[{"content":"就在这几天，也就是大一的第二个月，笔者补完了这部旷世神作（包括1、2、剧场版及所有番外篇），下面我说说自己的感受。\n轻音是什么意思？ ​\t从名字看，\u0026ldquo;轻音\u0026rdquo;🤔，是舒缓的轻音乐吗？不是，轻音其实是摇滚。到这里你肯定想到：这不就是这几年非常多的少女乐队作品吗？没错，但是请注意它于2009年4月开播，因此可以说它是定义了整个少女乐队番的开山之作（确实是当之无愧的老资历）。\n轻音主要讲了什么 ​\t无论怎么说，轻音也是废萌番的开创者（也就是无目的的卖萌，且全片大部分时间都在卖萌） 表面上《轻音少女》讲述的是五个少女在高中时期组建轻音部、练习乐器、举办演出的故事。剧情朴实，甚至平淡，没有跌宕起伏的冲突，也没有刻意煽情的桥段。但正因为如此，它显得格外真诚。在那间小小的社团活动室里，少女们泡着茶、吃着点心、聊着天、偶尔练练琴——这就是她们的日常。可正是这些“无所事事”的日常，构成了她们青春最闪耀的部分。\n萌萌的平泽唯（也被称为呆唯） ​\t《轻音少女》的魅力在于它以极其细腻的笔触，捕捉了青春中那些不经意的温柔瞬间：迟到时的慌乱、合奏时的默契、毕业典礼上的拥抱与泪水……所有这些都被京阿尼用几乎完美的演出方式记录下来，让人仿佛也在那个阳光洒满木地板的活动室里，一起听着放学后的风声。\n轻音的内核是什么？ ​\t很多人说，《轻音少女》的核心是“乐队与友情”，但我更愿意称它为一部关于时间与成长的作品。轻音并没有讲述她们多么努力地追梦、如何登上大舞台，而是告诉我们：\n“青春的意义，不一定是要奔向远方，而是和喜欢的人一起度过当下。”\n​\t这是一个在“未来焦虑”中成长的世代所难以理解、却最需要的温柔。 ​\t当我在大一的第二个月看完《轻音》，正是我人生从“被安排好的阶段”走向“自由但未知的阶段”的时候。现在每天都有新的课程、新的朋友、新的困惑。那种不确定感，正是唯、澪、律、紬、梓喵在在结尾即将迎来的生活。她们也曾迷茫过、害怕分别过，但依然在笑着说：“来喝茶吧。” ​\t这种从容、纯粹的生活态度，是我在成年边缘最渴望抓住的东西。轻音告诉我：成长不一定要轰轰烈烈，有时候，慢下来、珍惜身边的人，就是一种了不起的勇气。\n为什么在这个时间点看《轻音》更打动我 ​\t如果说十几年前的观众在看《轻音》时感受到的是可爱与治愈，那么在今天、在我这个年纪再看，它更像一面时间的镜子。 ​\t当我坐在寝室的床边，回望刚结束不久的高中生活——那段总觉得漫长却又转瞬即逝的三年——我突然发现，原来我也曾有过那样的“轻音时光”。 ​\t只是那时的我被模拟考、升学和倒计时淹没，很少有机会停下来认真体会：和朋友汗洒绿茵场的畅快、课间一起吃零食的笑声、临近毕业时郁闷不已又假装镇定的自己。\n备考中的呆唯（真的在学习吗？） ​\t现在看《轻音》，我仿佛重新看见了那些被时间模糊掉的小瞬间。 ​\t唯她们喝茶聊天的悠闲、律的无厘头、澪的害羞、梓喵初入社团时的认真——都像是在提醒我，那些不起眼的日子其实也在闪闪发光。 ​\t而我当时或许没能察觉，只顾着向前走，直到现在才懂，那些看似平凡的时光，才是青春最难得的部分。\n​\t我们这一代人生活在高速运转的社会——信息爆炸、AI崛起、焦虑无处不在。我们被催促着“提升效率”“走在前面”，但《轻音》提醒我，人生不只是向前奔跑，还有停下来听听吉他的余音、和朋友一起笑着浪费的午后。\n​\t那种“慢”的力量，是轻音留给我们的礼物。 ​\t它不是反现代的，而是一种温柔的反思：\n我们在追逐未来的同时，是否还记得此刻的风有多温暖？\n结语 ​\t当五位少女在毕业演出上弹起最后一首歌、灯光洒下、观众欢呼的那一刻，我突然明白，《轻音少女》并不是在讲她们的青春结束了，而是告诉观众：你的青春正在开始。\n​\t而现在，我坐在宿舍的书桌前，窗外夜色温柔，校园的风吹动窗帘。也许若干年后，我也会像她们一样，在某个分别的瞬间，对朋友说一句——“谢谢你，一直以来。”\n​\t愿我们都能在自己的日常里，找到那份轻音的旋律。\nMusic Time! 结尾带来一首剧中几人告别时演奏的一首《相遇天使》，欢迎欣赏（当然您在剧中按照剧情顺其自然的收听更好）\n最后一次在学园祭上演出完的众人 ","date":"2025-11-01T09:58:38+08:00","image":"https://www.retr0.qzz.io/post/%E5%BD%B1%E8%A7%86/qy3.png","permalink":"https://www.retr0.qzz.io/p/%E6%81%B0%E5%88%B0%E5%A5%BD%E5%A4%84%E7%9A%84%E8%A1%A5%E5%AE%8C%E8%BD%BB%E9%9F%B3%E5%B0%91%E5%A5%B3%E8%A7%82%E5%90%8E%E6%84%9F/","title":"恰到好处的补完—《轻音少女》观后感"},{"content":"云服务器/云电脑的获取 方案一：阿里云（免费） 云电脑的购买（领取） 1.访问学生用券中心-阿里云云工开物，登录账号后点击领取 学生300元优惠券\n这期间可能会要求进行实名认证和学生认证，如实填写就好\n这个按钮原本是领取，领完之后就会变成“立即使用”\n2.现在我们往下翻看到下面有无影云电脑这一栏，点击它\n下面有这样几个产品：\n3.我们这里选择第四个：“个人版云电脑核时包：8000核时”，点击立即购买\n等待右面弹窗价格计算完毕为￥0.00元后点击立即购买（如下图）\n云电脑的启用 现在我们已经成功购买了8000核时的时长，但是注意，有时长并不代表我们有云电脑，因为阿里云的云电脑分为两个部分： 设备（有不同配置和有效期）+时长， 不过没关系，针对无影云电脑的新客户，阿里云会赠送有效期一个月的免费体验普通配置设备，但这对于我们仅需要挂机刷课的需求肯定是够的。\n1.接下来我们下载并安装无影云电脑客户端，网站无影客户端下载_无影云电脑_客户端下载_无影-阿里云\n下载Windows版本（如图）\n2.打开“无影云电脑”并登录你的阿里云账号后可以看到软件上方已经显示核时算力8000.0，同时下面有个免费试用的按钮，点击它\n3.在弹出的界面可以看到右下角的“本次应付 ￥0.00”，点击立即下单\n随后的云电脑名称随便填写，常用地就填你所在的地区，这样可以为你分配你附近的服务器，从而大大降低延迟\n用支付宝扫码开通免密支付（不会扣款）\n你肯定已经猜到了，这其实就是常见的首月免费试用，接下来开始扣款的常见方案，所以我们要取消连续订阅。\n4.点击左下角用户里的订单管理\n点击右面的订阅管理\n在弹出的窗口中点击取消连续订阅即可\n如果还是不放心的话可以去支付宝的 **设置-支付设置-自动续费/免密支付-免密支付-阿里云免密支付-关闭服务 **中彻底关闭。\n补充：到期了怎么办？ 别急,请注意我们之前领的是300元的优惠券,但是购买\u0026quot;个人版云电脑核时包：8000核时\u0026ldquo;只花了247.40元,因此我们还剩下52.6元的优惠券没用,好!所以我们现在购买这个产品:\n计算价格后仍为0.00元,这波羊毛是不是薅爽了\n接下来的配置就和上面一样了,不再过多叙述\n方案二:京东云(进阶：一年￥38) 我们访问双11大促-京东云\n这有个38一年的云主机，但是蹲点抢购，看你个人想法吧，实测不是特别难抢\n然后如果抢到了记得配置的时候系统选 Windows Server 2022 数据中心版 即可\n远程连接上跟普通电脑没啥区别\n云电脑的启动与配置 由于我们的需求是挂机刷课，因此要把断连自动关机的功能关闭，因此，我们点击云电脑列表里你刚才购买的云电脑的 管理-策略-断连定时关机/休眠 ，关闭这个开关即可 接下来我们启动云电脑，点击你的云电脑右下角的蓝色圆形按钮远程连接云电脑 进入云电脑桌面后打开Microsoft Edge浏览器，搜索“大学搜题酱插件”，点击如图所示的搜索结果\n在如下图的网页中点击“获取”，然后在上方的小弹窗中点击“添加扩展”\n安装完成后会弹窗让你用“大学搜题酱app”扫码登录\n接下来进入你的学习通后台开启一门（不要同时刷多门）课程即可\n‼️‼️‼️ 注意：云电脑端在刷课时手机端不要进入课程看视频或做题，否则会把云电脑上的账号顶掉,此外,强烈建议每天进入云电脑2-3次检查刷课是否正常,因为长时间刷课可能因为种种原因(如内存溢出,登录失效等)需要重新登录,你只要刷新一下网页重新登录即可.\n","date":"2025-11-18T11:24:14+08:00","image":"https://img1.dancihu.com/2023-10-31/a116a2e0-4624-8c67-900f-7e6165b9012f.jpg","permalink":"https://www.retr0.qzz.io/p/%E5%85%8D%E8%B4%B9%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B%E5%9F%BA%E4%BA%8E%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/%E4%BA%91%E7%94%B5%E8%84%91%E7%9A%84%E5%85%A8%E8%87%AA%E5%8A%A8%E5%88%B7%E8%AF%BE%E5%B9%B3%E5%8F%B0/","title":"[免费]保姆级教程：基于云服务器/云电脑的全自动刷课平台"},{"content":" 网盘 地址 使用说明 百度 Vite App 无使用条件,解析50个文件,大小限制 10TB 内(每日刷新) 百度 百度网盘资源搜索 因成本问题,该站点已经停止运行 百度 百度网盘资源搜索 需要获取解析密码,解析20个文件,大小限制 30GB 内(每日刷新) 夸克 Kdown - 夸克网盘解析 Free版本 需要获取解析密码,无数量限制,无大小限制 阿里 https://bw.01233.xyz/alipan 寄了 百度 KDown-Free - 百度网盘解析工具 需要获取解析密码,无数量限制,无大小限制 迅雷 客户端破解 因被投诉,已删除下架 安卓端下载器:AriaNgGUI\nPC端下载器:Motrix\n","date":"2025-11-08T20:57:28+08:00","permalink":"https://www.retr0.qzz.io/p/%E4%B8%BB%E6%B5%81%E7%BD%91%E7%9B%98%E8%A7%A3%E6%9E%90%E6%BB%A1%E9%80%9F%E4%B8%8B%E8%BD%BD-%E7%99%BE%E5%BA%A6%E5%A4%B8%E5%85%8B%E8%BF%85%E9%9B%B7%E9%98%BF%E9%87%8C/","title":"主流网盘解析,满速下载 ,(百度,夸克,迅雷,阿里)"},{"content":"一、行列式法（仅适用于系数矩阵$A$为$n$阶方阵，$n$为变量个数） 1. 线性齐次方程组（$Ax=0$） 若 $|A| \\neq 0$，方程组 只有零解； 若 $|A| = 0$，方程组 有无穷多非零解。 2. 线性非齐次方程组（$Ax=b$，$\\overline{A}=(A,b)$为增广矩阵） 若 $|A| \\neq 0$，方程组 有唯一解； 若 $|A| = 0$： 当 $r(A) \\neq r(\\overline{A})$ 时，方程组 无解； 当 $r(A) = r(\\overline{A})$ 时，方程组 有无穷多解。 二、矩阵的秩法（通用，无方阵限制） 1. 核心定义 $A$：系数矩阵； $\\overline{A}=(A,b)$：线性非齐次方程组的增广矩阵（齐次方程组无需增广矩阵）； $n$：变量个数。 2. 线性齐次方程组（$Ax=0$） 若 $r(A) = n$，方程组 只有零解； 若 $r(A) \u0026lt; n$，方程组 有无穷多非零解。 3. 线性非齐次方程组（$Ax=b$） 若 $r(A) \\neq r(\\overline{A})$，方程组 无解； 若 $r(A) = r(\\overline{A}) = n$，方程组 有唯一解； 若 $r(A) = r(\\overline{A}) \u0026lt; n$，方程组 有无穷多解。 ","date":"2025-11-21T20:45:26+08:00","permalink":"https://www.retr0.qzz.io/p/%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%E5%88%A4%E6%96%AD%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E8%A7%A3%E7%9A%84%E6%83%85%E5%86%B5/","title":"两种方法判断线性方程组解的情况"},{"content":"模块的定义和导入 模块（Module），是一个Python文件，以.py结尾。模块能定义函数，类和变量，模块里也能包含可执行的代码。\n**模块的作用：**python中有很多各种不同的模块,每一个模块都可以帮助我们快速的实现一些功能,比如实现和时间相关的功能就可以使用time模块我们可以认为一个模块就是一个工具包,每一个工具包中都有各种不同的工具供我们使用进而实现各种不同的功能.\n大白话：模块就是一个Python文件,里面有类、函数、变量等,我们可以拿过来用(导入模块去使用)\n模块的导入方式 模块在使用前需要先导入，语法如下：\n1 2 3 4 5 6 7 [from 模块名] import [模块 | 类 | 变量 | 函数 | *] [as 别名]\t# 中括号指可选内容 # 常用的组合形式如： import 模块名 from 模块名 import 类、变量、方法等 from 模块名 import * import 模块名 as 别名 from 模块名 import 功能名 as 别名 import 模块名： 基本语法（Quickstart）：\n1 2 3 4 5 6 # 导入时间模块 import time print(\u0026#39;开始运行\u0026#39;) # 让程序睡眠5秒（阻塞） time.sleep(5)\t# 注意此处语法是 模块名.方法名 print(\u0026#39;运行结束\u0026#39;) from 模块名 import 功能名： 基本语法（Quickstart）：\n1 2 3 4 5 6 # 导入时间模块的sleep方法 from time import sleep print(\u0026#39;开始运行\u0026#39;) # 让程序睡眠5秒（阻塞） sleep(5)\t# 注意此处语法是直接调用方法名 print(\u0026#39;运行结束\u0026#39;) from 模块名 import *： 基本语法（Quickstart）：\n1 2 3 4 5 # 导入时间模块的全部功能 from time import *\t# *表示全部的意思 print(\u0026#39;开始运行\u0026#39;) sleep(5)\t# 注意此处语法是直接调用方法名 print(\u0026#39;运行结束\u0026#39;) as定义别名 基本语法（Quickstart）：\n1 2 3 4 5 #模块别名 import time as t print(\u0026#39;hi\u0026#39;) t.sleep(3) print(\u0026#39;hello\u0026#39;) 1 2 3 4 5 # 功能别名 from time import sleep as s print(\u0026#39;hi\u0026#39;) s(3) print(\u0026#39;hello\u0026#39;) 自定义模块并导入 制作自定义模块 示例 Quickstart:\n创建模块文件module.py\n1 2 def test(a,b): print(a + b) 创建主文件main.py\n1 2 import module module.test(1,2) 注意：当导入多个模块的时候。且模块内有同名功能，当调用这个同名功能的时候，调用的是后导入的模块的功能\n例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 模块1 module1.py def test(a,b): print(a + b) # 模块2 module2.py def test(a,b): print(a - b) # 导入模块和调用功能代码 from module1 import test from module2 import test # 实际test函数是模块2中的函数 test(1,2)\t# 输出 -1 特殊变量的使用 __main__变量的使用 有些时候开发者编写好一个自定义模块后为了方便测试会直接在模块文件中写一些测试语句方便直接F5测试。\n但是这时如果将模块导入到其他项目中时那些测试语句也会被执行，所以我们需要一种方法使得直接运行模块文件时测试语句能正常运行，但是以导入模块的方式调用时又不会触发测试语句，因此我们需要使用__main__变量\n例如（Quickstart）：\n1 2 3 4 5 6 7 8 9 10 # 模块文件module.py def test(a,b): print(a + b) if __name__ == \u0026#39;__main__\u0026#39;: test(1,2) # 主文件 from module import test test(3,4)\t# 这样只会输出7 原理解释：任何文件在直接执行（如F5调试、双击运行）时其__name__参数的值都为__main__，但是在作为模块导入时其__name__参数的值是它自己的模块名，再结合上面的if代码，当文件直接运行时if为真所以运行下面的测试语句，当通过导入模块调用时，if不为真，进而不会执行接下来的代码\n__all__变量的使用 __all__变量是一个列表，里面包括了可以被导入的模块，如果一个模块文件中有__all__变量，当使用from xxx import *导入时，只能导入这个列表中的元素\n例如（Quickstart）：\n1 2 3 4 5 6 7 8 9 10 11 # 模块文件module.py __all__ = [\u0026#39;testA\u0026#39;] def testA(a,b): print(a + b) def testB(a,b): print(a - b) # 主文件 from module import * testA(1,2) 但是__all__变量并不妨碍你通过from module import testB指明某个方法来导入\n例如（Quickstart）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 # 模块文件module.py __all__ = [\u0026#39;testA\u0026#39;] def testA(a,b): print(a + b) def testB(a,b): print(a - b) # 主文件 from module import * from module import testB testA(1,2) testB(3,4) ","date":"2025-11-21T20:43:18+08:00","permalink":"https://www.retr0.qzz.io/p/9.2-%E6%A8%A1%E5%9D%97/","title":"9.2 模块"},{"content":" 当检测到一个错误时，Python解释器就无法继续执行了，反而出现了一些错误的提示，则就是所谓的“异常”，也就是我们常说的bug\n小插曲：bug单词的诞生\n早期计算机采用大量继电器工作,马克二型计算机就是这样的。\n1945年9月9日,下午三点,马克二型计算机无法正常工作了,技术人员试了很多办法,最后定位到第70号继电器出错。负责人哈珀观察这个出错的继电器,\n发现一只飞蛾躺在中间,已经被继电器打死。她小心地用摄子将蛾子夹出来,用透明胶布帖到“事件记录本”中,并注明“第一个发现虫子的实例。“自此之后,引发软件失效的缺陷,便被称为Bug。\n异常演示 例如，以r方式打开一个不存在的文件\n1 f = open(\u0026#39;test.txt\u0026#39;,\u0026#39;r\u0026#39;) 执行结果：\n1 Traceback (most recent call last): File \u0026#34;/home/cloudlab/main.py\u0026#34;, line 1, in \u0026lt;module\u0026gt; f = open(\u0026#39;test.txt\u0026#39;,\u0026#39;r\u0026#39;)FileNotFoundError: [Errno 2] No such file or directory: \u0026#39;test.txt\u0026#39; 异常的捕获 捕获常规异常： 基本语法：\n1 2 3 4 try: 可能发生错误的代码 except: 如果出现异常执行的代码 QuickStart：\n需求：尝试以r模式打开文件，如果文件不存在，则以w模式打开\n1 2 3 4 try: f = open(\u0026#39;test.txt\u0026#39;,\u0026#39;r\u0026#39;) except: f = open(\u0026#39;test.txt\u0026#39;,\u0026#39;w\u0026#39;)\t# 运行发现没有报错 捕获指定异常： 基本语法：\n1 2 3 4 try: 可能发生错误的代码\texcept 异常名称: 如果出现异常执行的代码 QuickStart：\n1 2 3 4 try: print(name)\t# 如果直接运行该行代码会报错NameError except NameError as e:\t# 此处as后加变量可以把错误信息赋值给该变量，方便后面print查看等 print(\u0026#39;name变量名称未定义错误\u0026#39;,\u0026#39;错误为：\u0026#39;，e) 捕获多个异常： 基本语法：\n1 2 3 4 try: 可能发生错误的代码 except(异常名称1,异常名称2,异常名称3): 如果出现异常执行的代码 QuickStart：\n1 2 3 4 try: print(1/0) except(NameError,ZeroDivisionError) as e: print(\u0026#39;出错了！\u0026#39;,\u0026#39;错误是：\u0026#39;,e) 捕获全部异常： 第一种： 同 2.1 捕获常规异常 1 2 3 4 try: 可能发生错误的代码 except: 如果出现异常执行的代码 第二种： 1 2 3 4 try: 可能发生错误的代码 except Exception as e:\t# Exception可指代全部异常 如果出现异常执行的代码 异常之else else表示的是如果没有异常要执行的代码。\n1 2 3 4 5 6 try: print(1)\texcept Exception as e: print(e) else: print(\u0026#39;没有错误发生！\u0026#39;) 异常之finally finally表示的是无论是否异常都要执行的代码，例如关闭文件。\n1 2 3 4 5 6 7 8 try: f = open(\u0026#39;test.txt\u0026#39;,\u0026#39;r\u0026#39;)\texcept Exception as e: f = open(\u0026#39;test.txt\u0026#39;,\u0026#39;w\u0026#39;) else: print(\u0026#39;没有错误发生！\u0026#39;) finally: f.close() 异常的传递 解释：\n无捕获时： 1 2 3 4 5 6 7 8 9 10 11 12 13 def func01(): print(\u0026#39;这是func01开始\u0026#39;) nmu = 1 / 0 print(\u0026#39;这是func01结束\u0026#39;) def func02(): print(\u0026#39;这是func02开始\u0026#39;) func01() print(\u0026#39;这是func02结束 \u0026#39;) def main(): func02() main() 输出及报错内容：\n这是func02开始\nTraceback (most recent call last):\nFile \u0026quot;/home/cloudlab/main.py\u0026quot;,line 13, in \u0026lt;module\u0026gt;\n这是func01开始\nmain()\nFile \u0026quot;/home/cloudlab/main.py\u0026quot;,line 12, in main\nfunc02()\nFile \u0026quot;/home/cloudlab/main.py\u0026quot;,line 8, in func02\nfunc01()\nFile \u0026quot;/home/cloudlab/main.py\u0026quot;,line 3, in func01\nnmu = 1 / 0\nZeroDivisionError: division by zero\n注意观察报错中错误所在代码行数的变化，体现了异常的传递\n有捕获时： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def func01(): print(\u0026#39;这是func01开始\u0026#39;) nmu = 1 / 0 print(\u0026#39;这是func01结束\u0026#39;) def func02(): print(\u0026#39;这是func02开始\u0026#39;) func01() print(\u0026#39;这是func02结束 \u0026#39;) def main(): try: func02() except Exception as e: print(\u0026#39;检测到异常!\u0026#39;,e) main() # 输出结果： # 这是func02开始 # 这是func01开始 # 检测到异常! division by zero 输出内容：\n这是func02开始\n这是func01开始\n检测到异常! division by zero\n当函数func01中发生异常,并且没有捕获处理这个异常的时候,异常\n会传递到函数func02,当func02也没有捕获处理这个异常的时候\nmain函数会捕获这个异常,这就是异常的传递性.\n而且代码再按步骤执行时一旦遇到异常就会立即停止接下来的步骤，除非被捕获\n","date":"2025-11-19T22:22:08+08:00","permalink":"https://www.retr0.qzz.io/p/9.1-%E5%BC%82%E5%B8%B8/","title":"9.1 异常"},{"content":" 本篇课程使用资源库内的“win10渗透测试工具预安装虚拟机（日常使用）”\n抓包 环境准备 Java环境准备 打开C:\\tools\\alltools\\java环境中的jre-8u261-windows-x64.rar压缩包，解压并安装Java 安装完成后按win+R打开“运行”窗口，输入cmd并回车进入命令行控制台。 分别输入java和javac均有内容返回则说明安装成功。 Burpsuite软件的准备 打开C:\\tools\\alltools\\抓包工具中的Burpsuitepro_Unlimited_jb51.rar压缩包并解压到合适的位置。 在解压的文件夹内创建一个.bat批处理文件用于启动Burpsuite，名称随便，内容为： 1 java -jar BurpUnlimited.jar 双击该批处理文件即可启动Burpsuite,一路next进入软件界面。 检查并确认Options选项卡中监听地址和端口为127.0.0.1:8080 Firefox浏览器的准备（需要开着Burpsuite） 打开Firefox浏览器，并转到选项中，在高级-网络-连接-设置中选择“手动配置代理”并勾选为所有协议使用相同代理，填写好之前获取的地址和端口。 在地址栏输入http://burp/能进入页面说明配置成功，接下来点击页面右上角的‘CA Certificate’按钮保存证书。 再次转到浏览器的选项中，在高级-证书-查看证书-证书机构-导入中选择刚才保存到证书导入，弹窗内全部勾上。 证书机构的列表中多出名为PortSwigger CA的证书则导入成功。 Charles软件的准备（可选） 打开位于C:\\tools\\Charles内的Charles.exe 点击代理选项，可以看到默认勾选了Windows代理，说明Charles默认使用系统代理的方法抓包，也因此能抓取系统上所有软件的http数据包。\n正如上述，我们需要在浏览器的代理设置中更改为：**使用系统代理 **（1.1.3中提到） 因为未知原因，charles的证书不能从本地保存后导入，所以这里我们选择 **帮助-SSL代理-在移动设备或远程浏览器上安装Charles根证书 **点击后出现弹窗，例如： 这里我们只看后面的chls.pro/ssl在浏览器中访问该地址。\n安装证书的操作不再过多叙述。\n抓包实操 Burp抓包 在Burp软件内Proxy-Intercept选项卡中点击Intercept is off开始抓包\n此时在百度上搜索任意关键词（以\u0026quot;test\u0026quot;为例）可以看到抓取到数据包\n修改数据包首行wd参数值为\u0026quot;ok\u0026quot;\n点击Intercept is on放行数据包\n发现搜索关键词被替换为\u0026quot;ok\u0026quot;\nCharles抓包 打开Charles软件并访问百度\n发现抓取到数据包，查看内容发现与页面原代码一致\nweb基本知识 一些术语：\nGET 通过地址栏输入===从服务器获取\nPOST 提交表单===向服务器发送\nrequest 向服务器发起一个请求，服务器会返回一个结果(response)给客户端\n**forward **服务器内部发送重定向（网页发生改变但地址不变）\n**redirect **服务器收到一个请求后，发送一个状态给客户端，客户端会再次请求，此时url发生了改变\n**url **统一资源定位器（链接）\nurl的组成，以百度搜索为例：\nhttps:// www.baidu.com/ s ? wd=test \u0026amp; rsv_spt=1 \u0026amp; issp=1 \u0026amp; f=8\nhttp:// == 协议\nwww.baidu.com == 域名\ns == 文件\n？== get请求\nwd/rsv_spt/issp/f == 参数名\n参数名等号后为参数值\n\u0026amp; == 连接符\n","date":"2025-11-17T15:59:43+08:00","permalink":"https://www.retr0.qzz.io/p/1.1-%E6%8A%93%E5%8C%85%E5%92%8Cweb%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/","title":"1.1 抓包和web基本知识"},{"content":"部分虚拟机的密码在文件名上\n===============================\n日常工具（包含VMware以及其他常用小工具）\n链接：https://pan.baidu.com/s/1Cas0WpP1XkOf8Blh0pOFSw\n提取码：67uq\nvmware激活\nvmware17.5.2激活（本机为win11系统使用）\nMC60H-DWHD5-H80U9-6V85M-8280D\nvmware17.5.2安装参考\nhttps://word.huayunsys.com/thread-688-1-1.html\n=============================\nwin10渗透测试工具预安装虚拟机（日常使用）\nhttps://pan.baidu.com/s/1VydYshBifpLR1U7tLowyBA\n提取码: zy7p\nparrot渗透src工具预安装虚拟机（日常使用）\n链接: https://pan.baidu.com/s/1GOqLxz-tCSIGZrX2TLeaZg\n提取码: qjp7\n=============================\nkali预安装虚拟机系列\nkali2018 x64（预安装）-优先使用（文件传输使用bitvise）\n链接: https://pan.baidu.com/s/10lm6F5UO0q2f16kRVKXRqw\n提取码: 6s8i\nkali 2025-1 x64位（预安装）\n链接: https://pan.baidu.com/s/1gXSP1me3Z6djvsFJjV7-Jw 提取码: c2sd\nkali2023.2 with Clash（需要高版本kali实验以及全局vpn使用）\n链接：https://pan.baidu.com/s/1h-2pY_NmDEWzD5ve_sadLw\n提取码：a7vm\n关于v2ray转clash配置的生成地址\nhttps://acl4ssr-sub.github.io/\nkali 1.0.6 x64位（预安装）\n链接：https://pan.baidu.com/s/1fE6sTVYLNXVi1wokT0GE_w\n提取码：oe8g\n=========================\n空靶机系列\nwin7nosp预安装虚拟机（适合渗透测试实验，自带chrome，phpstudy，无vmwaretools）\n链接：https://pan.baidu.com/s/1ZIEB06P727Fau6afz5zI1A 提取码：pvql\nwin7sp1预安装虚拟机（适合普通实验）\n链接：https://pan.baidu.com/s/1adkc-lYiw2IRc2ztpTWVjg 提取码：dvl5\nwin10预安装虚拟机链接（普通实验靶机）：\n链接: https://pan.baidu.com/s/1qWT4DeG8uujcsjgpeFBWjg 提取码: bpat\n===============================\n特殊实验虚拟机\nsrc挖洞虚拟机\n链接: https://pan.baidu.com/s/1QTZJ1ExIyYKkEEj-hTV8Gw 提取码: mesk\nparrot预安装虚拟机\n链接：https://pan.baidu.com/s/1m9GAPluSlkeb1ul8qYW2ag 提取码：mo8m\nwin2019数据中心版预安装虚拟机\n链接: https://pan.baidu.com/s/1P8VXiwHay9HpA6BshBI6tw 提取码: cbl9\nwin2012标准版预安装虚拟机\n链接: https://pan.baidu.com/s/1leMe8dBmf1A0R9xA-0N0aA 提取码: voou\nwin2008企业版预安装虚拟机+phpstudy\n链接：https://pan.baidu.com/s/1gAhA8A14HL5zXXJTFRGNDQ 提取码：97fa\ncentos7普通预安装虚拟机\n链接: https://pan.baidu.com/s/1vU6w6jJ58C9v9wxnGOEr0Q 提取码: f1c4\ncentos7预安装phpstudy\n链接: https://pan.baidu.com/s/1pol4yliVnnau9LqsM0nUjw 提取码: xtmv\ncentos7预安装redis\n链接: https://pan.baidu.com/s/1sdIu2_96xr5M7xG5EIOivQ 提取码: qyv8\ncentos7预安装docker\n链接: https://pan.baidu.com/s/1bZqqRKEAQH0FdEzxvnHmBA 提取码: 1vr3\n云安全3台centos7预安装k8s\n链接: https://pan.baidu.com/s/1awjXfkR4xRitkenSyPpn_w 提取码: 9ieh\nubuntu x64 20.04.3预安装虚拟机\n链接: https://pan.baidu.com/s/1PIRuo1h4RBxegqYIkMFx2g 提取码: rcsd\n域环境3台虚拟机（用户名密码都在文件名中）\n链接: https://pan.baidu.com/s/1oq4bG4ecWaB97324V91GCw 提取码: 174l\n预安装防火墙Monowall\n链接: https://pan.baidu.com/s/1EBYTLw_U74z6uj18UIA-Yw 提取码: wkvh\n=====================\n特殊情况\n苹果m1芯片win10虚拟机\n链接：https://pan.baidu.com/s/1cRvML1jPv6JfGBYfhAwEkA\n提取码：3r0j\n=========================\n渗透+逆向工程虚拟机\nwin7完整滲透測試+逆向工程工具預安裝虛擬機\n链接：https://pan.baidu.com/s/1r6AhgRLtkciqyUtep7okcA\n提取码：5z9u\n=====================\nctf版win10预安装虚拟机\nwin10-ctf.ova\n链接: https://pan.baidu.com/s/1wGtsdYzBIr4GcnjHxmh4lQ 提取码: pzjj\n=====================\n安全靶场类\n链接：https://pan.baidu.com/s/1dmU9DcXAthjY0te4qv4tAg\n提取码：38mj\n代码审计源码类\n链接：https://pan.baidu.com/s/1VU5IZAMXSmSrerN69-502w\n提取码：p7vj\nmisc类\n链接：https://pan.baidu.com/s/10d_oMAABD1sulW83qbDMtA\n提取码：hk03\n数字取证类\n链接：https://pan.baidu.com/s/11yOS0eQajxSnSqQ8xHQFgA\n提取码：qfux\n========================\n逆向工程实验包\nhttps://pan.baidu.com/s/1lwAKPU6leg2A1bJX7LMyUg\n提取码: 8pj5\n=========================\nctf系列实验包\n链接：https://pan.baidu.com/s/1ZPfV05b7AoL4CF2Ex9wHwg\n提取码：qafo\n==========================\nAOME备份还原系统\n链接：https://pan.baidu.com/s/1xwEQC4d0ub5S3pg78fGPrA\n提取码：8cnu\n============================\n游戏外挂辅助学习\n链接: https://pan.baidu.com/s/1MLKND0RapwTPxW2ciOC1Wg\n提取码: h4bm\n免杀工具包\n链接: https://pan.baidu.com/s/17Rd6YAYhgHDv5u7pteWWJw\n提取码: 3f1d\nweb漏洞.rar\n链接: https://pan.baidu.com/s/1YA7RjBa4-ibrkxyhWJfz0A\n提取码: wcgt\n服务攻防\n链接无法分享\n红队工具\nhttps://pan.baidu.com/s/1AYGBjVYVKlDx9AEF_maiPQ\n提取码: em5w\n蓝队工具\nhttps://pan.baidu.com/s/1Zkc1vCsonzZBQ2Q2stZQNA\n提取码: hw32\n免杀webshell\nhttps://pan.baidu.com/s/1plbtPsJllE4fetMcAmtU4g\n提取码: 7inr\n信息收集补充\n链接: https://pan.baidu.com/s/1P8HoH3jMPwTIXf-ji6Scsg\n提取码: gfhg\n云安全工具\n链接: https://pan.baidu.com/s/1l-FMgaccQlrxhFJHakGvNA\n提取码: q9ev\nONE-FOX集成工具箱_V6\n链接: https://pan.baidu.com/s/1gu5Z7z2Ls6wW_8FOSOEH0A\n提取码: exxx\n移动终端工具(密码huayunsys.com).rar\n链接: https://pan.baidu.com/s/1gNQ-okYjgeg7aoz6Cono0Q\n提取码: x227\n===========================\nvulfocus靶场\n链接: https://pan.baidu.com/s/1YPJfsN6WFwA7Q9viE8ejLg\n提取码: wbsv\nsnort2虚拟机\n链接: https://pan.baidu.com/s/1oZpepxjTHY5qLqYb5UD4IQ\n提取码: 4fsi\n雷池虚拟机\n链接: https://pan.baidu.com/s/1tByIap_RTrLPFwKRfAaxBA\n提取码: ceuv\n蜜罐虚拟机\n链接: https://pan.baidu.com/s/1u3EauAmLuILovlcbe-cGnw\n提取码: akvm\nsuicata虚拟机\n链接: https://pan.baidu.com/s/1uImCWMW_LttEbFrEae5n-Q\n提取码: sg9t\njumpserver堡垒机\n链接: https://pan.baidu.com/s/1fUJFAkUPg99f6g72oELVBA\n提取码: gvi5\nMobexler\n链接: https://pan.baidu.com/s/1OFdDyEkyNiWP5ms2IEMrEg\n提取码: 2nm8\nELK日志分析\n链接: https://pan.baidu.com/s/176TUQmmRjwGmuQhuPFLCuw\n提取码: s73m\nHIDS-Wazuh\n链接: https://pan.baidu.com/s/1s7_Xh6XOJ9Ea648gJnOeNw\n提取码: e6rv\n==========================\nwin10-java8预安装虚拟机\n链接: https://pan.baidu.com/s/1QEAM5-apx8UKn1ZijQZ8IQ\n提取码: m9wd\n===========================\nwin10-vc2022-qt预安装虚拟机\n链接: https://pan.baidu.com/s/18BudoNm569KZk4ildcODJw\n提取码: 79qu win10-ctf虚拟机\n链接: https://pan.baidu.com/s/1ayzi1gzJGmiiNo1KBVo3kA\n提取码: ku4v\n============================\n","date":"2025-11-17T15:58:53+08:00","permalink":"https://www.retr0.qzz.io/p/0.%E5%AE%89%E5%85%A8%E7%B1%BB%E5%B7%A5%E5%85%B7%E6%96%87%E4%BB%B6%E8%B5%84%E6%BA%90%E5%BA%93/","title":"0.安全类工具文件资源库"},{"content":"例： 需求：有一份账单文件，记录了消费收入的具体记录，内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 name, date, money, type, remarks 周杰轮,2022-01-01,100000,消费,正式 周杰轮,2022-01-02,300000,收入,正式 周杰轮,2022-01-03,100000,消费,测试 林俊节,2022-01-01,300000,收入,正式 林俊节,2022-01-02,100000,消费,测试 林俊节,2022-01-03,100000,消费,正式 林俊节,2022-01-04,100000,消费,测试 林俊节,2022-01-05,500000,收入,正式 张学油,2022-01-01,100000,消费,正式 张学油,2022-01-02,500000,收入,正式 张学油,2022-01-03,900000,收入,测试 王力鸿,2022-01-01,500000,消费,正式 王力鸿,2022-01-02,300000,消费,测试 王力鸿,2022-01-03,950000,收入,正式 刘德滑,2022-01-01,300000,消费,测试 刘德滑,2022-01-02,100000,消费,正式 刘德滑,2022-01-03,300000,消费,正式 将内容复制保存为bill.txt\n任务：\n读取文件 将文件写出到bill.txt.bak文件作为备份 同时，将文件内标记为测试的数据行丢弃 实现思路：\nopen和r模式打开一个文件对象,并读取文件 open和w模式打开另一个文件对象,用于文件写出 for循环内容,判断是否是测试不是测试就write写出,是测试就continue跳过 将2个文件对象均close() 代码演示：\n1 2 3 4 5 6 7 8 9 10 f = open(\u0026#39;F:/bill.txt\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#39;UTF-8\u0026#39;) g = open(\u0026#39;F:/bill.txt.bak\u0026#39;,\u0026#39;a\u0026#39;,encoding=\u0026#39;UTF-8\u0026#39;) for line in f: if line.count(\u0026#39;测试\u0026#39;) == 0: g.write(line) g.flush() else: continue f.close() g.close() ","date":"2025-11-16T22:37:55+08:00","permalink":"https://www.retr0.qzz.io/p/8.3-%E7%BB%83%E4%B9%A0%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9A%84%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B/","title":"8.3 练习：文件操作的综合案例"},{"content":"文件的从头写入 文件不存在 1 2 3 4 5 6 7 8 9 10 11 # 1.创建文件 f = (open(\u0026#39;python.txt\u0026#39;,\u0026#39;w\u0026#39;)) # 2.文件写入 f.write(\u0026#39;hello world\u0026#39;) # 3.内容刷新 f.flush() # 4.文件关闭 f.close() 注意：\n直接调用write，内容并未真正写入文件，而是会积攒在程序的内存中，称之为缓冲区 当调用flush的时候，内容会真正写入文件 这样做是避免频繁的操作硬盘，导致效率下降（攒一堆，一次性写磁盘） 文件已经存在 w模式会直接打开已有文件并清空所有内容\n其他与上述示例代码相同。\n文件的追加写入 1 2 3 4 5 6 7 8 9 10 11 # 1.打开文件，通过a模式打开即可 f = open(\u0026#39;python.txt\u0026#39;,\u0026#39;a\u0026#39;) # 文件写入 f.write(\u0026#39;hello world\u0026#39;) # 3. 内容刷新 f.flush() # 4.文件关闭 f.close() 注意：\na模式，文件不存在会创建文件 a模式，文件存在会在最后，追加写入文件 换行操作可以通过在写入内容中加入\u0026rsquo;\\n\u0026rsquo; 实现\n","date":"2025-11-15T21:50:41+08:00","permalink":"https://www.retr0.qzz.io/p/8.2-%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%99%E5%85%A5%E6%93%8D%E4%BD%9C/","title":"8.2 文件的写入操作"},{"content":"证明两个矩阵等价的核心方法（简要版） 矩阵等价的核心定义：设$A$、$B$为$m \\times n$同型矩阵，若存在$m$阶可逆矩阵$P$和$n$阶可逆矩阵$Q$，使得$PAQ = B$，则$A$与$B$等价。\n关键充要条件（满足其一即可证明） 秩相等：$r(A) = r(B)$（最常用，无需构造可逆矩阵，计算秩即可）； 初等变换互化：$A$可通过有限次初等行/列变换化为$B$； 等价标准形相同：$A$和$B$的等价标准形均为$\\begin{pmatrix} I_r \u0026amp; O \\ O \u0026amp; O \\end{pmatrix}$（$r$为秩，$I_r$为$r$阶单位矩阵）。 简要证明思路 先验证$A$与$B$是同型矩阵（行数、列数一致，否则必不等价）； 任选上述充要条件验证： 便捷法：计算$r(A)$和$r(B)$，若相等则等价； 严谨法：通过初等变换将$A$化为$B$，或构造$P$、$Q$使$PAQ = B$。 ","date":"2025-11-14T23:41:10+08:00","permalink":"https://www.retr0.qzz.io/p/%E8%AF%81%E6%98%8E%E7%9F%A9%E9%98%B5%E7%AD%89%E4%BB%B7/","title":"证明矩阵等价"},{"content":"一、行列式的核心计算方法及适用情况 1. 定义法 核心思路：直接利用n阶行列式的定义（所有$n!$项的代数和），即：\n$$|A| = \\sum_{p_1p_2\\cdots p_n} (-1)^{\\tau(p_1p_2\\cdots p_n)} a_{1p_1}a_{2p_2}\\cdots a_{np_n}$$\n其中$\\tau$是排列$p_1p_2\\cdots p_n$的逆序数。 适用情况： 1阶、2阶行列式（直接计算，无需简化）； 高阶行列式但零元素极多（非零项仅1-2项，可快速筛选）。 优点：直观、无需额外技巧；缺点：高阶（≥3阶）非零项多，计算量爆炸。 2. 按行（列）展开法（降阶法） 原理：行列式等于它的任意一行(列)各元素与其对应的代数余子式乘积之和，即 $$D=a_{i1}A_{i1}+a_{i2}A_{i3}+ \\cdots +a_{in}A_{in} (i=1,2, \\cdots ,n) $$ 核心思路：利用行列式展开定理，将n阶行列式按某行（列）展开为n个n-1阶行列式的线性组合：\n$$|A| = \\sum_{j=1}^n a_{ij}A_{ij} \\quad (\\text{按第}i\\text{行展开})$$\n其中$A_{ij}=(-1)^{i+j}M_{ij}$（$M_{ij}$为余子式）。 适用情况： 某行（列）零元素≥n-2个（直接展开后计算量小）； 可通过初等变换（如某行加另一行的$k$倍）快速造出一行（列）多零元素。 关键技巧：优先选择零元素最多的行（列）展开，减少计算量。 3. 初等变换法（化三角法） 核心思路：利用行列式的初等变换性质，将行列式化为上三角行列式（主对角线下方全为0）或下三角行列式（主对角线上方全为0），三角行列式的值=主对角线元素乘积：\n$$\\begin{vmatrix} a_{11} \u0026 a_{12} \u0026 \\cdots \u0026 a_{1n} \\\\ 0 \u0026 a_{22} \u0026 \\cdots \u0026 a_{2n} \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 a_{nn} \\end{vmatrix} = a_{11}a_{22}\\cdots a_{nn}$$ 适用情况： 任意n阶行列式（3阶及以上最常用）； 元素无明显规律、零元素少的普通行列式。 常用变换：换行变号、某行乘非零常数、某行加另一行的$k$倍（不改变行列式值）。 4. 递推法 核心思路：通过展开或变换，建立n阶行列式$D_n$与低阶行列式（$D_{n-1}$、$D_{n-2}$）的递推关系（如$D_n = pD_{n-1} + qD_{n-2}$），求解递推公式得结果。 适用情况： 具有带状结构的行列式（如三对角行列式）； 结构对称、元素按规律重复的行列式（如$n$阶循环行列式）。 示例：三对角行列式（主对角线及相邻两条对角线非零，其余为0）：\n$$D_n = \\begin{vmatrix} a \u0026 b \u0026 \u0026 \\\\ c \u0026 a \u0026 b \u0026 \\\\ \u0026 c \u0026 a \u0026 \\ddots \\\\ \u0026 \u0026 \\ddots \u0026 \\ddots \u0026 b \\\\ \u0026 \u0026 \u0026 c \u0026 a \\end{vmatrix}$$\n展开后得递推关系$D_n = aD_{n-1} - bcD_{n-2}$，结合初始条件$D_1=a$、$D_2=a^2-bc$求解。 5. 数学归纳法 核心思路：先验证$n=1$（或$n=2$）时行列式等式成立，假设$n=k$时成立，证明$n=k+1$时也成立，从而推广到所有$n$。 适用情况： 已知行列式结果（需证明）； 结构具有明显递推规律的行列式（如范德蒙德行列式、高阶对称行列式）。 二、特殊结构行列式的专门解法及适用情况 1. 三角/对角行列式（含数量矩阵） 结构特征： 上三角：主对角线下方全为0；下三角：主对角线上方全为0； 对角行列式：仅主对角线非零（三角行列式的特例）。 适用情况：直接符合上述结构，或可通过1-2步初等变换化为该结构。 解法：直接取主对角线元素的乘积，即$|A| = \\prod_{i=1}^n a_{ii}$。 2. 范德蒙德行列式（Vandermonde Determinant） 结构特征：第$i$行（或列）为变量$x_1,x_2,\\cdots,x_n$的0到$n-1$次幂，形式如下：\n$$V_n = \\begin{vmatrix} 1 \u0026 1 \u0026 \\cdots \u0026 1 \\\\ x_1 \u0026 x_2 \u0026 \\cdots \u0026 x_n \\\\ x_1^2 \u0026 x_2^2 \u0026 \\cdots \u0026 x_n^2 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ x_1^{n-1} \u0026 x_2^{n-1} \u0026 \\cdots \u0026 x_n^{n-1} \\end{vmatrix}$$ 适用情况：完全符合上述结构，或可通过转置、换行（列）调整为该结构（注意换行变号）。 解法：直接套用公式（所有变量两两差的乘积）：\n$$V_n = \\prod_{1 \\leq j \u003c i \\leq n} (x_i - x_j)$$ 关键提醒：若行列式是“列为幂次”，转置后仍为范德蒙德行列式（$|V_n^T|=|V_n|$）。 3. 爪型行列式（星形行列式） 结构特征：主对角线有非零元素，仅第一行、第一列（或最后一行、最后一列）有非零元素，其余为0，形如“爪”：\n$$D_n = \\begin{vmatrix} a_0 \u0026 b_1 \u0026 b_2 \u0026 \\cdots \u0026 b_n \\\\ c_1 \u0026 a_1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ c_2 \u0026 0 \u0026 a_2 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ c_n \u0026 0 \u0026 0 \u0026 \\cdots \u0026 a_n \\end{vmatrix} \\quad (a_i \\neq 0)$$ 适用情况：严格符合“主对角线+第一行+第一列”的爪形结构（无其他非零元素）。 解法：消去第一列（或第一行）的非零元素，化为对角行列式：\n第$i$行（$i\\geq2$）减去$\\frac{c_i}{a_i} \\times$第1行，得：\n$$D_n = \\begin{vmatrix} a_0 - \\sum_{i=1}^n \\frac{b_i c_i}{a_i} \u0026 b_1 \u0026 b_2 \u0026 \\cdots \u0026 b_n \\\\ 0 \u0026 a_1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 a_2 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 0 \u0026 \\cdots \u0026 a_n \\end{vmatrix} = \\left( a_0 - \\sum_{i=1}^n \\frac{b_i c_i}{a_i} \\right) \\prod_{i=1}^n a_i$$ 4. 箭型行列式（特殊爪型） 结构特征：仅第一行、最后一行、第一列、最后一列有非零元素，其余为0，形如“箭”：\n$$D_n = \\begin{vmatrix} a \u0026 b \u0026 \u0026 \u0026 c \\\\ d \u0026 a_2 \u0026 \u0026 \u0026 \\\\ \u0026 \u0026 a_3 \u0026 \u0026 \\\\ \u0026 \u0026 \u0026 \\ddots \u0026 \\\\ e \u0026 \u0026 \u0026 \u0026 a_n \\end{vmatrix} \\quad (a_i \\neq 0)$$ 适用情况：符合“四边非零、中间全零”的箭形结构。 解法：用第一列或最后一列的非零元素消去第一行、最后一行的非零元素，化为三角行列式。 5. 分块行列式 结构特征：矩阵可分块为对角块、上三角块或下三角块，例如： 分块对角：$A = \\begin{pmatrix} A_1 \u0026amp; O \\ O \u0026amp; A_2 \\end{pmatrix}$（$O$为零矩阵）； 分块上三角：$A = \\begin{pmatrix} A_1 \u0026amp; B \\ O \u0026amp; A_2 \\end{pmatrix}$。 适用情况：分块后非对角块为零矩阵（或可通过变换化为零块）。 解法：套用分块行列式公式： 分块对角：$|A| = |A_1| \\cdot |A_2| \\cdots |A_k|$； 分块上/下三角：$|A| = |A_1| \\cdot |A_2| \\cdots |A_k|$（仅需对角块非奇异）。 6. Hessenberg行列式 结构特征：上Hessenberg（主对角线下方仅一条非零元素带）或下Hessenberg（主对角线上方仅一条非零元素带）：\n$$D_n = \\begin{vmatrix} a_{11} \u0026 a_{12} \u0026 \\cdots \u0026 a_{1n} \\\\ a_{21} \u0026 a_{22} \u0026 \\cdots \u0026 a_{2n} \\\\ \u0026 a_{32} \u0026 \\cdots \u0026 a_{3n} \\\\ \u0026 \u0026 \\ddots \u0026 \\vdots \\\\ \u0026 \u0026 \u0026 a_{nn} \\end{vmatrix}$$ 适用情况：带状结构、非零元素集中在主对角线附近。 解法：按第一列（或最后一列）展开，建立递推关系求解。 三、方法选择优先级总结 先判断是否为特殊结构（范德蒙德、爪型、三角等）→ 直接套用专门公式； 若为普通行列式，先看是否有多零元素行（列） → 按行（列）展开降阶； 无明显零元素→ 用初等变换法化三角（3阶及以上首选）； 结构对称/带状→ 用递推法；需证明结果→ 用数学归纳法。 ","date":"2025-11-14T23:40:45+08:00","permalink":"https://www.retr0.qzz.io/p/%E7%AE%97%E8%A1%8C%E5%88%97%E5%BC%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/","title":"算行列式的几种方法"},{"content":" 多项式+余项=公式\n一、泰勒多项式（Taylor Polynomial） 定义 设函数$ f(x) $在点$ x = a $处$ n $阶可导，则以$ x = a $为中心的$ n $次泰勒多项式为： $$ P_n(x) = f(a) + f'(a)(x - a) + \\frac{f''(a)}{2!}(x - a)^2 + \\cdots + \\frac{f^{(n)}(a)}{n!}(x - a)^n $$核心特点 本质：用$ f(x) $在$ x = a $处的函数值及各阶导数值，构造多项式逼近$ f(x) $； 局部性：在$ a $的邻域内逼近效果好，阶数$ n $越高，逼近越精确。 二、麦克劳林多项式（Maclaurin Polynomial） 定义 泰勒多项式的特殊情况——当中心$ a = 0 $时，$ n $次麦克劳林多项式为： $$ P_n(x) = f(0) + f'(0)x + \\frac{f''(0)}{2!}x^2 + \\cdots + \\frac{f^{(n)}(0)}{n!}x^n $$核心特点 简化形式：无需考虑$ (x - a) $项，直接以$ x $的幂次展开； 适用场景：$ f(x) $在$ x = 0 $处易求各阶导数（如$ e^x $、$ \\sin x $、$ \\cos x $等）。 三、拉格朗日余项（Lagrange Remainder） 定义 泰勒公式中，$ f(x) $与泰勒多项式$ P_n(x) $的误差（定量余项），表达式为： $$ R_n(x) = \\frac{f^{(n+1)}(\\xi)}{(n+1)!}(x - a)^{n+1} $$ 其中$ \\xi $是介于$ a $与$ x $之间的某个数。\n核心特点 定量误差：给出误差的具体表达式，可精确估计逼近精度； 条件：要求$ f(x) $在$ a $的邻域内$ n+1 $阶可导。 四、佩亚诺余项（Peano Remainder） 定义 泰勒公式中，误差的定性描述（高阶无穷小余项），表达式为： $$ R_n(x) = o\\left((x - a)^n\\right) \\quad (x \\to a) $$核心特点 定性误差：仅说明“当$ x \\to a $时，误差是$ (x - a)^n $的高阶无穷小”，不给出具体大小； 条件：仅需$ f(x) $在$ x = a $处$ n $阶可导，要求比拉格朗日余项低。 ","date":"2025-11-14T23:40:16+08:00","permalink":"https://www.retr0.qzz.io/p/%E5%87%A0%E7%A7%8D%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%8F%8A%E4%BD%99%E9%A1%B9/","title":"几种多项式及余项"},{"content":"文件编码 文件的读取操作 open()打开函数 使用open函数，可以打开一个已经存在的文件，或者创建一个新文件，语法如下\nopen(name,mode,encoding)\nname：是要打开的目标文件名的字符串（可以包含文件所在的具体路径）\nmode：设置打开文件的模式（访问模式）：只读r、写入w、追加a等。\nencoding：编码格式（推荐使用UTF-8）\n示例：\n1 2 f = open(\u0026#39;python.txt\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#34;UTF-8\u0026#34;) # encoding的顺序不是第三位，所以不能用位置参数，用关键字参数直接指定 注意：此处‘f’是‘open’函数的文件对象，对象是Python中一种特殊的数据类型，拥有属性和方法可以使用对象.属性或对象.方法访问。\n模式 描述 r 以只读方式打开文件。文件的指针会放在文件的开头。这是默认模式。 w 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，原有内容会被删除。 a 打开一个文件用于追加。如果该文件已存在，新的内容会被写道已有内容之后。如果该文件**不存在，创建新文件**进行写入。 read()方法 文件对象.read(num) num表示要从文件中读取的数据的长度（单位是字符），如果没有传入num，那么就表示读取文件中所有的数据。\n例如：\n1 2 3 4 # 有test.txt文件内容为：abcdefghijk f = open(\u0026#39;test.txt\u0026#39;) print(f.read(3))\t# 输出abc print(f.read(5))\t# 输出defgh readlines()方法 readlines可以按照行的方式把整个文件中的内容进行一次性读取，并且返回的是一个列表，其中返回的是一个**列表**，其中每一行的数据为一个元素。\n示例：\n1 2 3 4 5 6 7 8 # 有python.txt文件内容为： # abc # def # ghi f = open(\u0026#39;python.txt\u0026#39;) content = f.readlines() print(content)\t# 输出[\u0026#39;abc\\n\u0026#39;,\u0026#39;def\\n\u0026#39;,\u0026#39;ghi\\n\u0026#39;] 此处\\n为换行符 f.close()\t# 关闭文件 注意：连续调用多次read或readlines，后面的read会接着前面的继续读取而不是从头开始，相当于每次读取时文本中会有一个指针再向后读取，读到最后就没有东西可读了\nreadline()方法 readline可以一次读取一行内容\n1 2 3 4 5 6 7 8 9 10 # 有python.txt文件内容为： # abc # def # ghi f = open(\u0026#39;python.txt\u0026#39;) content = f.readline() print(f\u0026#39;第一行:{content}\u0026#39;)\t# 输出 abc content = f.readline() print(f\u0026#39;第二行:{content}\u0026#39;)\t# 输出 def f.close for循环读取文件行 示例：\n1 2 for line in open(\u0026#39;python.txt\u0026#39;,\u0026#39;r\u0026#39;): print(line) 文件的关闭 前面已经有提到，以对象名为\u0026rsquo;f\u0026rsquo;为例：\nf.close()\nwith open()语法 通过在with open的语句块中对文件进行操作，可以在操作完成后自动关闭close文件，避免遗忘掉close方法\n以对象名为\u0026rsquo;f\u0026rsquo;为例：\n1 2 with open(\u0026#39;python.txt\u0026#39;,\u0026#39;r\u0026#39;)as f: f.readline() ","date":"2025-11-14T23:36:48+08:00","permalink":"https://www.retr0.qzz.io/p/8.1-%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%8F%96%E6%93%8D%E4%BD%9C/","title":"8.1 文件的读取操作"},{"content":"多个返回值的写法 1 2 3 4 5 def test(): return 1,2 a,b= test() print(a) print(b) 按照返回值的顺序，写对应的多个变量接收即可\n变量之间用逗号隔开\n支持不同类型的数据return\n函数的多种参数使用形式 位置参数 调用时根据函数定义的参数位置来传递参数\n1 2 3 def user_info(name,age,gender): print(f\u0026#39;您的姓名是{name}，年龄是{age}，性别是{gender}\u0026#39;)\t# 注意此处print内有f，意为在字符串内插入表达式 user_info(\u0026#39;Retr0\u0026#39;,18,\u0026#39;男\u0026#39;) 关键字参数 调用时通过“键=值”形式传递参数\n1 2 3 4 5 6 7 8 def user_info(name,age,gender): print(f\u0026#39;您的姓名是{name}，年龄是{age}，性别是{gender}\u0026#39;) # 关键字传参 user_info(name=\u0026#39;小明\u0026#39;,age=20,gender=\u0026#39;男\u0026#39;) # 可以不按照固定顺序 user_info(age=20,gender=\u0026#39;男\u0026#39;,name=\u0026#39;小明\u0026#39;) # 可以和位置参数混用，位置参数必须在前，且匹配参数顺序 user_info(\u0026#39;小明\u0026#39;,age=20,gender=\u0026#39;男\u0026#39;) 注意：函数调用时，如果有位置参数时位置参数必须在关键字参数的前面，但关键字参数之间不存在先后顺序\n缺省参数 也叫默认参数，用于定义函数，为参数提供默认值，调用函数时刻不传该默认参数的值\n注意：所有位置参数必须出现在默认参数前，包括函数定义和调用\n1 2 3 4 def user_info(name,age,gender=\u0026#39;男\u0026#39;): print(f\u0026#39;您的姓名是{name}，年龄是{age}，性别是{gender}\u0026#39;) user_info(\u0026#39;Retr0\u0026#39;,20) user_info(\u0026#39;小红\u0026#39;,20,\u0026#39;女\u0026#39;) 函数调用时，如果为缺省参数传值则修改默认参数值，否则使用这个默认值\n不定长参数 也叫可变参数，用于不确定调用的时候会传递多少个参数（不传参也可以）的场景\n类型包括：\n位置传递 1 2 3 4 def test(*args):\t# *标记表示args这个形式参数接收的参数数量无限，且采用位置传递 print(args) test(\u0026#39;Retr0\u0026#39;) test(\u0026#39;Retr0\u0026#39;,\u0026#39;18\u0026#39;) 传进的所有参数都会被args变量收集，它会根据传进参数的位置合并为一个元组，args是元组类型\n关键字参数 1 2 3 def test(**kwargs):\t# **标记表示kwargs这个形式参数接收的参数数量无限，且采用关键字传递 print(kwargs) test(name=\u0026#39;Retr0\u0026#39;,age=18,gender=\u0026#39;男\u0026#39;) 参数是“键=值”的形式的情况下，所有的“键=值”都会被kwargs接受，同时根据“键=值”组成字典\n函数作为参数传递 示例：\n1 2 3 4 5 6 def test(compute): result = compute(1,2) print(result) def compute(x,y): return x + y test(compute) 此处函数compute作为参数传入了test函数中使用\n实质上数据由test函数内部传入的compute函数进行计算\n所以这是一种**计算逻辑的传递，而非数据的传递，而任何逻辑都可以自行定义并作为函数传入**\nlambda匿名函数 众所周知，\ndef 关键字，可以定义带有名称的函数\n而 lambda关键字，可以定义匿名函数（无名称）\n有名称的函数，可以基于名称重复使用\n无名称的匿名函数，只能临时使用一次\n匿名函数定义语法 lambda 传入参数: 函数体(一行代码)\nlambda 是关键字，表示定义匿名函数 传入参数表示匿名函数的形式参数，如：x，y表示接收2个形式参数 函数体，就是函数的执行逻辑，要注意：只能写一行，无法写多行代码 例如：\n1 2 3 4 def test(compute): result = compute(1,2) print(result) test(lambda x,y:x+y) ","date":"2025-11-11T22:51:43+08:00","permalink":"https://www.retr0.qzz.io/p/7.1-%E8%BF%9B%E9%98%B6%E5%87%BD%E6%95%B0/","title":"7.1 进阶函数"},{"content":"统计容器的元素个数 len 前几篇中都有提到，不做演示\n统计容器的最大元素 max 1 2 list = [1,2,3,4,5] print(max(list)) 统计容器的最小元素 min 1 2 list = [1,2,3,4,5] print(min(list)) 注意：字符串的比较大小原则按照ASCII表顺序比较,从第一个字符开始一位位比较只要有一个字符大整体就大\n类型转换 1 2 3 4 5 6 7 list = [\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;e\u0026#39;] A = tuple(list) B = str(list) C = set(list) print(A,type(A)) print(B,type(B)) print(C,type(C)) 需要注意：\n字符串转列表\n1 2 s = \u0026#39;abcde\u0026#39; print(list(s))\t# 输出[\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;] 字典转列表\n1 2 dict = {\u0026#39;key1\u0026#39;:1,\u0026#39;key2\u0026#39;:2,\u0026#39;key3\u0026#39;:3} print(list(dict))\t# 输出[\u0026#39;key1\u0026#39;, \u0026#39;key2\u0026#39;, \u0026#39;key3\u0026#39;] 舍弃了value 字典转字符串\n1 2 dict = {\u0026#39;key1\u0026#39;:1,\u0026#39;key2\u0026#39;:2,\u0026#39;key3\u0026#39;:3} print(str(dict))\t# 输出{\u0026#39;key1\u0026#39;: 1, \u0026#39;key2\u0026#39;: 2, \u0026#39;key3\u0026#39;: 3} 全部保留 排序 此处为《数据容器：列表》2.9 列表的排序 的复制版本\n见链接 数据容器：列表\n默认升序（数字从小到大，首字母从前到后），且会修改当前列表\n1 2 3 4 5 6 list1 = [10, 8, 3, 22, 33, 7, 11, 100, 54] list2 = [\u0026#39;f\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;e\u0026#39;] list1.sort() list2.sort() print(list1) print(list2) 可选参数：reverse\t降序\n1 2 3 list = [1,2,3,4,5] list.sort(reverse=True) print(list) 可选参数：key\t自定义排序\n1 2 3 list = [\u0026#39;java\u0026#39;,\u0026#39;python\u0026#39;,\u0026#39;C++\u0026#39;,\u0026#39;go\u0026#39;] list.sort(key=len)\t#此处以长度为参考量，仅为其中一种用法 print(list) 你也可以将其组合\n1 2 3 list = [\u0026#39;java\u0026#39;,\u0026#39;python\u0026#39;,\u0026#39;C++\u0026#39;,\u0026#39;go\u0026#39;] list.sort(key=len,reverse=True)\tprint(list) sorted()函数 用法与sort()一致，但是不会修改列表本身，而是将修改后的列表创建一个副本。简而言之，你需要一个变量来接收它。\n1 2 3 list = [\u0026#39;java\u0026#39;,\u0026#39;python\u0026#39;,\u0026#39;C++\u0026#39;,\u0026#39;go\u0026#39;] a = sorted(list,key=len,reverse=True) print(a) 我们来比较一下二者的区别\n1 2 3 4 5 6 7 8 list1 = [5,4,3,2,1] list2 = [5,4,3,2,1] list3 = list1.sort() list4 = sorted(list2) print(list1)\t#[1, 2, 3, 4, 5]\t列表本身也被修改 print(list2)\t#[5, 4, 3, 2, 1]\t可见列表本身未被修改 print(list3)\t#None\t因为sort()函数不会传出修改后的列表 print(list4)\t#[1, 2, 3, 4, 5]\t","date":"2025-11-09T17:49:07+08:00","permalink":"https://www.retr0.qzz.io/p/6.7-%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8%E7%9A%84%E9%80%9A%E7%94%A8%E6%93%8D%E4%BD%9C/","title":"6.7 数据容器的通用操作"},{"content":" Python中，字典（Dictionary）是一种内置的数据结构，用于存储键值对的集合。它是一种可变容器，允许用户存储任意类型的对象。字典中的每个元素由一个键（key）和一个值（value）组成，键和值之间用冒号（:）分隔，而各个键值对之间用逗号（,）分隔，整个字典被包含在花括号（{}）中。\n字典的定义 字典标准格式 1 2 3 4 5 # 定义字典变量 dict = {key:value,key:value,……,key:value} # 定义空字典 dict = {} dict = dict{} 使用例：\n1 2 # 使用字典记录学生及其成绩 dict = {\u0026#39;小明\u0026#39;:80,\u0026#39;小华\u0026#39;:84,\u0026#39;小红\u0026#39;:90} 字典数据的获取 字典不支持下标索引，可以通过Key值来取得对应的Value\n1 2 3 4 dict = {\u0026#39;小明\u0026#39;:80,\u0026#39;小华\u0026#39;:84,\u0026#39;小红\u0026#39;:90} print(dict[\u0026#39;小明\u0026#39;]) print(dict[\u0026#39;小华\u0026#39;]) print(dict[\u0026#39;小红\u0026#39;]) 字典的嵌套 字典的Key和Value可以是任意数据类型**（Key不可以是字典）**\n使用例：使用字典记录学生及其成绩\n姓名 语文 数学 英语 小明 77 66 33 小华 88 86 55 小红 99 96 66 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 score = { \u0026#39;小明\u0026#39;:{ \u0026#39;语文\u0026#39;:77, \u0026#39;数学\u0026#39;:66, \u0026#39;英语\u0026#39;:33 },\u0026#39;小华\u0026#39;:{ \u0026#39;语文\u0026#39;:88, \u0026#39;数学\u0026#39;:86, \u0026#39;英语\u0026#39;:55 },\u0026#39;小红\u0026#39;:{ \u0026#39;语文\u0026#39;:99, \u0026#39;数学\u0026#39;:96, \u0026#39;英语\u0026#39;:66 } } print(score) # 接下来是索引教程 # 此处查询小华的数学成绩 print(score[\u0026#39;小华\u0026#39;][\u0026#39;数学\u0026#39;])\t#输出 86 字典的常用操作 字典的新增元素 直接对新元素执行以下命令即可\n1 2 3 dict = {\u0026#39;小明\u0026#39;:80,\u0026#39;小华\u0026#39;:84,\u0026#39;小红\u0026#39;:90} dict[\u0026#39;小芳\u0026#39;] = 94 print(dict) 字典的更新/修改元素 字典Key不可重复，所以直接对已有元素执行以下命令即可\n1 2 3 dict = {\u0026#39;小明\u0026#39;:80,\u0026#39;小华\u0026#39;:84,\u0026#39;小红\u0026#39;:90} dict[\u0026#39;小明\u0026#39;] = 100 print(dict) 删除元素 pop 删除的同时取出元素\n1 2 3 4 dict = {\u0026#39;小明\u0026#39;:80,\u0026#39;小华\u0026#39;:84,\u0026#39;小红\u0026#39;:90} a = dict.pop(\u0026#39;小红\u0026#39;) print(dict) print(a) 清空字典 1 2 3 dict = {\u0026#39;小明\u0026#39;:80,\u0026#39;小华\u0026#39;:84,\u0026#39;小红\u0026#39;:90} dict.clear() print(dict) 获取全部的Key keys 和pop相同，你需要用变量来接收\n1 2 3 dict = {\u0026#39;小明\u0026#39;:80,\u0026#39;小华\u0026#39;:84,\u0026#39;小红\u0026#39;:90} a = dict.keys() print(a)\t# 输出 dict_keys([\u0026#39;小明\u0026#39;, \u0026#39;小华\u0026#39;, \u0026#39;小红\u0026#39;]) 统计字典内的元素数量 len 1 2 dict = {\u0026#39;小明\u0026#39;:80,\u0026#39;小华\u0026#39;:84,\u0026#39;小红\u0026#39;:90} print(len(dict)) 字典的遍历 由于不能通过下标索引，字典同样不支持while循环\nfor函数 方式一：使用 2.5获取全部的Key keys 处的指令\n1 2 3 4 dict = {\u0026#39;小明\u0026#39;:80,\u0026#39;小华\u0026#39;:84,\u0026#39;小红\u0026#39;:90} k = dict.keys()\t#此处的k本质是列表，所以接下来参考列表的遍历 for m in k: print(m,\u0026#39;的成绩是\u0026#39;,dict[m]) 方式二：直接遍历\n1 2 3 dict = {\u0026#39;小明\u0026#39;:80,\u0026#39;小华\u0026#39;:84,\u0026#39;小红\u0026#39;:90} for k in dict: print(k,\u0026#39;的成绩是\u0026#39;,dict[k]) ","date":"2025-11-07T22:21:09+08:00","permalink":"https://www.retr0.qzz.io/p/6.6-%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8%E5%AD%97%E5%85%B8/","title":"6.6 数据容器：字典"},{"content":" 集合不支持元素的重复（自带去重功能），并且内容无序。\n集合的定义 1 2 3 4 5 # 定义集合变量 a = {1,2,3,4,5,4,3,2,1} # 定义空集合 b = set() print(a)\t# 输出{1, 2, 3, 4, 5} 发现自动去重 集合的常用操作 因为集合是无序的，所以集合**不支持下标索引**，但是集合是可以修改的\n添加新元素 add 1 2 3 4 a = {1,2,3,4,5,\u0026#39;hi\u0026#39;} a.add(\u0026#39;hello\u0026#39;)\t# 添加成功 a.add(\u0026#39;hi\u0026#39;)\t# 添加失败，因为被自动去重 print(a)\t# 输出{1, 2, 3, 4, 5, \u0026#39;hi\u0026#39;, \u0026#39;hello\u0026#39;} 移除元素 remove 1 2 3 a = {1,2,3,4,5,\u0026#39;hi\u0026#39;} a.remove(\u0026#39;hi\u0026#39;) print(a) 从集合中随机抽取元素 pop 1 2 3 4 a = {1,2,3,4,5,\u0026#39;hi\u0026#39;} b = a.pop() print(a) print(b) 注意：取出元素后集合本身被修改，对应元素移除，因此你需要用一个变量来接收取出的元素\n清空集合 clear 1 2 3 a = {1,2,3,4,5,\u0026#39;hi\u0026#39;} a.clear() print(a) 取出两个集合的差集 difference 语法：集合1.difference(集合2)，功能：取出集合1和集合2的差集 (集合1有而集合2没有的，即 C=A-A∩B)\n结果：得到一个新集合，集合1和集合2不变\n1 2 3 4 5 6 set1 = {1,2,3} set2 = {1,5,6} set3 = set1.difference(set2) print(set3)\t# 结果：{2,3} 得到的新集合 print(set1)\t# 结果：{1,2,3} 不变 print(set2)\t# 结果：{1,5,6} 不变 消除两个集合的差集 语法：集合1.difference_update(集合2)\n功能：对比集合1和集合2，在集合1内，删除和集合2相同的元素（即 A=A-A∩B）\n因此只有集合1被修改，不会产生新的集合。\n1 2 3 4 5 set1 = {1,2,3} set2 = {1,5,6} set1.difference_update(set2) print(set1)\t# 结果{2, 3}，被修改 print(set2)\t# 结果{1,5,6}，不变 两个集合合并 语法：集合1.union(集合2)\n功能：将集合1和集合2合并为新集合\n1 2 3 4 5 6 set1 = {1,2,3} set2 = {1,5,6} set3 = set1.union(set2) print(set3)\t# 结果：{1,2,3,5,6}，新集合 print(set1)\t# 结果：{1,2,3}，不变 print(set2)\t# 结果：{1,5,6}，不变 统计集合元素数量 1 2 a = {1,2,3,4,5,\u0026#39;hi\u0026#39;} print(len(a)) 集合的循环遍历 注意：因为集合不支持下标索引，所以无法为while循环提供条件，因此只能使用for循环\nfor循环 1 2 3 a = {1,2,3,4,5,\u0026#39;hi\u0026#39;} for element in a: print(element) ","date":"2025-11-06T22:30:30+08:00","permalink":"https://www.retr0.qzz.io/p/6.5-%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8%E9%9B%86%E5%90%88/","title":"6.5 数据容器：集合"},{"content":" 序列是指：内容连续、有序，可使用下标索引的一类数据容器\n列表、元组、字符串，均可以视为序列。\n序列的切片 切片：从一个序列中，取出一个子序列。\n语法：序列[起始下标:结束下标:步长]\n表示从序列中,从指定位置开始,依次取出元素,到指定位置结束,得到一个新序列:\n起始下标表示从何处开始,可以留空,留空视作从头开始 结束下标**(不含)**表示何处结束,可以留空,留空视作截取到结尾(包含尾部) 步长表示,依次取元素的间隔 步长1表示,一个个取元素(默认为1) 步长2表示,每次跳过1个元素取 步长N表示,每次跳过N-1个元素取 步长为负数表示,反向取(注意,起始下标和结束下标也要反向标记) 注意：切片操作不会对原序列进行修改，而是会得到新的序列\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 对List进行切片,从1开始,4结束,步长1 list = [0,1,2,3,4,5,6] print(list[1:4])\t#输出[1, 2, 3] # 对tuple进行切片,从头开始,到最后结束,步长1 tuple = (0,1,2,3,4,5,6) print(tuple[:])\t#输出(0, 1, 2, 3, 4, 5, 6) # 对str进行切片,从头开始,到最后结束,步长2 str = \u0026#39;01234567\u0026#39; print(str[::2])\t#输出0246 # 对str进行切片,从头开始,到最后结束,步长-1 str = \u0026#39;01234567\u0026#39; print(str[::-1])\t#输出76543210 # 对列表进行切片,从3开始,到1结束,步长-1 list = [0,1,2,3,4,5,6] print(list[3:1:-1])\t#输出[3, 2] #对元组进行切片,从头开始,到尾结束,步长-2 tuple = (0,1,2,3,4,5,6) print(tuple[::-2])\t#输出(6, 4, 2, 0) ","date":"2025-11-05T18:17:46+08:00","permalink":"https://www.retr0.qzz.io/p/6.4-%E5%BA%8F%E5%88%97%E7%9A%84%E6%93%8D%E4%BD%9C%E5%88%87%E7%89%87/","title":"6.4 序列的操作：切片"},{"content":" 字符串是字符的容器，一个字符串可以存放任意数量的字符。字符串同样无法修改。\n字符串的定义 字符串中的每个字符都为一个元素，同样可以用下标号索引，例如：\n1 2 3 s = \u0026#39;hello\u0026#39; print(s[0])\t#输出h print(s[-1])\t#输出o 此外，需要注意空格也属于一种字符\n1 2 3 s = \u0026#39;you and me\u0026#39; print(s[3]) print(s[-3])\t#输出空格 字符串的常用操作 找到特定字符串的下标 1 2 s = \u0026#39;you and me\u0026#39; print(s.index(\u0026#39;and\u0026#39;))\t#输出4 字符串的替换 1 2 3 4 s1 = \u0026#39;12345666\u0026#39; s2 = s1.replace(\u0026#39;6\u0026#39;,\u0026#39;7\u0026#39;)\t#字符串.replace（‘要替换的字符’，‘替换后的字符’） print(s1)\t#输出12345666 print(s2)\t#输出12345777 可见replace并没有修改字符串本身，而是产生了一个新字符串，因此你需要一个变量来接收它\n字符串的分割 1 2 3 4 s1 = \u0026#39;you and me\u0026#39; s2 = s1.split(\u0026#39; \u0026#39;)\t#字符串.split(\u0026#39;分割依据\u0026#39;) print(s1)\t#输出you and me print(s2)\t#输出[\u0026#39;you\u0026#39;, \u0026#39;and\u0026#39;, \u0026#39;me\u0026#39;] 在括号内填入你想要按照哪一个字符分割后，split会将原字符串分割为若干元素并装入一个列表\n但是原字符串仍被未修改，因此你需要一个变量来接收分割结果\n字符串的规整操作 当括号内不填参数时，strip会去除字符串前后的空格\n1 2 s = \u0026#39; you and me \u0026#39; print(s.strip())\t#输出you and me 当括号内填入参数后，strip会去除字符串首尾全部满足参数的字符（不严格：满足参数的任意字符就去除）例：\n1 2 s = \u0026#39;23you and me34\u0026#39; print(s.strip(\u0026#39;234\u0026#39;))\t#输出you and me 此处表明于strip并不是找到'234\u0026rsquo;这一整体才去除，而是把'2\u0026rsquo;、\u0026lsquo;3\u0026rsquo;、\u0026lsquo;4\u0026rsquo;分别都去除\n统计字符串中某字符串出现的次数 1 2 s = \u0026#39;itheima and itcast\u0026#39; print(s.count(\u0026#39;it\u0026#39;))\t#输出2 严格按照所查找字符串整体查找，区分大小写\n统计字符串的长度 同样包括空格，用法与之前相同\n1 2 s = \u0026#39;you and me\u0026#39; print(len(s))\t#输出10 字符串的遍历 while循环 示例：\n1 2 3 4 5 6 s = \u0026#39;12345\u0026#39; index = 0 while index \u0026lt; len(s): a = s[index] print(a)\t#对元素a进行处理 index += 1 for循环 示例：\n1 2 3 4 s = \u0026#39;12345\u0026#39; for i in range (0,len(s)): a = s[i] print(a) ","date":"2025-11-04T17:45:08+08:00","permalink":"https://www.retr0.qzz.io/p/6.3-%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"6.3 数据容器：字符串"},{"content":" 什么是元组？\n元组是Python中的一种基本数据结构，它是一个不可变的序列，意味着一旦创建，元组中的元素不能被修改、添加或删除。\n元组的定义 定义元组使用小括号，且用逗号隔开各个数据，数据可以是不同数据类型\n1 2 3 4 tuple = (1,2,\u0026#39;ok\u0026#39;,4,5,True) #定义空元组 a = ()\t#方式1 b = tuple()\t#方式2 注意：如果元组中只有一个元素，它的后面也要加上逗号，例如\n1 tuple = (\u0026#39;hello\u0026#39;,) 此外，元组也可以嵌套\n1 tuple = ((1,2,3),(4,5,6)) 元组的常用操作\t（同列表基本一致） 元组的索引 元组同样支持通过下标号正反向索引\n1 2 3 t = (\u0026#39;一\u0026#39;,\u0026#39;二\u0026#39;,\u0026#39;三\u0026#39;,\u0026#39;四\u0026#39;,\u0026#39;五\u0026#39;) print(t[0]) print(t[-1]) 查询元组中元素的下标号 同样只查询到第一个匹配的元素\n1 2 t = (\u0026#39;一\u0026#39;,\u0026#39;二\u0026#39;,\u0026#39;三\u0026#39;,\u0026#39;四\u0026#39;,\u0026#39;五\u0026#39;) print(t.index(\u0026#39;三\u0026#39;)) 统计某元素在元组中的数量 1 2 t = (1,2,3,2,4,2,5) print(t.count(2)) 统计元组内全部元素数量 1 2 t = (\u0026#39;一\u0026#39;,\u0026#39;二\u0026#39;,\u0026#39;三\u0026#39;,\u0026#39;四\u0026#39;,\u0026#39;五\u0026#39;) print(len(t)) 特别：修改元组内的列表的元素 1 2 3 t1 = (1,2,[\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;hello\u0026#39;]) t1[2][2] = \u0026#39;c\u0026#39; print(t1) 元组的循环遍历 while循环 示例：\n1 2 3 4 5 6 t = (1,2,3,4,5) index = 0 while index \u0026lt; len(t): a = t[index] print(a)\t#对元素a进行处理 index += 1 for循环 示例：\n1 2 3 4 t = (1,2,3,4,5) for i in range (0,len(t)): a = t[i] print(a) ","date":"2025-11-03T18:14:15+08:00","permalink":"https://www.retr0.qzz.io/p/6.2-%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8%E5%85%83%E7%BB%84/","title":"6.2 数据容器：元组"},{"content":"一、事件概述 1. 攻击爆发与范围 时间：2017 年 5 月 12 日，黑客利用美国国家安全局（NSA）泄露的 \u0026ldquo;永恒之蓝\u0026rdquo;（EternalBlue）漏洞发动攻击，迅速波及全球。\n规模：超过 150 个国家、30 多万台设备被感染，包括英国 NHS 医院、中国高校、俄罗斯电信公司等关键基础设施。\n行业影响：医疗系统瘫痪导致手术延误，教育机构数据丢失影响毕业季，物流企业供应链中断，全球经济损失估算达40 亿至 500 亿美元。\n被入侵的公安网 某加油站中毒 某高校机房中毒 2. 传播与加密机制 蠕虫式传播：病毒通过扫描开放 445 端口（SMB 协议）的 Windows 设备，利用 \u0026ldquo;永恒之蓝\u0026rdquo; 漏洞自动植入恶意代码，无需用户交互即可横向扩散。\n文件加密：感染设备后，病毒使用AES-256 对称加密和RSA-1024 非对称加密组合，将文档、照片、数据库等文件后缀改为.wncry，并在桌面显示勒索弹窗。\n赎金要求：索要 300-600 美元比特币，付款后承诺提供解密密钥，但实际仅有少数受害者成功恢复数据。\n3. 关键转折点 Kill Switch（自毁开关）：病毒代码中隐藏了一个检测特定域名（iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com）是否存在的机制。英国安全研究员马库斯・哈钦斯（Marcus Hutchins）以 8 英镑注册该域名，意外触发病毒自毁，阻止了约 10 万台设备感染。\n当时媒体对马库斯・哈钦斯的报道 变种威胁：5 月 14 日出现的 WannaCry 2.0 移除了 Kill Switch，传播速度更快，但未造成大规模二次爆发。\n二、病毒原理简单解析 1. 漏洞利用：永恒之蓝（MS17-010） 漏洞背景：该漏洞存在于 Windows SMBv1 协议实现中，攻击者通过发送特制数据包触发内存错误，实现远程代码执行（RCE）。 攻击流程： 扫描阶段：病毒通过 445 端口向目标主机发送 SMB 请求，探测是否存在漏洞。 漏洞触发：构造包含恶意指令的数据包，利用 SMB 协议中的缓冲区溢出漏洞，覆盖内存中的返回地址。 代码执行：强制目标系统执行病毒 Payload，下载并运行 WannaCry 本体。 2. 加密流程 密钥生成：每台感染设备生成唯一的 AES-256 密钥用于文件加密，该密钥再通过攻击者的 RSA 公钥加密后上传至控制服务器。 文件锁定：病毒遍历系统磁盘，对文档（.doc/.xls）、媒体（.mp4/.jpg）、数据库（.mdb/.sql）等 70 余种格式文件进行加密，同时删除原始文件备份。 3. 传播扩散 横向移动：成功感染一台设备后，病毒通过以下方式继续传播： 漏洞复用：利用相同的永恒之蓝漏洞攻击局域网内其他未打补丁的设备。 共享渗透：扫描网络共享目录，尝试弱密码登录并植入病毒。 传播速度：由于许多企业未及时更新系统（如 Windows XP、Server 2003），病毒在数小时内形成全球扩散。 三、样本深度分析 该病毒分为两个部分：\n蠕虫部分，用于病毒传播，并释放出勒索病毒。\n勒索病毒部分，加密用户文件索要赎金。\n1. 蠕虫部分详细分析： 1.蠕虫代码运行后先会连接域名：http://www.iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com 如果该域名可以成功连接，则直接退出。\n关于这个“Kill Switch”的存在网络上众说纷纭，我们认为相对可靠的解释是：开关的存在是为了检测安全软件沙箱。这种手法多见于恶意代码混淆器，但是除了看到几个人为修改“Kill Switch”的样本外，该病毒并没有批量生成、混淆的迹象。另外，如果真是为了对抗安全软件沙箱，和以往对抗沙箱的样本比起来，这段代码过于简单，而且出现的位置也过于明显。所以，放置这样一个“低级”的“Kill Switch”具体出于何种原因，恐怕只有恶意代码作者能够解释了。\n2. 如果上述域名无法访问，则会安装病毒服务，服务的二进制文件路径为当前进程文件路径，参数为：-m security，并启动服务。\n3. 释放资源到C:WINDOWS目录下的tasksche.exe（该程序是勒索病毒），并将其启动。\n4. 蠕虫病毒服务启动后，会利用MS17-010漏洞传播。传播分为两种渠道，一种是局域网传播，另一种是公网传播。如下图所示：\n局域网传播主要代码如下图：\n病毒会根据用户计算机内网IP，生成覆盖整个局域网网段表，然后循环依次尝试攻击。相关代码如下：\n公网传播主要代码如下图，病毒会随机生成IP地址，尝试发送攻击代码。\nSMB漏洞攻击数据包数据，如下图所示：\nWorm病毒的PE文件中包含有两个动态库文件，是攻击模块的Payload，分别是：x86版本的payload，大小0x4060和x64版本的payload，大小0xc8a4。\n两个Payload都是只有资源目录结构没有具体资源的无效PE动态库文件。病毒在攻击前，会构造两块内存，在内存中分别组合Payload和打开Worm病毒自身，凑成有效攻击Payload，代码如下图所示：\n有效攻击Payload模型如下：\n完整的攻击Payload的资源如下图，资源中的第一个DWORD是病毒大小，之后就是病毒本身。\n然后使用MS17-010漏洞，通过APC方式注入动态库到被攻击计算机的Lsass.exe，并执行Payload动态库的导出函数PlayGame，该函数非常简单，功能就是释放资源“W”到被攻击计算机“C:Windowsmssecsvc.exe”，并执行，如下图所示：\n火绒剑监控被攻击计算机的如下：\n被攻击的计算机包含病毒的完整功能，除了会被勒索，还会继续使用MS17-010漏洞进行传播，这种传播呈几何级向外扩张，这也是该病毒短时间内大规模爆发的主要原因。如下图：\n目前，攻击内网IP需要用户计算机直接暴露在公网且没有安装相应操作系统补丁的计算机才会受到影响，因此那些通过路由拨号的个人用户，并不会直接通过公网被攻击。如果企业网络也是通过总路由出口访问公网的，那么企业网络中的电脑也不会受到来自公网的直接攻击。但是，现实中一些机构的网络存在直接连接公网的电脑，且内部网络又类似一个大局域网，因此一旦暴露在公网上的电脑被攻破，就会导致整个局域网存在被感染的风险。\n2. 勒索病毒部分详细分析： 1. 该程序资源中包含带有密码的压缩文件，使用密码“WNcry@2ol7”解压之后释放出一组文件：\na) taskdl.exe，删除临时目录下的所有“*.WNCRYT”扩展名的临时文件。\nb) taskse.exe，以任意session运行指定程序。\nc) u.wnry，解密程序，释放后名为@WanaDecryptor@.exe。\nd) b.wnry勒索图片资源。\ne) s.wnry，包含洋葱路由器组件的压缩包。病毒作者将勒索服务器搭建在”暗网”，需要通过tor.exe和服务器进行通信。\nf) c.wnry，洋葱路由器地址信息。\ng) t.wnry，解密后得到加密文件主要逻辑代码。\nh) r.wnry，勒索Q\u0026amp;A。\n2. 通过命令行修改所有文件的权限为完全访问权限。命令行如下：\nicacls . /grant Everyone:F /T /C /Q\n3. 解密t.wnry文件数据得到含有主要加密逻辑代码的动态库，通过其模拟的LoadLibrary和GetProcAddress函数调用该动态库中的导出函数执行其加密逻辑。\n调用勒索动态库代码，如下图所示：\n勒索主逻辑执行，先会导入一个存放在镜像中的RSA公钥，之后调用CryptGenKey生成一组RSA算法的Session key。之后将这组Key的公钥通过CryptExportKey导出，再写入到00000000.pky文件中。将Session key中的私钥用刚导入RSA公钥进行加密，存放在00000000.eky如下图所示： 如果遍历到的文件扩展名在欲加密的文件扩展名列表中，如下图所示：\n对于每个需要加密的文件，都会调用CryptGenRadom随机生成AES密钥，之后使用Session Key中的RSA公钥对AES密钥进行加密，存放在加密后的数据文件头中，之后将原始文件数据用该AES密钥进行加密。如下图所示：\n整体加密流程，如下图所示：\n因为病毒是生成加密过的用户文件后再删除原始文件，所以存在通过文件恢复类工具恢复原始未加密文件的可能。但是因为病毒对文件系统的修改操作过于频繁，导致被删除的原始文件数据块被覆盖，致使实际恢复效果有限。且随着系统持续运行，恢复类工具恢复数据的可能性会显著降低。\n四、 关于“WannaCry”新变种的说明\n早期版本的“WannaCry”病毒存在“Kill Switch”开关，也就是病毒中检测“http://www.iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com”这个网址是否可以访问的代码片段，如果可以访问则不会利用“永恒之蓝”漏洞继续传播。\n现在这个域名已经被注册，这个版本“WannaCry”传播功能等于已经关闭，因为这段代码本身没有加密，所以很可能会被得到改病毒样本的“骇客”修改，放开开关，使病毒继续传播。\n截止到今日，收集到的所谓“WannaCry”最新版本的“变种”，正如我们推测的一样，网上两个“热炒\u0026quot;变种, SHA256分别为：\n32f24601153be0885f11d62e0a8a2f0280a2034fc981d8184180c5d3b1b9e8cf\nc8d816410ebfb134ee14d287a34cea9d34d627a2c5e16234ab726cf9fde47ec6\n和早期的“WannaCry”相比\nSHA256：24d004a104d4d54034dbcffc2a4b19a11f39008a575aa614ea04703480b1022c\n有明显人为修改痕迹，如下图所示：\n这个样本仅仅是16进制修改了两个字节，让\u0026quot;Kill Switch\u0026quot;失效，这个修改不会影响检测。\n另外一个样本除了修改了\u0026quot;Kill Switch\u0026quot;域名，还修改了病毒携带勒索模块。经过测试勒索代码已经被修改坏了，无法运行。如下图：\n除了以上两个样本，火绒还截获另一个人为修改的” WannaCry “样本，同样被修改的不能运行\nSHA256如下：\n99c0d50b088df94cb0b150a203de6433cb97d4f8fd3b106ce442757c5faa35c4\n","date":"2025-11-03T13:18:39+08:00","image":"https://s.secrss.com/anquanneican/eba6dc46083f85d24ac9474fa735590a.jpg","permalink":"https://www.retr0.qzz.io/p/%E5%9B%9E%E5%BF%86%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92wannacry%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/","title":"回忆勒索病毒WannaCry：深度剖析"},{"content":"列表的标准定义形式 1 list = [1,2,\u0026#39;三\u0026#39;,d,\u0026#39;我是一个元素\u0026#39;] 列表的常用操作 正向索引： 注意正向索引时从列表内第一个元素开始，其下标号为0，向右以此为1、2、3……\n反向索引：注意反向索引时从列表内倒数第一个元素开始，其下标号为-1，向左以此为-2、-3……\n1 list[N] #其中N为列表元素的下标号，‘list’要换为实际列表名 查询列表中元素的下标号 1 list.index(\u0026#39;我是一个元素\u0026#39;)\t#‘list’要换为实际列表名 特别地，对于嵌套列表需要指定除了所查询元素在其列表的下标号之外的所有下标号，例如\n1 2 list = [[1,2,3],[4,5,6],[7,8,9]] print(list[1].index(5))\t#此处我们查询元素‘5’的下标号 修改指定位置的元素 支持正反索引下标号\n1 list[2] = \u0026#39;example\u0026#39;\t#列表[下标] = 值 列表的插入 1 2 3 list = [1,2,3,4] list.insert(1,\u0026#39;Hello\u0026#39;)\t#列表.insert(下标，值)\t在所填下标之前插入一个值 print(list) 列表的追加 追加单个元素\n1 2 3 list = [1,2,3,4] list.append(\u0026#39;五\u0026#39;)\t#列表.append(值)\t在列表尾追加一个元素 print(list) 追加一批元素\n1 2 3 4 list1 = [1,2,3,4] list2 = [5,6,7] list1.extend(list2)\t#列表.extend(数据容器)\t在列表尾导入一批元素，此处括号内直接填写也可以 print(list1) 删除元素 方法一：del指定下标删除\t注意：由于del是Python主环境中的一个关键字，所以到此只有它的语法是放在列表名前面的\n1 2 3 list = [1,2,3] del list[0]\t#del 列表[下标] print(list) 方法二：pop取出\n1 2 3 4 list = [1,2,3] a = list.pop(0)\t#列表.pop(下标) print(list) print(a)\t#获取被取出的元素 方法三：remove指定内容删除\t注意：remove方法会从前往后依次检索列表中的元素，并删除第一个匹配的元素，如果想删除多个相同元素，请执行多次remove\n1 2 3 list = [\u0026#39;一\u0026#39;,\u0026#39;二\u0026#39;,\u0026#39;删我\u0026#39;,\u0026#39;三\u0026#39;,\u0026#39;删我\u0026#39;] list.remove(\u0026#39;删我\u0026#39;)\t#列表.remove(元素值) print(list) 清空列表 1 2 3 list = [1,2,3] list.clear()\t#列表.clear() print(list) 统计某元素在列表中的数量 1 2 list = [1,2,3,2,8,2,5,2]\tprint(list.count(2))\t#列表.count(元素值) 统计列表内全部元素数量 注意：它的语法也是放在列表名前面的\n1 2 list = [1,2,3,2,8,2,5,2]\tprint(len(list))\t#len(列表) 列表的排序 sort()函数 默认升序（数字从小到大，首字母从前到后），且会修改当前列表\n1 2 3 4 5 6 list1 = [10, 8, 3, 22, 33, 7, 11, 100, 54] list2 = [\u0026#39;f\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;e\u0026#39;] list1.sort() list2.sort() print(list1) print(list2) 可选参数：reverse\t降序\n1 2 3 list = [1,2,3,4,5] list.sort(reverse=True) print(list) 可选参数：key\t自定义排序\n1 2 3 list = [\u0026#39;java\u0026#39;,\u0026#39;python\u0026#39;,\u0026#39;C++\u0026#39;,\u0026#39;go\u0026#39;] list.sort(key=len)\t#此处以长度为参考量，仅为其中一种用法 print(list) 你也可以将其组合\n1 2 3 list = [\u0026#39;java\u0026#39;,\u0026#39;python\u0026#39;,\u0026#39;C++\u0026#39;,\u0026#39;go\u0026#39;] list.sort(key=len,reverse=True)\tprint(list) sorted()函数 用法与sort()一致，但是不会修改列表本身，而是将修改后的列表创建一个副本。简而言之，你需要一个变量来接收它。\n1 2 3 list = [\u0026#39;java\u0026#39;,\u0026#39;python\u0026#39;,\u0026#39;C++\u0026#39;,\u0026#39;go\u0026#39;] a = sorted(list,key=len,reverse=True) print(a) 我们来比较一下二者的区别\n1 2 3 4 5 6 7 8 list1 = [5,4,3,2,1] list2 = [5,4,3,2,1] list3 = list1.sort() list4 = sorted(list2) print(list1)\t#[1, 2, 3, 4, 5]\t列表本身也被修改 print(list2)\t#[5, 4, 3, 2, 1]\t可见列表本身未被修改 print(list3)\t#None\t因为sort()函数不会传出修改后的列表 print(list4)\t#[1, 2, 3, 4, 5]\t列表的循环遍历 while循环 示例：\n1 2 3 4 5 6 list = [1,2,3,4,5] index = 0 while index \u0026lt; len(list): a = list[index] print(a)\t#对元素a进行处理 index += 1 for循环 示例：\n1 2 3 4 list = [1,2,3,4,5] for i in range (0,len(list)): a = list[i] print(a) ","date":"2025-11-02T22:54:24+08:00","permalink":"https://www.retr0.qzz.io/p/6.1-%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8%E5%88%97%E8%A1%A8/","title":"6.1 数据容器：列表"},{"content":"一、伴随矩阵与伴随矩阵法求逆矩阵 1. 伴随矩阵的定义 对于n阶方阵$A = (a_{ij})$，其代数余子式$A_{ij}$定义为：$A_{ij} = (-1)^{i+j}M_{ij}$，其中$M_{ij}$是$A$中去掉第$i$行第$j$列后剩余子矩阵的行列式（即余子式）。\n伴随矩阵$A^*$是由$A$的代数余子式按转置顺序排列而成的矩阵，即： $$ A^* = \\begin{pmatrix} A_{11} \u0026 A_{21} \u0026 \\cdots \u0026 A_{n1} \\\\ A_{12} \u0026 A_{22} \u0026 \\cdots \u0026 A_{n2} \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ A_{1n} \u0026 A_{2n} \u0026 \\cdots \u0026 A_{nn} \\end{pmatrix} $$2. 伴随矩阵的核心性质 对于任意n阶方阵$A$，有： $$ A \\cdot A^* = A^* \\cdot A = |A|I_n $$ 其中$|A|$是$A$的行列式，$I_n$是n阶单位矩阵。\n3. 伴随矩阵法求逆矩阵 可逆条件：矩阵$A$可逆的充要条件是$|A| \\neq 0$。\n逆矩阵公式：若$|A| \\neq 0$，则$A$的逆矩阵为： $$ A^{-1} = \\frac{1}{|A|}A^* $$推导过程：由$A \\cdot A^* = |A|I_n$，两边同时除以$|A|$（因$|A| \\neq 0$），得： $$ A \\cdot \\frac{1}{|A|}A^* = I_n $$ 根据逆矩阵的定义，可知$\\frac{1}{|A|}A^$是$A$的逆矩阵，即$A^{-1} = \\frac{1}{|A|}A^$。\n4. 示例：用伴随矩阵法求2阶矩阵的逆 设$A = \\begin{pmatrix} 1 \u0026amp; 2 \\ 3 \u0026amp; 4 \\end{pmatrix}$，求$A^{-1}$。\n步骤1：计算行列式$|A|$ $$ |A| = 1 \\times 4 - 2 \\times 3 = 4 - 6 = -2 \\neq 0 $$ 故$A$可逆。\n步骤2：计算代数余子式，构造伴随矩阵$A^*$\n$A_{11} = (-1)^{1+1} \\times 4 = 4$，$A_{12} = (-1)^{1+2} \\times 3 = -3$ $A_{21} = (-1)^{2+1} \\times 2 = -2$，$A_{22} = (-1)^{2+2} \\times 1 = 1$ 因此，伴随矩阵： $$ A^* = \\begin{pmatrix} A_{11} \u0026 A_{21} \\\\ A_{12} \u0026 A_{22} \\end{pmatrix} = \\begin{pmatrix} 4 \u0026 -2 \\\\ -3 \u0026 1 \\end{pmatrix} $$ 步骤3：代入逆矩阵公式 $$ A^{-1} = \\frac{1}{|A|}A^* = \\frac{1}{-2} \\begin{pmatrix} 4 \u0026 -2 \\\\ -3 \u0026 1 \\end{pmatrix} = \\begin{pmatrix} -2 \u0026 1 \\\\ \\frac{3}{2} \u0026 -\\frac{1}{2} \\end{pmatrix} $$ 验证（可选）： $$ A \\cdot A^{-1} = \\begin{pmatrix} 1 \u0026 2 \\\\ 3 \u0026 4 \\end{pmatrix} \\begin{pmatrix} -2 \u0026 1 \\\\ \\frac{3}{2} \u0026 -\\frac{1}{2} \\end{pmatrix} = \\begin{pmatrix} 1 \\times (-2) + 2 \\times \\frac{3}{2} \u0026 1 \\times 1 + 2 \\times (-\\frac{1}{2}) \\\\ 3 \\times (-2) + 4 \\times \\frac{3}{2} \u0026 3 \\times 1 + 4 \\times (-\\frac{1}{2}) \\end{pmatrix} = \\begin{pmatrix} 1 \u0026 0 \\\\ 0 \u0026 1 \\end{pmatrix} = I_2 $$ 验证成立。\n二、初等变换法求逆矩阵 1. 核心原理 对于n阶可逆矩阵$A$，构造增广矩阵$[A \\mid I_n]$（$I_n$为n阶单位矩阵），通过初等行变换（不可混用列变换）将左侧的$A$化为$I_n$，此时右侧原$I_n$会同步化为$A^{-1}$，即： $$ [A \\mid I_n] \\xrightarrow{初等行变换} [I_n \\mid A^{-1}] $$2. 关键步骤 构造增广矩阵：将$A$与同阶单位矩阵并排拼接，形成$[A \\mid I_n]$； 初等行变换（仅3种：换行、某行乘非零常数、某行加另一行的$k$倍）； 当左侧$A$化为$I_n$时，右侧矩阵即为$A^{-1}$； 验证（可选）：计算$A \\cdot A^{-1}$，若结果为$I_n$则正确。 3. 示例：用初等变换法求3阶矩阵的逆 设$A = \\begin{pmatrix} 1 \u0026amp; 0 \u0026amp; 1 \\ 2 \u0026amp; 1 \u0026amp; 0 \\ -3 \u0026amp; 2 \u0026amp; -5 \\end{pmatrix}$，求$A^{-1}$。\n步骤1：构造增广矩阵$[A \\mid I_3]$ $$ [A \\mid I_3] = \\begin{pmatrix} 1 \u0026 0 \u0026 1 \u0026 \\vdots \u0026 1 \u0026 0 \u0026 0 \\\\ 2 \u0026 1 \u0026 0 \u0026 \\vdots \u0026 0 \u0026 1 \u0026 0 \\\\ -3 \u0026 2 \u0026 -5 \u0026 \\vdots \u0026 0 \u0026 0 \u0026 1 \\end{pmatrix} $$ 步骤2：初等行变换\n消去第2、3行第1列元素：\n第2行 = 第2行 - 2×第1行：$R_2 = R_2 - 2R_1$ 第3行 = 第3行 + 3×第1行：$R_3 = R_3 + 3R_1$ 得到： $$ \\begin{pmatrix} 1 \u0026 0 \u0026 1 \u0026 \\vdots \u0026 1 \u0026 0 \u0026 0 \\\\ 0 \u0026 1 \u0026 -2 \u0026 \\vdots \u0026 -2 \u0026 1 \u0026 0 \\\\ 0 \u0026 2 \u0026 -2 \u0026 \\vdots \u0026 3 \u0026 0 \u0026 1 \\end{pmatrix} $$ 消去第3行第2列元素：\n第3行 = 第3行 - 2×第2行：$R_3 = R_3 - 2R_2$ 得到： $$ \\begin{pmatrix} 1 \u0026 0 \u0026 1 \u0026 \\vdots \u0026 1 \u0026 0 \u0026 0 \\\\ 0 \u0026 1 \u0026 -2 \u0026 \\vdots \u0026 -2 \u0026 1 \u0026 0 \\\\ 0 \u0026 0 \u0026 2 \u0026 \\vdots \u0026 7 \u0026 -2 \u0026 1 \\end{pmatrix} $$ 化为行最简形（首元为1，消去上方对应元素）：\n第3行 = 第3行 × $\\frac{1}{2}$：$R_3 = \\frac{1}{2}R_3$ 第1行 = 第1行 - 1×第3行：$R_1 = R_1 - R_3$ 第2行 = 第2行 + 2×第3行：$R_2 = R_2 + 2R_3$ 最终得到： $$ \\begin{pmatrix} 1 \u0026 0 \u0026 0 \u0026 \\vdots \u0026 -\\frac{5}{2} \u0026 1 \u0026 -\\frac{1}{2} \\\\ 0 \u0026 1 \u0026 0 \u0026 \\vdots \u0026 5 \u0026 -1 \u0026 1 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\vdots \u0026 \\frac{7}{2} \u0026 -1 \u0026 \\frac{1}{2} \\end{pmatrix} $$ 步骤3：得到逆矩阵 左侧已化为$I_3$，右侧即为$A^{-1}$： $$ A^{-1} = \\begin{pmatrix} -\\frac{5}{2} \u0026 1 \u0026 -\\frac{1}{2} \\\\ 5 \u0026 -1 \u0026 1 \\\\ \\frac{7}{2} \u0026 -1 \u0026 \\frac{1}{2} \\end{pmatrix} $$ 验证（可选）： 计算$A \\cdot A^{-1}$，结果为$I_3$（过程略），验证成立。\n","date":"2025-11-02T21:54:18+08:00","permalink":"https://www.retr0.qzz.io/p/%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%E6%B1%82%E9%80%86%E7%9F%A9%E9%98%B5/","title":"几种方法求逆矩阵"},{"content":"新华社北京10月28日电\n钟台文\n解决台湾问题、实现祖国完全统一，是全体中华儿女的共同愿望，也是中华民族伟大复兴的应有之义。两岸同属一个中国，祖国统一大势不可阻挡，这是中华民族走向伟大复兴的时、势、义所决定的。统一不是一种选择，而是一种必然。在中华民族走向伟大复兴的历史征程中，两岸中华儿女一定能够早日解决台湾问题，实现祖国完全统一，共享民族复兴荣耀。\n两岸统一是民心所向 在中华民族几千年的历史长河中，统一始终是历史发展的主流。中华民族书写了辉煌的历史，创造了灿烂的文明，深刻认识到 “统则强、分则乱” 的兴衰规律，形成了追求 “大一统” 的共同价值取向。自宋元以来，台湾绝大多数时间都是统一的多民族国家的一部分。即便是在被日本非法侵占的 50 年里，台湾同胞武装、非武装反抗日本殖民统治从未停止，更有数万人胸怀 “欲救台湾，必先救祖国” 的信念，奔赴祖国大陆参加抗日战争，最终与大陆同胞共同取得抗战的伟大胜利，台湾随之光复、回归祖国。这充分表明，台湾同胞具有光荣的爱国主义传统。两岸同胞同属中华民族，都是中国人，完成国家统一是全体中华儿女孜孜以求的愿望。有全体 14 亿多中国人汇聚的智慧和力量作支撑，实现国家统一的民意无比坚实、基础无比雄厚、力量无比强大。\n在中国共产党的引领推动下，70 多年来特别是两岸隔绝状态打破以来，两岸关系获得长足发展。两岸交流合作日益广泛，互动往来日益密切，给两岸同胞特别是台湾同胞带来实实在在的好处，充分说明两岸和则两利、合则双赢，两岸同胞走近走亲的强烈意愿是任何力量都压制不了的，两岸交流交往交融的时代大潮是任何力量都阻挡不了的。两岸关系发展，特别是祖国大陆广泛惠及台湾同胞的政策举措，契合了广大台湾同胞的心声，塑造了台湾社会要和平、要发展、要交流、要合作的主流民意。\n在中华民族实现国家完全统一的伟大进程中，“台独” 分裂势力不过是蚍蜉撼树、螳臂当车。2300 万台湾同胞都是中华民族一分子，都是中国人。“台独” 分裂势力大肆推动 “去中国化”“渐进台独”，愚弄台湾民众，尤其是毒害青少年一代，制造台湾社会 “分离意识”，严重毒害台湾同胞心灵。“台独” 分裂势力置台湾民众命运与台湾发展前途于不顾，不惜裹挟台湾社会为其政治私利垫背，给台湾带来深重祸患，危害台湾前途。“台独” 分裂势力一意孤行，背弃民族大义，甘当美国等西方国家 “以台遏华” 的棋子，配合其打压遏制大陆发展，甚至不惜将民族利益出卖给外部势力，损害两岸同胞共同利益和中华民族根本利益，终将遭到历史和人民的审判和惩处。\n两岸统一是大义所在 1949 年以来，中国共产党始终把解决台湾问题、实现祖国完全统一作为矢志不渝的历史任务。党的十八大以来，以习近平同志为核心的党中央，牢牢把握对台工作的历史方位和时代使命，引领两岸关系发展方向，塑造祖国必然统一大势。新时代新征程，中国共产党立志于中华民族千秋伟业，在以中国式现代化全面推进中华民族伟大复兴的进程中，坚定不移推进祖国统一大业。\n国家统一是全体中国人民意志的强烈表达。解决台湾问题是中国人自己的事，只能也必须由包括台湾同胞在内的 14 亿多中国人民共同决定。这不仅是民族情感使然，更是国家行使主权的必然。制度的不同，改变不了两岸同属一个国家、一个民族的客观事实。外部的干涉，阻挡不了家国团圆的历史大势。统一，是中华民族根本利益所在，也是台湾同胞福祉的最大保障。\n台湾回归中国是二战后国际秩序的重要组成部分，支持中国统一是维护国际法权威和战后国际秩序的应有之义。80 年前，中国人民浴血奋战，赢得了抗日战争的伟大胜利；80 年后，中国致力于维护战后国际秩序，决不允许历史悲剧重演。维护国家统一和领土完整，是国际法的基本原则，是每个主权国家的基本权利。一个中国原则是国际社会普遍共识和国际关系基本准则，国际社会广泛理解支持中国人民完成国家统一的正义事业。从国际大义上讲，中国人民解决台湾问题，事关维护《联合国宪章》的原则，符合人类社会进步和正义的潮流。中国必将统一，既由战后国际秩序所决定，也为站在人类文明与进步一边的绝大多数国家所支持。无论外部势力如何捣乱，中国终将统一、也必将统一的历史大势不可阻挡。\n两岸统一是大势所趋 习近平总书记深刻指出：“台湾问题因民族弱乱而产生，必将随着民族复兴而解决。” 决定两岸关系走向的关键因素是祖国大陆的发展进步。经过数十年的发展，祖国大陆的经济实力、科技实力、军事实力、文化软实力及综合国力大幅跃升，国际地位显著提高，国际影响力明显增强，日益走近世界舞台中央。中华民族伟大复兴势不可挡，国家统一事业也正进入新的历史进程。祖国大陆发展的优势和条件，持续转化为推进统一的能力和动力，必将不断促进两岸社会交流交融，加深两岸同胞利益和情感联结，增进共同的民族、文化和国家认同，牵引两岸关系朝统一方向前行。祖国大陆的实力决定了 “台独” 分裂没有出路、统一不可抗拒，决定了外部干涉不会得逞、“倚外谋独” 只会失败，台湾的出路有且只有一条，就是走向祖国完全统一。\n中华民族一定是强必统，统更强。从两岸实力对比和国际格局演变趋势看，只会对支持统一的正义一方越来越有利。两岸坐下来谈，谈出合理的 “两制” 台湾方案，不仅台湾现有社会制度会得到充分尊重、实现高度自治，台湾同胞还可以更广泛参与国家治理和国际事务，与大陆同胞一道当家做主，在更广袤的土地上实现治国安邦、经天纬地的理想。正如孙中山先生所言：\n“‘统一’是中国全体国民的希望。能够统一，全国人民便享福；不能统一，便要受害。”\n青山遮不住，毕竟东流去。两岸统一既是历史定论、法理必然，也是民心所向、大义所在，更是不可阻挡、不可逆转的时代洪流。国家统一、民族复兴的历史车轮滚滚向前，祖国完全统一一定要实现，也一定能够实现！\n","date":"2025-10-29T15:14:16+08:00","image":"https://www.retr0.qzz.io/post/%E6%96%B0%E9%97%BB/ece126ea-8f4b-4807-8eb6-df9ea636296c.jpeg","permalink":"https://www.retr0.qzz.io/p/%E7%BD%B2%E5%90%8D%E6%96%87%E7%AB%A0%E7%A5%96%E5%9B%BD%E5%BF%85%E7%84%B6%E7%BB%9F%E4%B8%80%E5%8A%BF%E4%B8%8D%E5%8F%AF%E6%8C%A1/","title":"署名文章：祖国必然统一势不可挡"},{"content":"一、罗尔定理（Rolle\u0026rsquo;s Theorem） 1. 核心条件 函数 $f(x)$ 在闭区间 $[a, b]$ 上 连续； 函数 $f(x)$ 在开区间 $(a, b)$ 内 可导； 端点函数值相等：$f(a) = f(b)$。 2. 结论 存在至少一点 $\\xi \\in (a, b)$，使得 $f\u0026rsquo;(\\xi) = 0$。\n3. 使用例子 设 $f(x) = x^2 - 2x$，区间 $[0, 2]$。\n验证条件：$f(x)$ 是多项式（闭区间连续、开区间可导）；$f(0) = 0$，$f(2) = 0$，满足 $f(0)=f(2)$； 应用结论：求导得 $f\u0026rsquo;(x) = 2x - 2$，令 $f\u0026rsquo;(x)=0$，解得 $x=1$，即 $\\xi=1 \\in (0,2)$，符合定理。 二、拉格朗日中值定理（Lagrange\u0026rsquo;s Mean Value Theorem） 1. 核心条件 函数 $f(x)$ 在闭区间 $[a, b]$ 上 连续； 函数 $f(x)$ 在开区间 $(a, b)$ 内 可导。 2. 结论 存在至少一点 $\\xi \\in (a, b)$，使得 $f\u0026rsquo;(\\xi) = \\frac{f(b) - f(a)}{b - a}$（几何意义：曲线在 $\\xi$ 处的切线与端点连线平行）。\n3. 使用例子 设 $f(x) = \\ln x$，区间 $[1, e]$。\n验证条件：$f(x)$ 在 $[1,e]$ 连续、$(1,e)$ 可导； 应用结论：端点斜率 $\\frac{f(e) - f(1)}{e - 1} = \\frac{1 - 0}{e - 1} = \\frac{1}{e - 1}$；求导得 $f\u0026rsquo;(x) = \\frac{1}{x}$，令 $\\frac{1}{x} = \\frac{1}{e - 1}$，解得 $x = e - 1 \\in (1,e)$，即 $\\xi = e - 1$，符合定理。 三、柯西中值定理（Cauchy\u0026rsquo;s Mean Value Theorem） 1. 核心条件 函数 $f(x)$、$g(x)$ 均在闭区间 $[a, b]$ 上 连续； 函数 $f(x)$、$g(x)$ 均在开区间 $(a, b)$ 内 可导； 对任意 $x \\in (a, b)$，$g\u0026rsquo;(x) \\neq 0$； 端点函数值不等：$g(a) \\neq g(b)$。 2. 结论 存在至少一点 $\\xi \\in (a, b)$，使得 $\\frac{f(b) - f(a)}{g(b) - g(a)} = \\frac{f\u0026rsquo;(\\xi)}{g\u0026rsquo;(\\xi)}$（拉格朗日中值定理的推广，$g(x)=x$ 时退化为拉格朗日定理）。\n3. 使用例子 设 $f(x) = \\sin x$，$g(x) = \\cos x$，区间 $[0, \\frac{\\pi}{2}]$。\n验证条件：$f(x)$、$g(x)$ 均连续可导；$g\u0026rsquo;(x) = -\\sin x$，在 $(0, \\frac{\\pi}{2})$ 内不为0；$g(0)=1 \\neq g(\\frac{\\pi}{2})=0$； 应用结论：增量比 $\\frac{f(\\frac{\\pi}{2}) - f(0)}{g(\\frac{\\pi}{2}) - g(0)} = \\frac{1 - 0}{0 - 1} = -1$；导数比 $\\frac{f\u0026rsquo;(\\xi)}{g\u0026rsquo;(\\xi)} = \\frac{\\cos \\xi}{-\\sin \\xi} = -\\cot \\xi$；令 $-\\cot \\xi = -1$，解得 $\\xi = \\frac{\\pi}{4} \\in (0, \\frac{\\pi}{2})$，符合定理。 ","date":"2025-10-29T12:31:38+08:00","permalink":"https://www.retr0.qzz.io/p/%E4%B8%89%E4%B8%AA%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86/","title":"三个微分中值定理"},{"content":"一、矩阵的秩（核心定义） 矩阵的秩是最高阶非零子式的阶数，也等于矩阵行向量组/列向量组的“极大无关组个数”(通俗说：最多能找出多少个不互相“多余”的行/列)记为 $$r(A)$$。\n二、核心性质 非负性与有界性：$\\displaystyle 0 \\leq r(A) \\leq \\min{m, n}$（秩是0或正整数，不超过行数和列数）； 零矩阵专属：$\\displaystyle A = O \\iff r(A) = 0$（零矩阵秩为0，反之亦然）； 转置不变性：$\\displaystyle r(A^T) = r(A)$（矩阵与其转置秩相等）； 初等变换不变性：初等行/列变换后，矩阵秩不变； 和秩不等式：$\\displaystyle r(A + B) \\leq r(A) + r(B)$（两矩阵和的秩不超过各自秩的和）； 乘积秩不等式：$\\displaystyle r(AB) \\leq \\min{r(A), r(B)}$（两矩阵乘积的秩不超过任一矩阵的秩）； 可逆矩阵作用：$\\displaystyle r(PA) = r(AQ) = r(PAQ) = r(A)$（可逆矩阵左乘/右乘，秩不变）； 伴随矩阵秩关系： 若$\\displaystyle r(A) = n$，则$\\displaystyle r(A^*) = n$； 若$\\displaystyle r(A) = n-1$，则$\\displaystyle r(A^*) = 1$； 若$\\displaystyle r(A) \u0026lt; n-1$，则$\\displaystyle r(A^*) = 0$； 分块矩阵秩：$\\displaystyle r\\begin{pmatrix} A \u0026amp; O \\ O \u0026amp; B \\end{pmatrix} = r(A) + r(B)$（对角分块矩阵的秩等于各块秩的和）。 ","date":"2025-10-28T15:27:38+08:00","permalink":"https://www.retr0.qzz.io/p/%E7%9F%A9%E9%98%B5%E7%9A%84%E7%A7%A9%E5%8F%8A%E5%85%B6%E6%80%A7%E8%B4%A8/","title":"矩阵的秩及其性质"},{"content":"判断n阶方阵A是否可逆，核心看以下快速等价条件（满足其一即可，优先选前2个最便捷）：\n行列式非零：$|A| \\neq 0$（直接计算行列式，最快上手）； 矩阵满秩：秩$r(A) = n$（通过初等行变换看是否能化为单位矩阵）； 齐次方程组$AX = 0$只有零解； 行/列向量组线性无关； 存在方阵B，使得$AB = BA = I$（I为单位矩阵）。 ","date":"2025-10-28T15:27:38+08:00","permalink":"https://www.retr0.qzz.io/p/%E5%BF%AB%E9%80%9F%E5%88%A4%E6%96%AD%E7%9F%A9%E9%98%B5%E6%98%AF%E5%90%A6%E5%8F%AF%E9%80%86/","title":"快速判断矩阵是否可逆"},{"content":"1. 伪装学校邮件 大前提（原理）： 大多数学校的邮箱都可以使用代发服务 重要提醒： 接收邮件的邮箱只有网易系，qq邮箱因为安全限制问题无法接收到 打开终端并按需要输入指令\n指令例：\n1 swaks --body \u0026#34;学校紧急通知\u0026#34; --header \u0026#34;Subject:教务处\u0026#34; -t ⽬标邮箱@XXX.com -f admin@XXX.edu.cn 参数解释\nbody参数是发送过去邮件的内容\nheader是发送过去邮件的标题\n-t是我们的目标邮箱\n-f是发送者的邮箱\n\u0026ndash;attach是指定要附加的文件的路径\n10月19日更新\n使用例：\n这里我们输入以下代码\n1 swaks --body \u0026#34;恭喜你已被我所拟录取，请在24小时内确认是否同意待录取，12小时后仍未确认的将取消资格。\u0026#34; --header \u0026#34;Subject:南京大学招生办：待录取通知\u0026#34; -t example@163.com -f zsb@nju.edu.cn 回车后查看接收邮箱\n发现正常接收了邮件，但是有提示可能伪造的标\n因此，在生活中各位务必确认邮件内容的真实性。\n","date":"2025-10-27T22:43:38+08:00","image":"https://www.retr0.qzz.io/post/kali%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E7%8B%B1/email.jpg","permalink":"https://www.retr0.qzz.io/p/swaks%E4%BC%AA%E9%80%A0%E9%82%AE%E4%BB%B6/","title":"swaks伪造邮件"},{"content":"虽说目前官网开放了个人免费下载使用，但是注册什么的对很多人还不是太友好，所以这里直接提供打包好的安装包和注册码\n链接：https://pan.quark.cn/s/85f0cadc8f12\n下载不多说，客户端下还是找解析网站自行解决\n安装除了位置自己看着改一下，其他下一步就完事了\n最后软件让你注册时，请输入压缩包内提供的注册码即可\n","date":"2025-10-27T22:39:38+08:00","permalink":"https://www.retr0.qzz.io/p/vmware%E7%9A%84%E5%AE%89%E8%A3%85/","title":"VMware的安装"},{"content":"感谢jm汉化组\n切换简中语言包 打开终端\n1 sudo dpkg-reconfigure locales 在打开的界面中使用pg up，pg dn，⬆️，⬇️翻页，使用空格选择，按tab切换到下方的确定和取消，按enter确定\n这里我们选择 zh_CN.UTF-8\n使用reboot重启即可\n换源 所谓换源就是切换软件仓库源\n这里需要修改以下文件sources.list\n在终端中输入\n1 sudo vim /etc/apt/sources.list ⚠️⚠️⚠️注意：这里需要使用到世界上最伟大的编辑器（没有之一）使用方法见下面的文章\n[retr0的小窝：Vim的使用](Vim的使用\n在文件末加上以下任意国内源\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # 官方源(国外的太慢不推荐) deb http://http.kali.org/kali kali-rolling main non-free contrib deb-src http://http.kali.org/kali kali-rolling main non-free contrib #中科大 deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib #阿里云 deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib #清华大学 deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free #浙大 deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free deb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free #东软大学 deb http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib deb-src http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib #南京大学 deb https://mirrors.nju.edu.cn/kali kali-rolling main non-free contrib deb-src https://mirrors.nju.edu.cn/kali kali-rolling main non-free contrib 添加并保存后需要到终端中更新\n1 sudo apt upgrade 调整文字大小（可选） 注意：这里我们去设置里在dpi选项中调整，而不要去“display”选项中调整，因为效果很差\n","date":"2025-10-27T18:27:38+08:00","image":"https://www.retr0.qzz.io/post/kali%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E7%8B%B1/kali2.webp","permalink":"https://www.retr0.qzz.io/p/1.2kali%E7%9A%84%E6%9C%AC%E5%9C%B0%E5%8C%96%E9%85%8D%E7%BD%AE%E6%9B%B4%E9%80%82%E5%90%88%E4%B8%AD%E5%9B%BD%E5%AE%9D%E5%AE%9D%E7%9A%84kali/","title":"1.2Kali的本地化配置：更适合中国宝宝的Kali"},{"content":"遲到的補完：《終》觀影指南 2025年10月31日，《天鹰战士：最后的冲击》将登录大陆内各影院，但我们仍用《新·福音战士剧场版：终》来称呼它，或者更简单的《终》也可以。\n然而上文表述都是不准确的，它真正的名字《シン・エヴァンゲリオン劇場版𝄇》（这么多片假名谁看得懂啊）里并没有“终”或者“最后”的字样，只有一个音乐符号**𝄇——它是乐谱中的段落终止线，表示一个完整段落的结束**。其副标题Thrice upon a time出自同名科幻小说，后者同时也是《命运石之门》的原型。\n即使你没看过EVA，也可能晓得EVA很难看懂，甚至形成了专门的学问叫“E学”。不过笔者在此只提供EVA的基本认识和一套简单易懂的世界观，希望对各位提供些许帮助。\n你所必须知道的… 许多年前，“第一先祖种族”FAR（就是牛逼外星人）生活在银河系内。它们在灭亡之前制造了名为“月亮”的运输船，月亮可以通过颜色来区分，比如在地球上空的白月，称为“白之月”。运输船运输的是生命之种、朗基努斯之枪、死海文书。\n它们仨分别是用来产生生命的（白之月的“亚当”产生“使徒”，黑之月的“莉莉丝”产生地球生物）、前者的开关（为了生物多样性，FAR要求一个星球上只允许一颗生命之种起作用）和前两者的使用说明书。\n40亿年前，白之月降落到南极区域，亚当繁衍“使徒”，使徒拥有生命之果，所以体型巨大而且难杀；之后，黑之月也来了，出于未知的原因，黑之月中的朗枪没有抑制莉莉丝，于是莉莉丝产生生命，人类拥有智慧之果，能造EVA去干使徒。亚当这边则受委屈了，白之月携带的朗基努斯之枪抑制了它产生生命。\n1947年，掌控人类的组织Seele（“灵魂”的德语）发现了死海文书，相信这是“神明”的启示，他们就要执行上面的计划（这就是EVA宗教色彩的来源，但EVA从任何角度上都不应当被定义为“宗教动漫”）。\n1999年，人类在南极发现了白之月撞击地球时产生了巨大坑洞，并在其内部发现了亚当，称为“第一使徒”。为了验证死海古书上的内容，人类进行了一些实验，导致南极的亚当发生了暴走，其释放出的能量对地球造成了不小的影响，所以EVA可以说是末世作品。\n2003年，人类在日本发现了巨大的地洞，也就是黑之月，Seele的下属机构NERV（“神经”的英语）的总部就建在其中，表面上是为了对抗使徒，实际是为了执行Seele的人类补完计划（就是全人类共同进化呗，灵魂脱离橙汁组成的肉体，合为一个整体，地球球长总喜欢搞这种）。\nNERV通过克隆亚当和莉莉丝的细胞制作了“终极泛用人型决战兵器，人造人EVANGELION”来打败使徒，由此可知，EVA并不是机甲番。\n政策的制定者Seele、政策的执行者NERV、在战斗一线的少年少女们——EVA的故事就是他们三者之间以及内部的矛盾。\n𝄇之前，发生了什么？ 我们不得不承认，如果《终》是你接触的第一步EVA作品，那诸位在电影院基本上也就是看个热闹，别说看懂EVA的内核、导演庵野秀明的表达、主角的愿景，最基本的这几个人在干什么都会搞不明白，所以介绍这部电影之前发生了什么，是很有必要的。\n旧EVA（26集TV+两部剧场版）我们不再讲了，只需要知道在旧剧场版的最后，人类补完计划没有得到完美执行，世界进行了一次轮回而进入到新EVA的故事即可。\n《终》之前有三部剧场版《序》《破》《Q》，我们简要说一说各个人物的动机和行为，相信这会对各位看明白《终》起到一定帮助。\n执行人类补完计划的势力NERV：碇源堂和冬月教授。碇源堂争取到了Seele老登们的信任，他希望主导人类补完计划，从而在人与人完全没有隔阂的世界中和老婆团聚；冬月教授则是他的得力助手。\n反对NERV的Wille（意为意志）：美里小姐、律子博士及其他机组人员。美里小姐的爱人良治在Wille起义时牺牲，继承了爱人意志的她一方面要阻止真嗣再一次不小心毁灭地球，另一方面又要阻止碇司令的疯狂计划，她能够成功吗；律子博士是她的得力助手。\nEVA驾驶员：碇真嗣、明日香、绫波丽、真希波。碇真嗣先是在《序》《破》中被老爹骗去帮忙执行计划，而后又在《Q》中和薰一起进他爹圈套，在《终》里他还能拯救世界吗；明日香在之前的作战中成为了半使徒半生物的存在，迷茫的她就要全力帮助美里小姐，等会，她会不会是克隆人；至少我们确定绫波丽是克隆人，是碇源堂妻子的克隆，《序》《破》中出现了白衣服的绫波丽（白丽），她对真嗣觉醒了感情，也就是“爱他”，却连同初号机被封印了，《Q》《终》出现的黑丽是否会觉醒“爱我”呢；真希波，她对世界真相的认识似乎比Seele还要多，我们不知道她为什么会帮助真嗣，但事实就是这样。\n生活在第三村的人们：真嗣以前的同班同学们，在《Q》中差点毁灭世界的他，需要一些友人们的帮助呢……\n总而言之，神秘兮兮的那群人干神神鬼鬼的事情本质上都是“碇司令为了见老婆，在举办神明的高科技仪式”，其他人则都是来阻止他的，阻止的方式就是开生物高达嗯打。\n万一，你喜欢上了EVA？ 在观影之后，各位或许会对EVA产生了更多的兴趣，或许也想要和笔者一样对“E学”进行一些学习和研究。对此，笔者的回答是：\n正如《终》里的台词“再见是希望彼此再见时说的话”，各位读者朋友们，\n再见。\n​ 終劇\n","date":"2025-10-27T18:27:38+08:00","image":"https://www.retr0.qzz.io/post/%E5%BD%B1%E8%A7%86/%E5%9B%BE%E7%89%871.png","permalink":"https://www.retr0.qzz.io/p/%E9%81%B2%E5%88%B0%E7%9A%84%E8%A3%9C%E5%AE%8C%E7%B5%82%E8%A7%80%E5%BD%B1%E6%8C%87%E5%8D%97/","title":"遲到的補完：《終》觀影指南"},{"content":"1. 下载kali 几种可选方案：\n官网下载：Get Kali | Kali Linux选择VMware下载即可（不推荐）\n镜像源下载：阿里云镜像源kali-images安装包下载_开源镜像站-阿里云\n​ 清华镜像源清华大学开源软件镜像站 | Tsinghua Open Source Mirror\n​ 中科大镜像源Index of /kali-images/\n以上几个都是从最新版本中找到后缀为vmware-amd64.7z的下载即可\n2. 安装kali 将下载好的压缩包解压在某文件夹内\n然后打开VMware Workstation Pro点击主页上的【打开虚拟机】\n选择你刚刚解压出的那一堆文件中后缀为vmx的文件即可（一般会自动筛选的）\n3. 登录kali 默认超级用户名和密码均为kali，\n至此，\n享受你的个人kali吧。\n","date":"2025-10-27T12:46:38+08:00","image":"https://www.retr0.qzz.io/post/kali%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E7%8B%B1/kali.jpeg","permalink":"https://www.retr0.qzz.io/p/1.1kali%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85/","title":"1.1Kali的下载与安装"},{"content":"一、Vim 基本操作 1. 启动和退出 Vim 启动 Vim:\n1 vim filename 退出 Vim:\n正常退出并保存：:wq 或 ZZ\n仅退出（不保存）：:q\n强制退出（不保存）：:q!\n仅保存文件：:w\n2. 模式切换 Vim 有多种模式，最常用的是以下几种：\n正常模式（Normal Mode）：Vim 启动时默认的模式，可以执行各种命令，如移动光标、删除文本等。按 Esc 键进入。\n插入模式（Insert Mode）：可以输入文本。按 i 进入，按 Esc 返回正常模式。\n可视模式（Visual Mode）：用于选中文本块。按 v 进入，可视模式下可使用方向键选择文本。\n常用模式切换命令：\ni：进入插入模式，在当前光标位置前插入。\na：进入插入模式，在当前光标位置后插入。\no：在当前行下方打开新行并进入插入模式。\nv：进入可视模式。\nV：进入可视行模式（选中整行）。\nCtrl + v：进入可视块模式（列选择）。\n二、Vim 光标移动命令 1. 基本移动 h：向左移动一个字符。\nl：向右移动一个字符。\nj：向下移动一行。\nk：向上移动一行。\n2. 行内移动 0：移动到行首。\n^：移动到本行第一个非空白字符。\n$：移动到行尾。\n3. 单词移动 w：移动到下一个单词的开头。\ne：移动到当前或下一个单词的末尾。\nb：移动到上一个单词的开头。\n4. 页面移动 Ctrl + u：向上滚动半页。\nCtrl + d：向下滚动半页。\nCtrl + b：向上滚动一整页。\nCtrl + f：向下滚动一整页。\nG：移动到文件末尾。\ngg：移动到文件开头。\n5. 行跳转 :n：跳转到第 n 行。\nnG：跳转到第 n 行。\n三、Vim 文本编辑命令 1. 插入和删除 i：进入插入模式。\na：在当前光标后插入文本。\no：在当前行下方新开一行并进入插入模式。\ndd：删除当前行。\nD：删除当前光标到行尾的所有内容。\nx：删除当前光标所在的字符。\ndw：删除当前光标到单词末尾的内容。\nu：撤销上一步操作。\nCtrl + r：重做上一步撤销的操作。\n2. 复制、剪切与粘贴 yy：复制当前行。\nyw：复制一个单词。\np：粘贴到光标后。\nP：粘贴到光标前。\ndd：剪切当前行。\ndaw：剪切一个单词。\n3. 替换与修改 r：替换当前字符。\nR：进入替换模式，从光标开始的字符将被逐个替换，直到退出替换模式为止。\ncw：修改当前单词（删除当前单词并进入插入模式）。\nc$：修改从光标位置到行尾的内容。\n四、Vim 查找与替换命令 1. 查找 /pattern：向下查找 pattern（正则表达式）。\n?pattern：向上查找 pattern。\nn：在查找模式下，查找下一个匹配项。\nN：在查找模式下，查找上一个匹配项。\n*：查找光标所在单词的下一个匹配项。\n#：查找光标所在单词的上一个匹配项。\n2. 替换 :s/old/new：替换当前行的第一个匹配的 old 为 new。\n:s/old/new/g：替换当前行的所有 old 为 new。\n:%s/old/new/g：替换整个文件中的所有 old 为 new。\n:%s/old/new/gc：替换整个文件中的所有 old 为 new，每次替换前提示确认。\n五、Vim 多窗口与多文件操作 1. 多窗口操作 :split 或 :sp：水平分割窗口。\n:vsplit 或 :vsp：垂直分割窗口。\nCtrl + w, w：在分割窗口之间切换。\nCtrl + w, h/j/k/l：分别向左、下、上、右切换窗口。\n:q：关闭当前窗口。\n2. 多文件操作 :e filename：打开指定文件。\n:bnext 或 :bn：切换到下一个缓冲区（文件）。\n:bprev 或 :bp：切换到上一个缓冲区（文件）。\n:ls：列出所有缓冲区（打开的文件）。\n:bN：切换到缓冲区 N。\n","date":"2025-10-27T09:27:38+08:00","image":"https://www.retr0.qzz.io/post/kali%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E7%8B%B1/vim.webp","permalink":"https://www.retr0.qzz.io/p/vim%E7%9A%84%E4%BD%BF%E7%94%A8/","title":"Vim的使用"},{"content":" 指令 用法 示例 \u0026quot;\u0026quot;(引号) 用引号来查询一个确切的单词或短语 查找有关《百年孤独》这本书的网页，语法：\u0026ldquo;百年孤独\u0026rdquo; OR(或者) 用OR分隔搜索词，同时执行两个搜索查询，这将找到包含多个单词之一的页面。 搜索引用了“Google Drive”、“Dropbox”或“OneDrive”的页面，语法：Google Drive OR Dropbox OR OneDrive -(减号、连字符) 在单词或网站前使用连字符将其从搜索结果中排除 从搜索结果中排除维基百科页面，语法：- site:http://wikipedia.org allintext: 使用allintext:[搜索短语]查找正文中包含这些单词的页面 查找正文中有关Roth、IRA投资讯息的页面，语法：allintext:Roth IRA 投资 allintitle: 使用allintitle:[搜索短语]查找标题中包含这些单词的页面 查找标题中同时包含“Apple”和“notebook”的页面，语法：allintitle:Apple notebook allinurl: 使用allinurl:[搜索短语]查找URL中包含这些单词的页面 查找URL中同时包含”Microsoft” and “Surface”的页面，语法：allinurl:Microsoft Surface site: 使用site:[URL]将搜索结果限制到特定网站 查找云点SEO网关于谷歌SEO的页面，语法：site:http://yundianseo.com 谷歌SEO ~(波浪号) 使用波浪号获得目标关键词及其近似词的搜索结果 查找SEO方面的策略或者教程，语法：SEO ~教程 related: 使用related:[URL]查找与特定网站类似的网站 查找与云点SEO类似的网站，语法：related:http://yundianseo.com define: 使用define:[搜索短语]查找其定义 查找SEO的定义，语法：define:SEO $ 使用$查找特定价格的商品 查找一款售价在99美金的手机，语法：mobile phone $99 location: 使用location:[地点]查看某个地区内的相关信息 查询南京的酒店，语法：hotel location:Nanjing *（星号） 添加星号作为未知单词或事实的占位符 查找以“生活就像一个”开头的引语，语法：生活就像一个* filetype: 使用filetype:[后缀]将结果限制为特定的文件格式，如PDF或DOC。 查找PDF格式的Microsoft Office键盘快捷键相关文件，语法：filetype:pdf Microsoft Office键盘快捷键 ..（两点） 用两个句点分隔数字，不带空格，以搜索该范围内的数字 查找1950年至2000年间发生的计算机里程碑，语法：”计算机里程碑” 1950..2000 AROUND(n) 在两个搜索词之间加上AROUND(n)，以查找两个词间有特定距离的页面。用数字n设置术语之间的最大距离，这对于查找两个搜索词之间的关系很有用。 查找在同一句话或段落中提到Facebook和Microsoft的页面，语法：Facebook AROUND(7) Microsoft ","date":"2025-10-27T09:27:38+08:00","permalink":"https://www.retr0.qzz.io/p/%E8%B0%B7%E6%AD%8C%E6%90%9C%E7%B4%A2%E8%AF%AD%E6%B3%95/","title":"谷歌搜索语法"},{"content":"Hello World! 如果你能看到这篇文章，说明我的博客已经正常开通。\n总之，\n欢迎订阅！\n","date":"2025-10-26T23:13:26+08:00","permalink":"https://www.retr0.qzz.io/p/hello_world/","title":"Hello_world"}]